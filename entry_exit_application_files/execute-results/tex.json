{
  "hash": "d082be4db6a9d6695969921f873f23fc",
  "result": {
    "markdown": "---\ntitle: 参入ゲームの推定（応用編）\nformat:\n  html:\n    toc: true\n    html-math-method: katex\n---\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing CSV\nusing DataFrames\nusing StringEncodings\nusing FixedEffectModels\nusing RegressionTables\nusing Plots\nusing LinearAlgebra\nusing Statistics\nusing Optim\nusing StatsBase\nusing Printf\nusing ForwardDiff\nusing Random\nusing GLM\nusing NLopt\nusing StatsPlots\nusing Distributions\nusing CategoricalArrays\n# using BenchmarkTools\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\ndata_raw = data = CSV.File(\n    open(read, \"data/entry_exit_application/data_hospital_chapter6.csv\", enc\"UTF-8\"),\n    missingstring = [\"NA\", \"\"],\n    ) |> DataFrame\nfirst(data, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=tex}\n\\begin{tabular}{r|ccccccc}\n\t& HospitalID & Prefecture & CityCode & SecondaryAreaName & SecondaryAreaCode & Management & \\\\\n\t\\hline\n\t& Int64 & String15 & Int64 & String31 & Int64? & String? & \\\\\n\t\\hline\n\t1 & 1 & 北海道 & 1101 & 札幌 & 104 & 共済 & $\\dots$ \\\\\n\t2 & 2 & 北海道 & 1101 & 札幌 & 104 & 財団 & $\\dots$ \\\\\n\t3 & 3 & 北海道 & 1101 & 札幌 & 104 & 医療法人 & $\\dots$ \\\\\n\t4 & 4 & 北海道 & 1101 & 札幌 & 104 & 医療法人 & $\\dots$ \\\\\n\t5 & 5 & 北海道 & 1101 & 札幌 & 104 & 医療法人 & $\\dots$ \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\ndata_cleaned = data_raw[:, :];\nreplace!(data_cleaned.Management, missing => \"\");\ndata_cleaned[!, :DaigakuDum] = in([\"公立大学法人\", \"国（国立大学法人）\", \"私立学校法人\"]).(data_cleaned.Management);\ndata_cleaned[!, :ZeroBedDum] = (data_cleaned[:, :NumBeds] .== 0);\n\ndata_cleaned[!, :NumBeds] = data_cleaned[:, :NumBeds] ./ 100.0;\ndata_cleaned[!, :LogNumBeds] = log.(data_cleaned[:, :NumBeds] .+ 0.01);\ndata_cleaned[!, :Population] = data_cleaned[:, :Population] ./ 1e+6;\ndata_cleaned[!, :Menseki] = data_cleaned[:, :Menseki] ./ 100.0;\ndata_cleaned[!, :TaxableIncome] = data_cleaned[:, :TaxableIncome] ./ 1000.0;\ndata_cleaned[!, :LogPop] = log.(data_cleaned[:, :Population]);\ndata_cleaned[!, :LogIncome] = log.(data_cleaned[:, :TaxableIncome]);\n```\n:::\n\n\n## 4\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\ntable_mean = combine(\n    groupby(data_cleaned, :MRIOwnDum),\n    [:Kyukyu, :Kinou, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :NumBeds, :ZeroBedDum, :DaigakuDum] .=> x -> mean(skipmissing(x))\n);\ntable_sd = combine(\n    groupby(data_cleaned, :MRIOwnDum),\n    [:Kyukyu, :Kinou, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :NumBeds, :ZeroBedDum, :DaigakuDum] .=> x -> std(skipmissing(x))\n);\n\ntable_sumstat = DataFrame(table_mean[2, :]);\nappend!(table_sumstat, DataFrame(table_sd[2, :]));\nappend!(table_sumstat, DataFrame(table_mean[1, :]));\nappend!(table_sumstat, DataFrame(table_sd[1, :]));\n\nDataFrame([[names(table_sumstat)]; collect.(eachrow(table_sumstat))], [:column; Symbol.(axes(table_sumstat, 1))])\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=tex}\n\\begin{tabular}{r|ccccc}\n\t& column & 1 & 2 & 3 & 4\\\\\n\t\\hline\n\t& String & Real & Real & Real & Real\\\\\n\t\\hline\n\t1 & MRIOwnDum & 1 & 1 & 0 & 0 \\\\\n\t2 & Kyukyu\\_function & 0.711693 & 0.453042 & 0.302131 & 0.459223 \\\\\n\t3 & Kinou\\_function & 0.0199464 & 0.139837 & 0.00254963 & 0.050434 \\\\\n\t4 & Sien\\_function & 0.0476332 & 0.213021 & 0.00400656 & 0.0631762 \\\\\n\t5 & Hyoka\\_function & 0.433462 & 0.495627 & 0.169368 & 0.375111 \\\\\n\t6 & DepNeurology\\_function & 0.393081 & 0.488507 & 0.121991 & 0.327306 \\\\\n\t7 & DepNeurosurgery\\_function & 0.569643 & 0.4952 & 0.0821194 & 0.274572 \\\\\n\t8 & NumBeds\\_function & 2.07728 & 1.9415 & 0.391861 & 0.710501 \\\\\n\t9 & ZeroBedDum\\_function & 0.058316 & 0.234375 & 0.452934 & 0.497825 \\\\\n\t10 & DaigakuDum\\_function & 0.0416048 & 0.199714 & 0.00454794 & 0.067291 \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nfunction per_MRI_cal(df)\n\n    output = combine(df, nrow => :Total, :MRIOwnDum => sum => :MRIHos)\n    output[!, :PerMRI] = round.(output.MRIHos ./ output.Total .* 100.0, digits = 2)\n    \n    return Matrix(output)\n    \nend\n\nvcat(\n    per_MRI_cal(data_cleaned),\n    per_MRI_cal(dropmissing(data_cleaned, :Kyukyu)[dropmissing(data_cleaned, :Kyukyu).Kyukyu .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :Sien)[dropmissing(data_cleaned, :Sien).Sien .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :Hyoka)[dropmissing(data_cleaned, :Hyoka).Hyoka .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :DepNeurology)[dropmissing(data_cleaned, :DepNeurology).DepNeurology .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :DepNeurosurgery)[dropmissing(data_cleaned, :DepNeurosurgery).DepNeurosurgery .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :LogNumBeds)[dropmissing(data_cleaned, :LogNumBeds).LogNumBeds .>= log(1.2), :]),\n    per_MRI_cal(dropmissing(data_cleaned, :DaigakuDum)[dropmissing(data_cleaned, :DaigakuDum).DaigakuDum .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :ZeroBedDum)[dropmissing(data_cleaned, :ZeroBedDum).ZeroBedDum .== 1, :]),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n9×3 Matrix{Float64}:\n 8862.0  3365.0  37.97\n 4051.0  2392.0  59.05\n  182.0   160.0  87.91\n 2386.0  1456.0  61.02\n 1987.0  1318.0  66.33\n 2365.0  1914.0  80.93\n 2264.0  1932.0  85.34\n  165.0   140.0  84.85\n 2674.0   196.0   7.33\n```\n:::\n:::\n\n\n## 5\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\ndata_processed_pre = dropmissing(data_cleaned[:, [\n            :CityCode, :Kyukyu, :Kinou, :Sien, :Hyoka,\n            :DepNeurology, :DepNeurosurgery, :LogNumBeds,\n            :ZeroBedDum, :DaigakuDum,\n            :Menseki, :LogPop, :LogIncome, :MRIOwnDum\n            ]]);\nfirst(data_processed_pre, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=tex}\n\\begin{tabular}{r|ccccccccc}\n\t& CityCode & Kyukyu & Kinou & Sien & Hyoka & DepNeurology & DepNeurosurgery & LogNumBeds & \\\\\n\t\\hline\n\t& Int64 & Int64 & Int64 & Int64 & Int64 & Int64 & Int64 & Float64 & \\\\\n\t\\hline\n\t1 & 1101 & 1 & 0 & 0 & 0 & 0 & 0 & 0.891998 & $\\dots$ \\\\\n\t2 & 1101 & 0 & 0 & 0 & 0 & 0 & 0 & 0.593327 & $\\dots$ \\\\\n\t3 & 1101 & 1 & 0 & 0 & 0 & 0 & 0 & 0.10436 & $\\dots$ \\\\\n\t4 & 1101 & 1 & 0 & 0 & 0 & 1 & 1 & 0.300105 & $\\dots$ \\\\\n\t5 & 1101 & 0 & 0 & 0 & 0 & 0 & 0 & 0.920283 & $\\dots$ \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nfunction berry_process_data(df)\n    \n    data_processed = df[:, :];\n#     sort!(data_processed, :CityCode);\n    data_processed[!, :TieEntryOrder] = rand(Uniform(), nrow(df));\n    \n    transform!(\n        groupby(data_processed, :CityCode),\n        nrow => :NumPotenHos,\n        :MRIOwnDum => sum => :NumEntryObs\n    );\n    sort!(data_processed, [:CityCode, :LogNumBeds, :TieEntryOrder], rev = [false, true, true]);\n    transform!(groupby(data_processed, :CityCode), :NumPotenHos => (x -> 1:length(x)) => :EntryOrderId);\n    \n    return data_processed\n        \nend\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nberry_process_data (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nRandom.seed!(123)\ndata_processed = berry_process_data(data_processed_pre);\nfirst(data_processed, 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=tex}\n\\begin{tabular}{r|ccccccccc}\n\t& CityCode & Kyukyu & Kinou & Sien & Hyoka & DepNeurology & DepNeurosurgery & LogNumBeds & \\\\\n\t\\hline\n\t& Int64 & Int64 & Int64 & Int64 & Int64 & Int64 & Int64 & Float64 & \\\\\n\t\\hline\n\t1 & 1101 & 1 & 0 & 0 & 0 & 1 & 1 & 2.19165 & $\\dots$ \\\\\n\t2 & 1101 & 1 & 0 & 0 & 0 & 1 & 1 & 2.0931 & $\\dots$ \\\\\n\t3 & 1101 & 0 & 0 & 0 & 0 & 1 & 0 & 1.61939 & $\\dots$ \\\\\n\t4 & 1101 & 0 & 0 & 0 & 0 & 1 & 0 & 1.59939 & $\\dots$ \\\\\n\t5 & 1101 & 0 & 0 & 0 & 0 & 0 & 0 & 1.14103 & $\\dots$ \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nNumPotenHos_max = 4;\ndata_processed = data_processed[data_processed.EntryOrderId .<= NumPotenHos_max, :];\ntransform!(\n    groupby(data_processed, :CityCode),\n    :MRIOwnDum => sum => :NumEntryObs,\n    nrow => :NumPotenHos\n);\ndata_processed[!, :Const] = ones(nrow(data_processed));\ndata_processed[!, :LogEntryOrderId] = log.(data_processed[:, :EntryOrderId]);\nvcat(\n    per_MRI_cal(data_processed),\n    per_MRI_cal(dropmissing(data_processed, :Kyukyu)[dropmissing(data_processed, :Kyukyu).Kyukyu .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :Sien)[dropmissing(data_processed, :Sien).Sien .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :Hyoka)[dropmissing(data_processed, :Hyoka).Hyoka .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :DepNeurology)[dropmissing(data_processed, :DepNeurology).DepNeurology .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :DepNeurosurgery)[dropmissing(data_processed, :DepNeurosurgery).DepNeurosurgery .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :LogNumBeds)[dropmissing(data_processed, :LogNumBeds).LogNumBeds .>= log(1.2), :]),\n    per_MRI_cal(dropmissing(data_processed, :DaigakuDum)[dropmissing(data_processed, :DaigakuDum).DaigakuDum .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :ZeroBedDum)[dropmissing(data_processed, :ZeroBedDum).ZeroBedDum .== 1, :]),\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n9×3 Matrix{Float64}:\n 4112.0  2246.0  54.62\n 2476.0  1745.0  70.48\n  151.0   141.0  93.38\n 1422.0  1097.0  77.14\n 1276.0  1014.0  79.47\n 1697.0  1472.0  86.74\n 1857.0  1628.0  87.67\n  125.0   115.0  92.0\n  646.0    41.0   6.35\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nns = 100;\n\nuniqueCityCode = unique(data_processed.CityCode);\nM = length(uniqueCityCode);\nNumHos = nrow(data_processed);\nNumEntryObs = combine(groupby(data_processed, :CityCode), :NumEntryObs => mean).NumEntryObs_mean;\nNumPotenHos_vec = combine(first, groupby(data_processed, :CityCode)).NumPotenHos;\n```\n:::\n\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nu_m0 = (uniqueCityCode .== permutedims(data_processed.CityCode))' * rand(Normal(), (M, ns));\nu_mIm = rand(Normal(), (NumHos, ns));\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nparam_init = [\n    -0.612340533,   -5.525423772,   -0.505275676,   \n    -0.32531026,    -1.04162392,    -0.991878025,   \n    -3.87040966,    -1.272714254,   2.684741676,    \n    0.040555764,    0.426448612,    -1.399627382,   \n    0.990975782,    0.958075433\n];\nfunction berry_obj(\n        param,\n        df::DataFrame,\n        u_m0::Matrix{Float64},\n        u_mIm::Matrix{Float64},\n        NumEntryObs::Vector{Float64},\n        uniqueCityCode::Vector{Int64},\n        NumPotenHos_vec::Vector{Int64}\n    )\n    \n    alpha = param[1:8];\n    beta = param[9:12];\n    delta = param[13];\n    rho = param[14];\n    \n    var_profit = Matrix(df[:, [:Const, :Menseki, :LogPop, :LogIncome]]) * beta .+ \n        rho .* u_m0;\n    fixed_cost = Matrix(df[:, [:Kyukyu, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :ZeroBedDum, :DaigakuDum]]) * alpha .-\n        (sqrt.(1.0 - rho^2) .* u_mIm);\n\n    prof_excl_comp = var_profit - fixed_cost;\n    \n    function each_entry_func(i)\n        entry_decision_df = hcat(df[:, [:CityCode]], DataFrame((prof_excl_comp .- delta .* log(i) .>= 0), :auto));\n        return (Matrix(combine(groupby(entry_decision_df, :CityCode), Not(:CityCode) .=> sum)[:, Not(:CityCode)]) .>= i) .* i\n    end\n    \n    each_entry_mat = max.(\n        each_entry_func(1),\n        each_entry_func(2),\n        each_entry_func(3),\n        each_entry_func(4)\n    );\n    n_exp = mean(each_entry_mat, dims = 2);\n    \n    diff = mean((NumEntryObs .- n_exp).^2);\n\n    return diff\n    \nend\n@time berry_obj(param_init, data_processed, u_m0, u_mIm, NumEntryObs, uniqueCityCode, NumPotenHos_vec)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  1.684149 seconds (6.25 M allocations: 463.673 MiB, 6.03% gc time, 98.93% compilation time)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n0.3832595058339053\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\n# @benchmark berry_obj(param_init, data_processed, u_m0, u_mIm, NumEntryObs)\nfunction test_nlopt(x::Vector, grad::Vector)\n    if length(grad) != 0\n        ForwardDiff.gradient!(grad, x -> berry_obj(x, data_processed, u_m0, u_mIm, NumEntryObs, uniqueCityCode, NumPotenHos_vec), x)\n    end\n    return berry_obj(x, data_processed, u_m0, u_mIm, NumEntryObs, uniqueCityCode, NumPotenHos_vec)\nend\n\nparam_init = [\n    -0.612340533,   -5.525423772,   -0.505275676,   \n    -0.32531026,    -1.04162392,    -0.991878025,   \n    -3.87040966,    -1.272714254,   2.684741676,    \n    0.040555764,    0.426448612,    -1.399627382,   \n    0.990975782,    0.958075433\n];\n# param_init = vcat(repeat([0.0], 13), 0.95)\n\nopt = NLopt.Opt(:LN_NELDERMEAD, length(param_init))\nopt.lower_bounds = [repeat([-Inf], 13); -1.0]\nopt.upper_bounds = [repeat([Inf], 13); 1.0]\n# opt.xtol_rel = 1e-8\n\nopt.min_objective = test_nlopt\n@time (minf, minx, ret) = NLopt.optimize(opt, param_init)\n\n[param_init minx]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 13.610425 seconds (32.88 M allocations: 29.328 GiB, 11.04% gc time, 2.09% compilation time)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n14×2 Matrix{Float64}:\n -0.612341    -0.623349\n -5.52542    -10.1976\n -0.505276    -0.541076\n -0.32531     -0.325195\n -1.04162     -1.15839\n -0.991878    -1.12713\n -3.87041     -3.56619\n -1.27271     -1.89788\n  2.68474      2.62547\n  0.0405558    0.0338055\n  0.426449     0.392436\n -1.39963     -1.44303\n  0.990976     1.06109\n  0.958075     0.973753\n```\n:::\n:::\n\n\n## 6.2\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nfunction entry_sim(df, delta, prof_excl_comp)\n    N = nrow(df);\n    n = ones(ns);\n    EntryCond = zeros(Int64, N, ns);\n    \n    for i = 1:N\n        net_prof = prof_excl_comp[i, :] .- delta * log.(n);\n        EntryCond[i, net_prof .> 0.0] .= 1;\n        n[net_prof .> 0.0] .+= 1;\n    end\n\n    return vec(mean(EntryCond, dims = 2))\nend\n\nberry_est = minx;\nalpha_est = berry_est[1:8];\nbeta_est = berry_est[9:12];\ndelta_est = berry_est[13];\nrho_est = berry_est[14];\n\nvar_profit = Matrix(data_processed[:, [:Const, :Menseki, :LogPop, :LogIncome]]) * beta_est .+ \n    rho_est .* u_m0;\nfixed_cost = Matrix(data_processed[:, [:Kyukyu, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :ZeroBedDum, :DaigakuDum]]) * alpha_est .-\n    (sqrt.(1.0 - rho_est^2) .* u_mIm);\n\nprof_excl_comp = var_profit - fixed_cost;\n\nEntryProb = map(\n    i -> entry_sim(data_processed[data_processed.CityCode .== i, :], delta_est, prof_excl_comp[data_processed.CityCode .== i, :]), \n    uniqueCityCode\n);\n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\nEntryPred = reduce(vcat, EntryProb) .> 0.5;\ndata_predicted = copy(data_processed);\ndata_predicted[!, :EntryProb] = reduce(vcat, EntryProb);\ndata_predicted[!, :EntryPred] = EntryPred;\ndata_predicted_agg = combine(\n    groupby(data_predicted, :CityCode),\n    :MRIOwnDum => sum => :Actual,\n    :EntryPred => sum => :Predict\n);\n\ndata_predicted_agg = stack(data_predicted_agg, [:Actual, :Predict]);\ndata_predicted_sum = combine(groupby(data_predicted_agg, [:variable, :value]), nrow);\nsort!(data_predicted_sum, [:variable, :value]);\ngroupedbar(\n    data_predicted_sum.nrow, \n    group = data_predicted_sum.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n![](entry_exit_application_files/figure-pdf/cell-16-output-1.svg){fig-pos='H'}\n:::\n:::\n\n\n\n\n## 7\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\ndata_cf = copy(data_processed);\nsort!(data_cf, [:CityCode, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :TieEntryOrder], rev = [false, true, true, true, true]);\ntransform!(groupby(data_cf, :CityCode), :NumPotenHos => (x -> 1:length(x)) => :EntryOrderId);\nvar_profit_cf = Matrix(data_cf[:, [:Const, :Menseki, :LogPop, :LogIncome]]) * beta_est .+ \n    rho_est .* u_m0;\nfixed_cost_cf = Matrix(data_cf[:, [:Kyukyu, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :ZeroBedDum, :DaigakuDum]]) * alpha_est .-\n    (sqrt.(1.0 - rho_est^2) .* u_mIm);\n\nprof_excl_comp_cf = var_profit_cf - fixed_cost_cf;\nprof_excl_comp_cf[(data_cf.DepNeurology .== 1) .| (data_cf.DepNeurosurgery .== 1), :] .= 1e+5;\n```\n:::\n\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\nEntryProb_cf = map(\n    i -> entry_sim(data_cf[data_cf.CityCode .== i, :], delta_est, prof_excl_comp_cf[data_cf.CityCode .== i, :]), \n    uniqueCityCode\n);\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.julia .cell-code}\nEntryPred_cf = reduce(vcat, EntryProb_cf) .> 0.5;\ndata_predicted_cf = copy(data_processed);\ndata_predicted_cf[!, :EntryProb] = reduce(vcat, EntryProb_cf);\ndata_predicted_cf[!, :EntryPred] = EntryPred_cf;\ndata_predicted_cf_agg = combine(\n    groupby(data_predicted_cf, :CityCode),\n    :MRIOwnDum => sum => :Actual,\n    :EntryPred => sum => :CounterFactual\n);\n\ndata_predicted_cf_agg = stack(data_predicted_cf_agg, [:Actual, :CounterFactual]);\ndata_predicted_cf_sum = combine(groupby(\n    vcat(data_predicted_agg, data_predicted_cf_agg[data_predicted_cf_agg.variable .== \"CounterFactual\", :]),\n    [:variable, :value]\n    ), nrow);\n\ntransform!(\n    data_predicted_cf_sum, \n    :variable => \n    (x -> categorical(x; ordered = true, levels = [\"Actual\", \"Predict\", \"CounterFactual\"])) => \n    :variable\n    )\nsort!(data_predicted_cf_sum, [:variable, :value]);\ngroupedbar(\n    data_predicted_cf_sum.nrow, \n    group = data_predicted_cf_sum.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n![](entry_exit_application_files/figure-pdf/cell-20-output-1.svg){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.julia .cell-code}\nvcat(\n    combine(groupby(\n        data_predicted_agg, :variable\n        ), :value => sum),\n    combine(groupby(\n        data_predicted_cf_agg, :variable\n        ), :value => sum) |> \n        filter(:variable => (x -> x .== \"CounterFactual\"))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=tex}\n\\begin{tabular}{r|cc}\n\t& variable & value\\_sum\\\\\n\t\\hline\n\t& String & Int64\\\\\n\t\\hline\n\t1 & Actual & 2246 \\\\\n\t2 & Predict & 2267 \\\\\n\t3 & CounterFactual & 2508 \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.julia .cell-code}\ndata_predicted_agg_wo_neuro = combine(\n    groupby(\n        filter([:DepNeurology, :DepNeurosurgery] => ((d1, d2) -> (d1 .== 1) .& (d2 .== 1)), data_predicted),\n        :CityCode\n        ),\n    :MRIOwnDum => sum => :Actual,\n    :EntryPred => sum => :Predict\n);\n\ndata_predicted_agg_wo_neuro = stack(data_predicted_agg_wo_neuro, [:Actual, :Predict]);\ndata_predicted_sum_wo_neuro = combine(groupby(data_predicted_agg_wo_neuro, [:variable, :value]), nrow);\n\ndata_predicted_cf_agg_wo_neuro = combine(\n    groupby(\n        # data_predicted_cf, \n        filter([:DepNeurology, :DepNeurosurgery] => ((d1, d2) -> (d1 .== 1) .& (d2 .== 1)), data_predicted_cf),\n        :CityCode\n        ),\n    :MRIOwnDum => sum => :Actual,\n    :EntryPred => sum => :CounterFactual\n);\n\ndata_predicted_cf_agg_wo_neuro = stack(data_predicted_cf_agg_wo_neuro, [:Actual, :CounterFactual]);\n\ndata_predicted_cf_sum_wo_neuro = combine(groupby(\n    vcat(\n        data_predicted_agg_wo_neuro, \n        data_predicted_cf_agg_wo_neuro[data_predicted_cf_agg_wo_neuro.variable .== \"CounterFactual\", :]\n        ),\n    [:variable, :value]\n    ), nrow)\n\ntransform!(\n    data_predicted_cf_sum_wo_neuro, \n    :variable => \n    (x -> categorical(x; ordered = true, levels = [\"Actual\", \"Predict\", \"CounterFactual\"])) => \n    :variable\n    )\nsort!(data_predicted_cf_sum_wo_neuro, [:variable, :value]);\ngroupedbar(\n    data_predicted_cf_sum_wo_neuro.nrow, \n    group = data_predicted_cf_sum_wo_neuro.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n![](entry_exit_application_files/figure-pdf/cell-22-output-1.svg){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.julia .cell-code}\nvcat(\n    combine(groupby(\n        data_predicted_agg_wo_neuro, :variable\n        ), :value => sum),\n    combine(groupby(\n        data_predicted_cf_agg_wo_neuro, :variable\n        ), :value => sum) |> \n        filter(:variable => (x -> x .== \"CounterFactual\"))\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=tex}\n\\begin{tabular}{r|cc}\n\t& variable & value\\_sum\\\\\n\t\\hline\n\t& String & Int64\\\\\n\t\\hline\n\t1 & Actual & 761 \\\\\n\t2 & Predict & 821 \\\\\n\t3 & CounterFactual & 809 \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n\n\n",
    "supporting": [
      "entry_exit_application_files"
    ],
    "filters": []
  }
}