[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "【非公式】実証ビジネス・エコノミクス Juliaでの実装",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "single_agent_dynamic_basic.html#section",
    "href": "single_agent_dynamic_basic.html#section",
    "title": "7  シングルエージェント動学モデルの推定（基礎編）",
    "section": "7.1 4",
    "text": "7.1 4\n\ntransform!(\n    groupby(data_gen, :consumer_id), \n    [:price, :mileage, :action] .=> ShiftedArrays.lag\n    )\n\n\n120000×9 DataFrame119975 rows omittedRowstateactionperiodconsumer_idpricemileageprice_lagmileage_lagaction_lagInt64Int64Int64Int64Int64Int64Int64?Int64?Int64?160481125000missingmissingmissing2120482125005250000318048312500102500504140484121001025001005250485120002021001006280486123002020002007280487123002023002008270488122002023002009270489122002022002001034049012300252200200113104911200025230025012320492121002520002501334049312300252100250⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮119989630589100022005023004001199907105901000240055220050011999169059110002200552400550119992680592100021005522005501199936705931000200055210055011999468059410002100552000550119995750595100022006021005501199967305961000200060220060011999778059710002500602000600119998780598100025006025006001199997605991000230060250060012000078060010002500602300600\n\n\n\nnum_cond_obs_mileage = combine(\n    groupby(\n        transform(\n            data_gen |>\n                filter(:period => (x -> x != (num_period - num_period_obs + 1))),\n            [:mileage_lag, :mileage, :action_lag] =>\n            ByRow(\n                (mileage_lag, mileage, action_lag) ->\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 95) & (mileage_lag == mileage)) |\n                    ((action_lag == 1) & (mileage == 0))\n                    ) ? \"cond_obs_mileage1\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 5)) |\n                    ((action_lag == 1) & (mileage == 5))\n                    ) ? \"cond_obs_mileage2\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 10)) |\n                    ((action_lag == 1) & (mileage == 10))\n                    ) ? \"cond_obs_mileage3\" :\n                (\n                    ((action_lag == 0) & (mileage_lag == 95) & (mileage == 100))\n                    ) ? \"cond_obs_mileage4\" :\n                \"other\"\n            ) =>\n            :cond_obs_mileage\n            ),\n        [:cond_obs_mileage]\n        ),\n    nrow => :num_cond_obs\n) |> filter(:cond_obs_mileage => (x -> (x != \"other\")));\n\nnum_cond_obs_mileage = Dict(\n    k => v[1, \"num_cond_obs\"] \n    for ((k, ), v) in pairs(groupby(num_cond_obs_mileage, :cond_obs_mileage))\n    );\n\n\nkappa_est = zeros(2);\n\nkappa_est[1] = num_cond_obs_mileage[\"cond_obs_mileage2\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est[2] = num_cond_obs_mileage[\"cond_obs_mileage3\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est\n\n2-element Vector{Float64}:\n 0.2507060588583926\n 0.05038686722769128\n\n\n\nInfomat_mileage_est = zeros((2, 2));\n\nInfomat_mileage_est[1, 1] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] / kappa_est[1]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[1, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[2, 1] = Infomat_mileage_est[1, 2];\n\nInfomat_mileage_est[2, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage3\"] / kappa_est[2]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nkappa_se = sqrt.(diag(inv(Infomat_mileage_est)));\n\n\nDataFrame(kappa_est = kappa_est, kappa_se = kappa_se)\n\n\n2×2 DataFrameRowkappa_estkappa_seFloat64Float6410.2507060.001309820.05038690.000662066\n\n\n\nnum_cond_obs_price = combine(\n    groupby(\n        data_gen |>\n            filter(:period => (x -> x != (num_period - num_period_obs + 1))),\n        [:price_lag, :price]\n    ),\n    nrow => :num_cond_obs\n)\n\nnum_cond_obs_price = [\n    (\n        num_cond_obs_price |> \n            filter([:price_lag, :price] => ((price_lag, price) -> ((price_lag == p_lag) & (price == p))))\n    )[1, :num_cond_obs]\n    for p_lag in price_states, p in price_states\n]\n\nlambda_est_mat = num_cond_obs_price ./ sum(num_cond_obs_price, dims = 2)\n\n6×6 Matrix{Float64}:\n 0.0992722  0.101205   0.196952  0.198431  0.205254  0.198886\n 0.104459   0.10081    0.200023  0.201733  0.20447   0.188505\n 0.0998312  0.0979389  0.29888   0.205646  0.197719  0.0999847\n 0.101128   0.098588   0.197836  0.300843  0.200477  0.101128\n 0.0495297  0.0498236  0.1       0.100911  0.50047   0.199265\n 0.0486584  0.0509654  0.103705  0.100511  0.198112  0.498048\n\n\n\n# TODO\nlambda_se = zeros(num_price_states)\n\n6-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\nlambda_est = lambda_est_mat'[lambda_est_mat' .!= diag(lambda_est_mat)]\n\n30-element Vector{Float64}:\n 0.10120536729588356\n 0.1969524675915397\n 0.19843074823743462\n 0.2052535819877189\n 0.1988856038207869\n 0.10445888926901585\n 0.20002280761774432\n 0.20173337894856883\n 0.20447029307788803\n 0.1885049606568594\n 0.09983122794456094\n 0.09793893520175932\n 0.2056461924001432\n ⋮\n 0.20047744819179195\n 0.10112759041040227\n 0.04952968841857731\n 0.04982363315696649\n 0.1\n 0.10091122868900647\n 0.19926513815402705\n 0.04865843270868825\n 0.050965360590573536\n 0.1037052810902896\n 0.10051107325383304\n 0.19811186825667235"
  },
  {
    "objectID": "single_agent_dynamic_basic.html#section-1",
    "href": "single_agent_dynamic_basic.html#section-1",
    "title": "7  シングルエージェント動学モデルの推定（基礎編）",
    "section": "7.2 5",
    "text": "7.2 5\n\nfunction logLH_stat(\n    theta,\n    states_matrix::Matrix{Int},\n    data_gen::DataFrame\n)\n    U = flow_utility(theta, states_matrix);\n    prob_C_stat = exp.(U) ./ sum(exp.(U), dims = 2);\n    return sum(log.([prob_C_stat[x.state, x.action + 1] for x in eachrow(data_gen)]))\nend\n\nlogLH_stat (generic function with 1 method)\n\n\n\nobjFunc_for_Optim_stat = TwiceDifferentiable(\n    x -> - logLH_stat(x, states_matrix, data_gen),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time logit_stat_opt = optimize(\n    objFunc_for_Optim_stat,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     2.297333e+04     7.561388e+06\n\n\n * time: 0.008337020874023438\n\n\n     1     1.468656e+04     3.971824e+06\n * time: 0.39047908782958984\n\n\n     2     1.407678e+04     3.143506e+06\n * time: 0.49204516410827637\n\n\n     3     1.355774e+04     1.214883e+06\n * time: 0.5796630382537842\n\n\n     4     1.350421e+04     2.487112e+04\n * time: 0.6638731956481934\n\n\n     5     1.350416e+04     2.355812e+01\n * time: 0.7518479824066162\n\n\n     6     1.350416e+04     7.915900e-06\n * time: 0.8671920299530029\n\n\n     7     1.350416e+04     3.805326e-09\n * time: 0.9517052173614502\n\n\n  2.842353 seconds (23.66 M allocations: 986.754 MiB, 7.67% gc time, 73.57% compilation time)\n\n\n * Status: success\n\n * Candidate solution\n    Final objective value:     1.350416e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 5.38e-14 ≰ 0.0e+00\n    |x - x'|/|x'|          = 1.26e-12 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.35e-16 ≰ 0.0e+00\n    |g(x)|                 = 3.81e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    7\n    f(x) calls:    17\n    ∇f(x) calls:   17\n    ∇²f(x) calls:  7\n\n\n\ntheta_est_stat = logit_stat_opt.minimizer;\n\nhessian_stat = ForwardDiff.hessian(\n    x -> - logLH_stat(x, states_matrix, data_gen),\n    logit_stat_opt.minimizer\n    );\n\ntheta_se_stat = sqrt.(diag(inv(hessian_stat)));\n\n\nDataFrame(theta_est_stat = theta_est_stat, theta_se_stat = theta_se_stat)\n\n\n2×2 DataFrameRowtheta_est_stattheta_se_statFloat64Float6410.04281710.00069209920.002376471.9178e-5\n\n\n\n7.2.1 5.2\n\nmileage_trans_mat_hat = zeros((num_mileage_states, num_mileage_states, num_choice));\ngen_mileage_trans!(kappa_est, num_mileage_states, mileage_trans_mat_hat);\n\nprice_trans_mat_hat = zeros(num_price_states, num_price_states);\ngen_price_trans!(lambda_est, num_price_states, price_trans_mat_hat);\n\ntrans_mat_hat = Array{Float64}(undef, num_states, num_states, num_choice);\nfor i in 1:num_choice\n    trans_mat_hat[:, :, i] = kron(mileage_trans_mat_hat[:, :, i], price_trans_mat_hat);\nend\n\n\nfunction logLH(\n    theta,\n    beta::Float64,\n    trans_mat::Array{Float64, 3},\n    states_matrix::Matrix{Int},\n    data_gen::DataFrame\n)\n\n    EV = contraction(theta, beta, trans_mat, states_matrix);\n    \n    U = flow_utility(theta, states_matrix);\n    V_CS = U + beta .* EV;\n\n    prob_C = exp.(V_CS) ./ sum(exp.(V_CS), dims = 2);\n\n    return sum(log.([prob_C[x.state, x.action + 1] for x in eachrow(data_gen)]))\nend\n\nlogLH (generic function with 1 method)\n\n\n\nobjFunc_for_Optim = TwiceDifferentiable(\n    x -> - logLH(x, beta, trans_mat_hat, states_matrix, data_gen),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time NFXP_opt = optimize(\n    objFunc_for_Optim,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     1.333725e+04     5.946862e+03\n * time: 9.608268737792969e-5\n\n\n     1     1.333722e+04     3.170489e+00\n * time: 1.4641339778900146\n\n\n     2     1.333722e+04     4.639569e-07\n * time: 2.9518020153045654\n\n\n     3     1.333722e+04     3.080640e-08\n * time: 4.066781997680664\n\n\n     4     1.333722e+04     4.640242e-08\n * time: 5.191215991973877\n\n\n     5     1.333722e+04     3.628702e-08\n * time: 6.290945053100586\n\n\n     6     1.333722e+04     6.017217e-09\n * time: 6.922192096710205\n\n\n 10.460664 seconds (25.64 M allocations: 22.485 GiB, 17.05% gc time, 25.76% compilation time)\n\n\n * Status: success (objective increased between iterations)\n\n * Candidate solution\n    Final objective value:     1.333722e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 9.54e-18 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.37e-15 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.36e-16 ≰ 0.0e+00\n    |g(x)|                 = 6.02e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   7  (vs limit Inf)\n    Iterations:    6\n    f(x) calls:    15\n    ∇f(x) calls:   15\n    ∇²f(x) calls:  6\n\n\n\ntheta_est = NFXP_opt.minimizer;\n\nhessian = ForwardDiff.hessian(\n    x -> - logLH(x, beta, trans_mat_hat, states_matrix, data_gen),\n    NFXP_opt.minimizer\n    );\n\ntheta_se = sqrt.(diag(inv(hessian)));\n\n\nDataFrame(theta_est = theta_est, theta_se = theta_se)\n\n\n2×2 DataFrameRowtheta_esttheta_seFloat64Float6410.004018268.88337e-520.003004553.67953e-5\n\n\n\nCSV.write(\"tmp/single_agent_dynamic_basic/data_gen.csv\", data_gen);"
  },
  {
    "objectID": "demand_estimation_1.html#data-cleaning",
    "href": "demand_estimation_1.html#data-cleaning",
    "title": "2  需要モデルの推定（基礎編 1）",
    "section": "2.1 Data cleaning",
    "text": "2.1 Data cleaning\n\ndata = data[!, [\n        :Maker, :Type, :Name, :Year, :Sales, \n        :Model, :price, :kata, :weight, :FuelEfficiency, \n        :HorsePower, :overall_length, :overall_width, :overall_height\n        ]]\nrename!(data, \"Year\" => \"year\")\ndata = leftjoin(data, dataHH, on = :year)\ndata = leftjoin(data, dataCPI, on = :year)\nfirst(data, 5)\n\n\n5×16 DataFrameRowMakerTypeNameyearSalesModelpricekataweightFuelEfficiencyHorsePoweroverall_lengthoverall_widthoverall_heightHHCPIString15String7String31Int64Int64StringFloat64String15Int64Float64?Int64?Int64Int64Int64Int64?Float64?1AudiForeignA1シリーズ201142061.4 TFSI289.0DBA-8XCAX119019.41223970174014405378343596.32AudiForeignA1シリーズ201245021.4 TFSI273.0DBA-8XCAX119019.41223970174014405417147596.23AudiForeignA1シリーズ201350711.4 TFSI273.0DBA-8XCAX119019.41223970174014405459474496.64AudiForeignA3シリーズ20064830アトラクション284.0GH-8PBSE136012.21024285176514305110200597.25AudiForeignA3シリーズ20073874アトラクション286.0GH-8PBSE136012.21024285176514305171304897.2\n\n\n\ndropmissing!(data, :FuelEfficiency);\n\n\ncpi2016 = dataCPI[dataCPI.year .== 2016, \"CPI\"][1]\ndata[!, :price] = data.price ./ (data.CPI / cpi2016) / 100;\n\n\ndata[!, :size] = (data[:, :overall_length] / 1000) .* (data[:, :overall_width] / 1000) .* (data[:, :overall_height] / 1000);\ndata[!, :hppw] = data[:, :HorsePower] ./ data[:, :weight];\n\nunique_name = unique(data[!, [:Name]])\nunique_name[!, :NameID] = rownumber.(eachrow(unique_name))\ndata = leftjoin(data, unique_name, on = :Name);\n\ndata = transform(\n    groupby(data, :year),\n    :Sales => sum => :inside_total\n);\ndata[!, :outside_total] = data.HH .- data.inside_total;\ndata[!, :share] = data.Sales ./ data.HH;\ndata[!, :share0] = data.outside_total ./ data.HH;\n\n\ntransform!(\n    groupby(data, [:year, :Maker]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_own, :FuelEfficiency_sum_own, :size_sum_own],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_own, :FuelEfficiency_sqr_sum_own, :size_sqr_sum_own],\n    nrow => \"group_n\"\n);\ntransform!(\n    groupby(data, [:year]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_mkt, :FuelEfficiency_sum_mkt, :size_sum_mkt],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_mkt, :FuelEfficiency_sqr_sum_mkt, :size_sqr_sum_mkt],\n    nrow => \"mkt_n\"\n);\n\n\ndata[!, :iv_BLP_own_hppw]             = data[:, :hppw_sum_own]           .- data[:, :hppw];\ndata[!, :iv_BLP_own_FuelEfficiency]   = data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency];\ndata[!, :iv_BLP_own_size]             = data[:, :size_sum_own]           .- data[:, :size];\ndata[!, :iv_BLP_other_hppw]           = data[:, :hppw_sum_mkt]           .- data[:, :hppw_sum_own];\ndata[!, :iv_BLP_other_FuelEfficiency] = data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own];\ndata[!, :iv_BLP_other_size]           = data[:, :size_sum_mkt]           .- data[:, :size_sum_own];\n\n\ndata[!, :iv_GH_own_hppw]             = (\n    (data[:, :group_n] .- 1) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_own] .- data[:, :hppw].^2) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_own] .- data[:, :hppw])\n);\ndata[!, :iv_GH_own_FuelEfficiency]   = (\n    (data[:, :group_n] .- 1) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_own] .- data[:, :FuelEfficiency].^2) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency])\n);\ndata[!, :iv_GH_own_size]             = (\n    (data[:, :group_n] .- 1) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_own] .- data[:, :size].^2) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_own] .- data[:, :size])\n);\ndata[!, :iv_GH_other_hppw]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_mkt] .- data[:, :hppw_sqr_sum_own]) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_mkt] .- data[:, :hppw_sum_own])\n);\ndata[!, :iv_GH_other_FuelEfficiency] = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_mkt] .- data[:, :FuelEfficiency_sqr_sum_own]) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own])\n);\ndata[!, :iv_GH_other_size]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_mkt] .- data[:, :size_sqr_sum_own]) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_mkt] .- data[:, :size_sum_own])\n);\n\n\nNIPPYOautoIDvec = [\n    260, 4, 76, 104, 64, 54, 152, 153, 71, 197,\n    42, 45, 114, 208, 209, 77, 236, 58, 127, 187,\n    79, 175, 19, 117, 216, 112, 256, 119, 37, 158\n];\n\n\ndata_NIPPYO = data[in(NIPPYOautoIDvec).(data[:, :NameID]), [:Sales, :price, :hppw, :FuelEfficiency, :size]];\ndata_NIPPYO[!, :log_sales] = log.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log_price] = log.(data_NIPPYO[:, :price]);\ndata_NIPPYO[!, :log10_sales] = log10.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log10_price] = log10.(data_NIPPYO[:, :price]);\n\n\nols_intro = reg(\n    data_NIPPYO, \n    @formula(log_sales ~ log_price + hppw + FuelEfficiency + size),\n    Vcov.robust()\n)\n\n                                 FixedEffectModel                                 \n==================================================================================\nNumber of obs:                       196  Converged:                          true\ndof (model):                           4  dof (residuals):                     190\nR²:                                0.217  R² adjusted:                       0.201\nF-statistic:                     19.1148  P-value:                           0.000\n==================================================================================\n                  Estimate  Std. Error    t-stat  Pr(>|t|)    Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────────────────\nlog_price       -1.24828     0.309545   -4.03262    <1e-04   -1.85886    -0.63769\nhppw            -4.19685     3.97622    -1.05549    0.2925  -12.0401      3.64635\nFuelEfficiency   0.0886034   0.0283887   3.12108    0.0021    0.0326059   0.144601\nsize             0.306896    0.0588927   5.2111     <1e-06    0.190728    0.423063\n(Intercept)      5.76211     1.06127     5.42946    <1e-06    3.66873     7.85549\n==================================================================================\n\n\n\nfit_line = predict(\n    lm(@formula(log10_sales ~ log10_price), data_NIPPYO)\n    );\nplot(\n    data_NIPPYO.price, \n    data_NIPPYO.Sales, \n    seriestype = :scatter, \n    legend = false,\n    xscale = :log10,\n    yscale = :log10,\n    xlabel = \"Price\",\n    ylabel = \"Sales\",\n    xticks = ([1, 3, 10], [1, 3, 10]),\n)\nplot!(\n    data_NIPPYO.price, \n    10 .^ fit_line,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndescribe(data[:, [:Sales, :price, :FuelEfficiency, :size, :hppw]])\n\n\n5×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64RealFloat64RealInt64DataType1Sales24586.4108544.03176750Int642price2.530470.7051762.0504212.62650Float643FuelEfficiency16.15975.515.440.80Float644size11.50535.90911.472519.15480Float645hppw0.09913120.0450.09268290.3238640Float64\n\n\n\ndata[!, :logit_share] = log.(data[:, :share]) .- log.(data[:, :share0]);\n\n\nols_res = reg(data, @formula(logit_share ~ price + hppw + FuelEfficiency + size), Vcov.robust());\niv_BLP_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust()\n);\niv_GH_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust(),\n    save = true\n);\n\n\nregtable(ols_res, iv_BLP_res, iv_GH_res)\n\n\n--------------------------------------------------------------\n                                       logit_share            \n                          ------------------------------------\n                                 (1)          (2)          (3)\n--------------------------------------------------------------\n(Intercept)               -12.255***   -12.323***   -12.973***\n                             (0.365)      (0.382)      (0.393)\nprice                      -0.255***    -0.283***    -0.552***\n                             (0.026)      (0.067)      (0.080)\nhppw                          -0.654        0.213      8.426**\n                             (1.284)      (2.298)      (2.638)\nFuelEfficiency              0.130***     0.130***     0.127***\n                             (0.010)      (0.010)      (0.010)\nsize                        0.182***     0.187***     0.236***\n                             (0.019)      (0.021)      (0.022)\n--------------------------------------------------------------\nEstimator                        OLS           IV           IV\n--------------------------------------------------------------\nN                              1,823        1,823        1,823\nR2                             0.222        0.222        0.180\nWithin-R2                                                     \nFirst-stage F statistic                    33.926       51.583\n--------------------------------------------------------------\n\n\n\n\niv1st_BLP_res = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n        ),\n    Vcov.robust()\n);\niv1st_GH_res = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n        ),\n    Vcov.robust()\n);\n\n\nregtable(iv1st_BLP_res, iv1st_GH_res)\n\n\n---------------------------------------------------\n                                      price        \n                              ---------------------\n                                    (1)         (2)\n---------------------------------------------------\n(Intercept)                      -3.159    -1.325**\n                                (1.685)     (0.423)\nhppw                          28.749***   23.508***\n                                (0.993)     (1.547)\nFuelEfficiency                   -0.011   -0.072***\n                                (0.008)     (0.014)\nsize                           0.202***    0.189***\n                                (0.015)     (0.020)\niv_BLP_own_hppw                 -0.728*            \n                                (0.336)            \niv_BLP_own_FuelEfficiency     -0.007***            \n                                (0.001)            \niv_BLP_own_size                0.013***            \n                                (0.004)            \niv_BLP_other_hppw                 0.165            \n                                (0.255)            \niv_BLP_other_FuelEfficiency     0.001**            \n                                (0.000)            \niv_BLP_other_size                -0.002            \n                                (0.003)            \niv_GH_own_hppw                            -1.889***\n                                            (0.439)\niv_GH_own_FuelEfficiency                      0.000\n                                            (0.000)\niv_GH_own_size                            -0.001***\n                                            (0.000)\niv_GH_other_hppw                           0.423***\n                                            (0.096)\niv_GH_other_FuelEfficiency                 0.000***\n                                            (0.000)\niv_GH_other_size                           0.000***\n                                            (0.000)\n---------------------------------------------------\nN                                 1,823       1,823\nR2                                0.616       0.623\n---------------------------------------------------\n\n\n\n\ndata[!, :own_elas_ols]   = ols_res.coef[ols_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\ndata[!, :own_elas_ivblp] = iv_BLP_res.coef[iv_BLP_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\ndata[!, :own_elas_ivgh]  = iv_GH_res.coef[iv_GH_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\n\n\ndescribe(data[:, r\"^own_elas\"])\n\n\n3×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64Float64Float64Float64Int64DataType1own_elas_ols-0.645328-3.22104-0.522324-0.1798920Float642own_elas_ivblp-0.717085-3.5792-0.580404-0.1998950Float643own_elas_ivgh-1.3967-6.9714-1.13048-0.3893460Float64\n\n\n\ndt_application = data[:, [:NameID, :year, :Sales, :price, :FuelEfficiency, :size, :hppw, :HH, :share]];\ndt_application[!, :xi_fit] = iv_GH_res.residuals;\n\n\nNameID_target = 197\ndt_application[(dt_application.year .== 2016) .& (dt_application.NameID .== NameID_target), :]\n\n\n1×10 DataFrameRowNameIDyearSalespriceFuelEfficiencysizehppwHHsharexi_fitInt64?Int64Int64Float64Float64Float64Float64Int64?Float64Float64?11972016370693.19811.617.09440.0947917569507570.0006508961.16401\n\n\n\nfunction f_share(\n        price_cand,\n        year, \n        NameID_target,\n        dt,\n        est_res\n    )\n    \n    dt = dt[dt.year .== year, :]\n    dt[!, :temp_price] = dt[:, :price]\n    dt[(dt[:, :NameID] .== NameID_target), :temp_price] .= price_cand\n    dt[!, :delta] = (\n        est_res.coef[est_res.coefnames .== \"(Intercept)\"] .+\n        est_res.coef[est_res.coefnames .== \"hppw\"] .* dt[:, :hppw] .+\n        est_res.coef[est_res.coefnames .== \"FuelEfficiency\"] .* dt[:, :FuelEfficiency] .+\n        est_res.coef[est_res.coefnames .== \"size\"] .* dt[:, :size] .+\n        est_res.coef[est_res.coefnames .== \"price\"] .* dt[:, :temp_price] .+\n        dt[:, :xi_fit]\n    )\n    dt[!, :denom] .= 1 .+ sum(exp.(dt[:, :delta]))\n    dt[!, :pred_sales] = exp.(dt[:, :delta]) ./ dt[:, :denom] .* dt[:, :HH]\n    dt = dt[dt.NameID .== NameID_target, :]\n    \n    return dt.pred_sales[1]\n    \nend\n\nf_share (generic function with 1 method)\n\n\n\npricevec = range(0.3, 5, step = 0.05);\nquantvec = f_share.(pricevec, 2016, NameID_target, Ref(dt_application), Ref(iv_GH_res));\n\n\nplot(quantvec, pricevec, xticks = [50000, 100000, 150000], legend = false)\nxlabel!(\"Sales\")\nylabel!(\"Price (million JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(pricevec, pricevec .* quantvec / 1000, legend = false)\nxlabel!(\"Price (million JPY)\")\nylabel!(\"Revenue (billion JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nopt_res = optimize(\n    x -> - f_share(x[1], 2016, NameID_target, dt_application, iv_GH_res) * x[1],\n    [1.0]\n);\n\n@printf(\"Revenue-maximizing price: %.3f \\n\", opt_res.minimizer[1])\n@printf(\"Max revenue : %.3f\", -opt_res.minimum)\n\nRevenue-maximizing price: 1.814 \nMax revenue : 144273.836"
  },
  {
    "objectID": "single_agent_dynamic_application.html#section",
    "href": "single_agent_dynamic_application.html#section",
    "title": "8  シングルエージェント動学モデルの推定（応用編）",
    "section": "8.1 4",
    "text": "8.1 4\n\ntheta_true = [0.004, 0.003];\n\nbeta = 0.99;\n\nEuler_const = Float64(MathConstants.eulergamma);\n\nnum_choice = 2;\n\n\nnum_cond_obs_mileage = combine(\n    groupby(\n        transform(\n            data_gen |>\n                filter(:period => (x -> x != minimum(data_gen.period))),\n            [:mileage_lag, :mileage, :action_lag] =>\n            ByRow(\n                (mileage_lag, mileage, action_lag) ->\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 95) & (mileage_lag == mileage)) |\n                    ((action_lag == 1) & (mileage == 0))\n                    ) ? \"cond_obs_mileage1\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 5)) |\n                    ((action_lag == 1) & (mileage == 5))\n                    ) ? \"cond_obs_mileage2\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 10)) |\n                    ((action_lag == 1) & (mileage == 10))\n                    ) ? \"cond_obs_mileage3\" :\n                (\n                    ((action_lag == 0) & (mileage_lag == 95) & (mileage == 100))\n                    ) ? \"cond_obs_mileage4\" :\n                \"other\"\n            ) =>\n            :cond_obs_mileage\n            ),\n        [:cond_obs_mileage]\n        ),\n    nrow => :num_cond_obs\n) |> filter(:cond_obs_mileage => (x -> (x != \"other\")));\n\nnum_cond_obs_mileage = Dict(\n    k => v[1, \"num_cond_obs\"] \n    for ((k, ), v) in pairs(groupby(num_cond_obs_mileage, :cond_obs_mileage))\n    );\n\n\nkappa_est = zeros(2);\n\nkappa_est[1] = num_cond_obs_mileage[\"cond_obs_mileage2\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est[2] = num_cond_obs_mileage[\"cond_obs_mileage3\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est\n\n2-element Vector{Float64}:\n 0.2507060588583926\n 0.05038686722769128\n\n\n\nInfomat_mileage_est = zeros((2, 2));\n\nInfomat_mileage_est[1, 1] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] / kappa_est[1]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[1, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[2, 1] = Infomat_mileage_est[1, 2];\n\nInfomat_mileage_est[2, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage3\"] / kappa_est[2]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nkappa_se = sqrt.(diag(inv(Infomat_mileage_est)));\n\n\nDataFrame(kappa_est = kappa_est, kappa_se = kappa_se)\n\n\n2×2 DataFrameRowkappa_estkappa_seFloat64Float6410.2507060.001309820.05038690.000662066\n\n\n\nnum_cond_obs_price = combine(\n    groupby(\n        data_gen |>\n            filter(:period => (x -> x != (minimum(data_gen.period)))),\n        [:price_lag, :price]\n    ),\n    nrow => :num_cond_obs\n)\n\nnum_cond_obs_price = [\n    (\n        num_cond_obs_price |> \n            filter([:price_lag, :price] => ((price_lag, price) -> ((price_lag == p_lag) & (price == p))))\n    )[1, :num_cond_obs]\n    for p_lag in price_states, p in price_states\n]\n\nlambda_est_mat = num_cond_obs_price ./ sum(num_cond_obs_price, dims = 2)\n\n6×6 Matrix{Float64}:\n 0.0992722  0.101205   0.196952  0.198431  0.205254  0.198886\n 0.104459   0.10081    0.200023  0.201733  0.20447   0.188505\n 0.0998312  0.0979389  0.29888   0.205646  0.197719  0.0999847\n 0.101128   0.098588   0.197836  0.300843  0.200477  0.101128\n 0.0495297  0.0498236  0.1       0.100911  0.50047   0.199265\n 0.0486584  0.0509654  0.103705  0.100511  0.198112  0.498048\n\n\n\n# TODO\nlambda_se = zeros(num_price_states)\n\n6-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\nlambda_est = lambda_est_mat'[lambda_est_mat' .!= diag(lambda_est_mat)]\n\n30-element Vector{Float64}:\n 0.10120536729588356\n 0.1969524675915397\n 0.19843074823743462\n 0.2052535819877189\n 0.1988856038207869\n 0.10445888926901585\n 0.20002280761774432\n 0.20173337894856883\n 0.20447029307788803\n 0.1885049606568594\n 0.09983122794456094\n 0.09793893520175932\n 0.2056461924001432\n ⋮\n 0.20047744819179195\n 0.10112759041040227\n 0.04952968841857731\n 0.04982363315696649\n 0.1\n 0.10091122868900647\n 0.19926513815402705\n 0.04865843270868825\n 0.050965360590573536\n 0.1037052810902896\n 0.10051107325383304\n 0.19811186825667235\n\n\n\nfunction gen_mileage_trans!(\n    kappa::Vector{Float64},\n    num_mileage_states::Int,\n    mileage_trans_mat::Array{Float64, 3}\n    )\n    kappa_1 = kappa[1];\n    kappa_2 = kappa[2];\n\n    mileage_trans_mat[:, :, :] .= 0;\n    for i in 1:num_mileage_states, j in 1:num_mileage_states\n        if (i == j)\n            mileage_trans_mat[i, j, 1] = 1 - kappa_1 - kappa_2;\n        elseif (i == j - 1)\n            mileage_trans_mat[i, j, 1] = kappa_1;\n        elseif (i == j - 2)\n            mileage_trans_mat[i, j, 1] = kappa_2;\n        end\n    end\n    mileage_trans_mat[num_mileage_states - 1, num_mileage_states, 1] = kappa_1 + kappa_2;\n    mileage_trans_mat[num_mileage_states, num_mileage_states, 1] = 1;\n\n    mileage_trans_mat[:, :, 2] = repeat(mileage_trans_mat[1, :, 1]', num_mileage_states);\nend\n\ngen_mileage_trans! (generic function with 1 method)\n\n\n\nfunction gen_price_trans!(\n    lambda::Vector{Float64},\n    num_price_states::Int,\n    price_trans_mat::Array{Float64, 2}\n    )\n\n    price_trans_mat[:, :] .= 0;\n\n    price_trans_mat[1, 2:end] = lambda[1:(num_price_states - 1)];\n    price_trans_mat[1, 1] = 1 - sum(price_trans_mat[1, :]);\n\n    for i in 2:(num_price_states - 1)\n        price_trans_mat[i, 1:(i - 1)] = lambda[\n            ((i - 1) * (num_price_states - 1) + 1):((i - 1) * (num_price_states - 1) + (i - 1))\n            ];\n        price_trans_mat[i, (i + 1):end] = lambda[\n            ((i - 1) * (num_price_states - 1) + i):(i * (num_price_states - 1))\n            ];\n        price_trans_mat[i, i] = 1 - sum(price_trans_mat[i, :]);\n    end\n\n    price_trans_mat[num_price_states, 1:(end - 1)] = lambda[((num_price_states - 1) * (num_price_states - 1) + 1):end];\n    price_trans_mat[num_price_states, num_price_states] = 1 - sum(price_trans_mat[num_price_states, :]);\n\nend\n\ngen_price_trans! (generic function with 1 method)\n\n\n\nmileage_trans_mat_hat = zeros((num_mileage_states, num_mileage_states, num_choice));\ngen_mileage_trans!(kappa_est, num_mileage_states, mileage_trans_mat_hat);\n\nprice_trans_mat_hat = zeros(num_price_states, num_price_states);\ngen_price_trans!(lambda_est, num_price_states, price_trans_mat_hat);\n\ntrans_mat_hat = Array{Float64}(undef, num_states, num_states, num_choice);\nfor i in 1:num_choice\n    trans_mat_hat[:, :, i] = kron(mileage_trans_mat_hat[:, :, i], price_trans_mat_hat);\nend\n\n\nlogit_model = glm(\n  @formula(action ~ price + price^2 + mileage + mileage^2), data_gen, Binomial(), LogitLink()\n  );\n\n\nCCP_1st = hcat(\n  1 .- predict(logit_model, DataFrame(price = states_matrix[:, 1], mileage = states_matrix[:, 2])), \n  predict(logit_model, DataFrame(price = states_matrix[:, 1], mileage = states_matrix[:, 2]))\n  );\nCCP_1st = convert(Matrix{Float64}, CCP_1st);\n\n\nfunction flow_utility(\n    theta,\n    states_matrix::Matrix{Int}\n    )\n\n    theta_c = theta[1];\n    theta_p = theta[2];\n\n    return hcat(\n        - theta_c .* states_matrix[:, 2],\n        - theta_p .* states_matrix[:, 1]\n    );\nend\n\nflow_utility (generic function with 1 method)\n\n\n\nfunction policy_operator_mat_inv(\n  theta,\n  CCP::Matrix{Float64},\n  beta::Float64,\n  trans_mat::Array{Float64, 3},\n  states_matrix::Matrix{Int};\n  num_states::Int = num_states,\n  Euler_const::Float64 = Euler_const\n)\n\n  U = flow_utility(theta, states_matrix);\n\n  psi = Euler_const .- log.(CCP);\n\n  V = (\n    diagm(ones(num_states)) - \n    beta .* (CCP[:, 1] .* trans_mat[:, :, 1] + CCP[:, 2] .* trans_mat[:, :, 2])\n  ) \\ sum(CCP .* (U + psi), dims = 2);\n\n  CV = U + beta .* hcat(trans_mat[:, :, 1] * V, trans_mat[:, :, 2] * V);\n\n  CCP = exp.(CV) ./ sum(exp.(CV), dims = 2)\n\n  return CCP\n\nend\n\npolicy_operator_mat_inv (generic function with 1 method)\n\n\n\nfunction likelihood_fun(\n  theta,\n  CCP::Matrix{Float64},\n  data_gen::DataFrame,\n  beta::Float64,\n  trans_mat::Array{Float64, 3},\n  states_matrix::Matrix{Int},\n  policy_operator\n  )\n\n  CCP = policy_operator(theta, CCP, beta, trans_mat, states_matrix);\n\n  return sum(log.([CCP[x.state, x.action + 1] for x in eachrow(data_gen)]))\n\nend\n\nlikelihood_fun (generic function with 1 method)\n\n\n\nobjFunc_for_Optim_mat_inv = TwiceDifferentiable(\n    x -> - likelihood_fun(x, CCP_1st, data_gen, beta, trans_mat_hat, states_matrix, policy_operator_mat_inv),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time mat_inv_opt_mat_inv = optimize(\n    objFunc_for_Optim_mat_inv,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     1.333730e+04     2.473233e+03\n\n\n * time: 0.010415077209472656\n\n\n     1     1.333729e+04     2.826419e+00\n * time: 0.4051940441131592\n\n\n     2     1.333729e+04     3.092846e-07\n * time: 0.5325851440429688\n\n\n     3     1.333729e+04     1.539229e-08\n * time: 0.6604170799255371\n\n\n     4     1.333729e+04     2.988236e-08\n * time: 0.7546780109405518\n\n\n     5     1.333729e+04     5.530183e-09\n * time: 0.8206510543823242\n\n\n  5.790047 seconds (27.69 M allocations: 1.396 GiB, 7.34% gc time, 88.30% compilation time)\n\n\n * Status: success (objective increased between iterations)\n\n * Candidate solution\n    Final objective value:     1.333729e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 9.19e-17 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.29e-14 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.36e-16 ≰ 0.0e+00\n    |g(x)|                 = 5.53e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    5\n    f(x) calls:    13\n    ∇f(x) calls:   13\n    ∇²f(x) calls:  5\n\n\n\ntheta_mat_inv = mat_inv_opt_mat_inv.minimizer;\n\nhessian_mat_inv = ForwardDiff.hessian(\n    x -> - likelihood_fun(x, CCP_1st, data_gen, beta, trans_mat_hat, states_matrix, policy_operator_mat_inv),\n    mat_inv_opt_mat_inv.minimizer\n    );\n\ntheta_se_mat_inv = sqrt.(diag(inv(hessian_mat_inv)));\n\n\nDataFrame(theta_mat_inv = theta_mat_inv, theta_se_mat_inv = theta_se_mat_inv)\n\n\n2×2 DataFrameRowtheta_mat_invtheta_se_mat_invFloat64Float6410.004009058.65791e-520.003002453.63389e-5\n\n\n\n8.1.1 4.2.2\n\nfunction policy_operator_finite_dep(\n  theta,\n  CCP::Matrix{Float64},\n  beta::Float64,\n  trans_mat::Array{Float64, 3},\n  states_matrix::Matrix{Int}\n  )\n\n  U = flow_utility(theta, states_matrix);\n\n  CV_dif = (\n    U[:, 2] - U[:, 1] +\n    beta .* (trans_mat[:, :, 2] * (- log.(CCP[:, 2])) -  trans_mat[:, :, 1] * (- log.(CCP[:, 2])))\n  );\n\n  prob_buy = exp.(CV_dif) ./ (1 .+ exp.(CV_dif));\n\n  CCP = hcat(1 .- prob_buy, prob_buy)\n\n  return CCP\n\nend\n\npolicy_operator_finite_dep (generic function with 1 method)\n\n\n\nobjFunc_for_Optim_finite_dep = TwiceDifferentiable(\n    x -> - likelihood_fun(x, CCP_1st, data_gen, beta, trans_mat_hat, states_matrix, policy_operator_finite_dep),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time finite_dep_opt = optimize(\n    objFunc_for_Optim_finite_dep,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     1.337865e+04     1.116086e+06\n * time: 9.202957153320312e-5\n\n\n     1     1.333718e+04     6.418191e+03\n * time: 0.1059269905090332\n\n\n     2     1.333718e+04     1.047973e+00\n * time: 0.20606207847595215\n\n\n     3     1.333718e+04     1.616718e-08\n * time: 0.331557035446167\n\n\n     4     1.333718e+04     2.244633e-09\n * time: 0.421781063079834\n\n\n  1.551868 seconds (14.75 M allocations: 613.699 MiB, 9.33% gc time, 66.65% compilation time)\n\n\n * Status: success (objective increased between iterations)\n\n * Candidate solution\n    Final objective value:     1.333718e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 9.02e-17 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.16e-14 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.36e-16 ≰ 0.0e+00\n    |g(x)|                 = 2.24e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   0  (vs limit Inf)\n    Iterations:    4\n    f(x) calls:    11\n    ∇f(x) calls:   11\n    ∇²f(x) calls:  4\n\n\n\ntheta_finite_dep = finite_dep_opt.minimizer;\n\nhessian_finite_dep = ForwardDiff.hessian(\n    x -> - likelihood_fun(x, CCP_1st, data_gen, beta, trans_mat_hat, states_matrix, policy_operator_finite_dep),\n    finite_dep_opt.minimizer\n    );\n\ntheta_se_finite_dep = sqrt.(diag(inv(hessian_finite_dep)));\n\n\nDataFrame(theta_finite_dep = theta_finite_dep, theta_se_finite_dep = theta_se_finite_dep)\n\n\n2×2 DataFrameRowtheta_finite_deptheta_se_finite_depFloat64Float6410.004168910.00080262620.002931792.2015e-5\n\n\n\n\n8.1.2 5.2\n\nfunction contraction(\n    theta,\n    beta::Float64,\n    trans_mat::Array{Float64, 3},\n    states_matrix::Matrix{Int};\n    num_states::Int = num_states,\n    num_choice::Int = num_choice,\n    Euler_const::Float64 = Euler_const\n    )\n\n    U = flow_utility(theta, states_matrix);\n    V_old = zeros(num_states);\n\n    diff = 1000;\n    tol_level = 1e-10;\n\n    while (diff > tol_level)\n        V_new = log.(sum(\n          exp.(U + beta .* hcat(trans_mat[:, :, 1] * V_old, trans_mat[:, :, 2] * V_old)),\n          dims = 2)) .+ Euler_const;\n\n        diff = sum(abs.(V_new - V_old));\n\n        V_old = V_new[:];\n    end\n\n    return V_old\n\nend\n\ncontraction (generic function with 1 method)\n\n\n\nfunction policy_operator_nfxp(\n    theta,\n    beta::Float64,\n    trans_mat::Array{Float64, 3},\n    states_matrix::Matrix{Int};\n    num_states::Int = num_states\n)\n\n    U = flow_utility(theta, states_matrix);\n\n    V = contraction(theta, beta, trans_mat, states_matrix; num_states = num_states);\n    \n    CV = U + beta .* hcat(trans_mat[:, :, 1] * V, trans_mat[:, :, 2] * V);\n\n    CCP = exp.(CV) ./ sum(exp.(CV), dims = 2);\n\n    return CCP\nend\n\npolicy_operator_nfxp (generic function with 1 method)\n\n\n\nfunction likelihood_fun_nfxp(\n    theta,\n    data_gen::DataFrame,\n    beta::Float64,\n    trans_mat::Array{Float64, 3},\n    states_matrix::Matrix{Int}\n)\n  CCP = policy_operator_nfxp(theta, beta, trans_mat, states_matrix);\n\n  return sum(log.([CCP[x.state, x.action + 1] for x in eachrow(data_gen)]))\n\nend\n\nlikelihood_fun_nfxp (generic function with 1 method)\n\n\n\nobjFunc_for_Optim_nfxp = TwiceDifferentiable(\n    x -> - likelihood_fun_nfxp(x, data_gen, beta, trans_mat_hat, states_matrix),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time nfxp_opt = optimize(\n    objFunc_for_Optim_nfxp,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     1.333725e+04     5.946862e+03\n * time: 0.0001201629638671875\n\n\n     1     1.333722e+04     3.170489e+00\n * time: 1.0622570514678955\n\n\n     2     1.333722e+04     4.777394e-07\n * time: 2.088454008102417\n\n\n     3     1.333722e+04     9.062569e-08\n * time: 3.1525042057037354\n\n\n     4     1.333722e+04     1.493299e-08\n * time: 4.006067991256714\n\n\n     5     1.333722e+04     1.400440e-08\n * time: 4.822648048400879\n\n\n     6     1.333722e+04     2.461275e-08\n * time: 6.105187177658081\n\n\n     7     1.333722e+04     3.908644e-08\n * time: 6.925626039505005\n\n\n     8     1.333722e+04     3.261812e-08\n * time: 7.744726181030273\n\n\n     9     1.333722e+04     9.928044e-09\n * time: 8.19316816329956\n\n\n 10.686350 seconds (32.00 M allocations: 27.938 GiB, 21.35% gc time, 16.84% compilation time)\n\n\n * Status: success (objective increased between iterations)\n\n * Candidate solution\n    Final objective value:     1.333722e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 2.26e-17 ≰ 0.0e+00\n    |x - x'|/|x'|          = 5.61e-15 ≰ 0.0e+00\n    |f(x) - f(x')|         = 3.64e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 2.73e-16 ≰ 0.0e+00\n    |g(x)|                 = 9.93e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   8  (vs limit Inf)\n    Iterations:    9\n    f(x) calls:    24\n    ∇f(x) calls:   24\n    ∇²f(x) calls:  9\n\n\n\ntheta_nfxp = nfxp_opt.minimizer;\n\nhessian_nfxp = ForwardDiff.hessian(\n    x -> - likelihood_fun_nfxp(x, data_gen, beta, trans_mat_hat, states_matrix),\n    nfxp_opt.minimizer\n    );\n\ntheta_se_nfxp = sqrt.(diag(inv(hessian_nfxp)));\n\n\nDataFrame(theta_nfxp = theta_nfxp, theta_se_nfxp = theta_se_nfxp)\n\n\n2×2 DataFrameRowtheta_nfxptheta_se_nfxpFloat64Float6410.004018268.88337e-520.003004553.67953e-5\n\n\n\nDataFrame(\n  Algorithm = [\"Matrix Inversion\", \"Finite Dependency\", \"NFXP\"],\n  theta_c = [theta_mat_inv[1], theta_finite_dep[1], theta_nfxp[1]],\n  theta_se_c = [theta_se_mat_inv[1], theta_se_finite_dep[1], theta_se_nfxp[1]],\n  theta_p = [theta_mat_inv[2], theta_finite_dep[2], theta_nfxp[2]],\n  theta_se_p = [theta_se_mat_inv[2], theta_se_finite_dep[2], theta_se_nfxp[2]],\n)\n\n\n3×5 DataFrameRowAlgorithmtheta_ctheta_se_ctheta_ptheta_se_pStringFloat64Float64Float64Float641Matrix Inversion0.004009058.65791e-50.003002453.63389e-52Finite Dependency0.004168910.0008026260.002931792.2015e-53NFXP0.004018268.88337e-50.003004553.67953e-5"
  },
  {
    "objectID": "single_agent_dynamic_application.html#section-3",
    "href": "single_agent_dynamic_application.html#section-3",
    "title": "8  シングルエージェント動学モデルの推定（応用編）",
    "section": "8.2 6",
    "text": "8.2 6\n\nCCP_dict = Dict();\n\n\nprob_buy_baseline = policy_operator_nfxp(theta_nfxp, beta, trans_mat_hat, states_matrix);\nCCP_dict[\"Baseline\"] = prob_buy_baseline;\n\n\nresult_df_edlp = combine(\n  groupby(\n    data_gen,\n    [:state, :price]\n  ),\n  nrow => :num_obs\n);\nsort!(result_df_edlp, :state)\nresult_df_edlp[!, :prob_buy_baseline] = prob_buy_baseline[:, 2];\n\nresult_df_edlp = combine(\n  groupby(\n    result_df_edlp,\n    [:price]\n  ),\n  [:prob_buy_baseline, :num_obs] =>\n  (\n    (prob_buy_baseline, num_obs) ->\n    sum(prob_buy_baseline .* num_obs) / sum(num_obs)\n  ) =>\n  :prob_buy\n);\n\n\nG_fixed_price = zeros((num_mileage_states, num_mileage_states, num_choice));\ngen_mileage_trans!(kappa_est, num_mileage_states, G_fixed_price);\n\n\nfor fixed_price in price_states\n  states_matrix_fixed_price = (\n    states_matrix[states_matrix[:, 1] .== fixed_price, :]\n  )\n\n  CCP_dict[\"edlp_\" * string(fixed_price)] = policy_operator_nfxp(\n    theta_nfxp,\n    beta,\n    G_fixed_price,\n    states_matrix_fixed_price;\n    num_states = num_mileage_states\n  )\nend\n\n\nresult_df_edlp2000 = combine(\n  groupby(\n    data_gen,\n    [:mileage]\n  ),\n  nrow => :num_obs\n);\nsort!(result_df_edlp2000, :mileage)\nresult_df_edlp2000[!, :prob_buy_baseline] = CCP_dict[\"edlp_2000\"][:, 2];\n\nprob_buy_edlp2000 = (\n  sum(result_df_edlp2000.prob_buy_baseline .* result_df_edlp2000.num_obs) / \n  sum(result_df_edlp2000.num_obs)\n);\n\n\nbar(\n    price_states,\n    result_df_edlp.prob_buy,\n    bar_width = 50, legend=false\n)\nhline!([prob_buy_edlp2000])"
  },
  {
    "objectID": "single_agent_dynamic_application.html#section-4",
    "href": "single_agent_dynamic_application.html#section-4",
    "title": "8  シングルエージェント動学モデルの推定（応用編）",
    "section": "8.3 7",
    "text": "8.3 7\n\nstates_matrix_discount = states_matrix[:, :];\nstates_matrix_discount[:, 1] .-= 100;\n\nCCP_dict[\"Permanent\"] = policy_operator_nfxp(theta_nfxp, beta, trans_mat_hat, states_matrix_discount);\n\n\nU_discount = flow_utility(theta_nfxp, states_matrix_discount);\n\nV = contraction(theta_nfxp, beta, trans_mat_hat, states_matrix);\n\nCV_temporary = U_discount + beta .* hcat(trans_mat_hat[:, :, 1] * V, trans_mat_hat[:, :, 2] * V);\n\nCCP_dict[\"Temporary\"] = exp.(CV_temporary) ./ sum(exp.(CV_temporary), dims = 2);\n\n\nplot_cf_df = DataFrame(price = states_matrix[:, 1], mileage = states_matrix[:, 2]);\nplot_cf_df[!, :ProbBaseline] = CCP_dict[\"Baseline\"][:, 2];\nplot_cf_df[!, :ProbPermanent] = CCP_dict[\"Permanent\"][:, 2];\nplot_cf_df[!, :ProbTemporary] = CCP_dict[\"Temporary\"][:, 2];\n\nfilter!(:price => (x -> x == 2200), plot_cf_df);\n\nplot(plot_cf_df.mileage, plot_cf_df.ProbBaseline, label = \"Baseline\")\nplot!(plot_cf_df.mileage, plot_cf_df.ProbPermanent, label = \"Permanent\")\nplot!(plot_cf_df.mileage, plot_cf_df.ProbTemporary, label = \"Temporary\")\nxlabel!(\"Mileage\")\nylabel!(\"Purchase probability\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.3.1 7.2\n\nconsumer_dist_obs = combine(\n  groupby(\n    data_gen,\n    [:state]\n  ),\n  nrow\n)\ntransform!(\n    consumer_dist_obs,\n    :nrow => (x -> x / sum(x)) => :consumer_dist_obs\n);\n\n\ndiscount_scenario_vec = [\"Baseline\", \"Permanent\", \"Temporary\"];\n\nG_CCP_dict = Dict();\n\nfor scenario in discount_scenario_vec\n  G_CCP_dict[scenario] = (\n    CCP_dict[scenario][:, 1] .* trans_mat_hat[:, :, 1] +\n    CCP_dict[scenario][:, 2] .* trans_mat_hat[:, :, 2]\n  );\nend\n\nfor scenario in [\"edlp_\" * string(price) for price in price_states]\n  G_CCP_dict[scenario] = (\n    CCP_dict[scenario][:, 1] .* G_fixed_price[:, :, 1] +\n    CCP_dict[scenario][:, 2] .* G_fixed_price[:, :, 2]\n  );\nend\n\n\nnum_consumer_sim = 1000;\nnum_period_sim = 20;\n\n\ndiscount_sim_dict = Dict();\n\nfor scenario in discount_scenario_vec\n\n  consumer_dist_sim = zeros((num_period_sim, num_states));\n  consumer_dist_sim[1, :] .= consumer_dist_obs.consumer_dist_obs;\n\n  prob_buy_sim_vec = zeros(num_period_sim);\n  demand_vec = zeros(num_period_sim);\n  revenue_vec = zeros(num_period_sim);\n\n  for t in 1:num_period_sim\n\n    if ((t == 1) & (scenario == \"Temporary\"))\n\n      if (t != num_period_sim)\n        consumer_dist_sim[t + 1, :] = consumer_dist_sim[t, :]' * G_CCP_dict[scenario];\n      end\n\n      prob_buy_sim_vec[t] = consumer_dist_sim[t, :]' * CCP_dict[scenario][:, 2];\n      demand_vec[t] = prob_buy_sim_vec[t]' * num_consumer_sim;\n      revenue_vec[t] = sum(\n        (states_matrix[:, 1] .- 100) .* consumer_dist_sim[t, :] .* CCP_dict[scenario][:, 2] .* num_consumer_sim\n      )\n\n    else\n\n      if (scenario == \"Temporary\")\n        scenario_current = \"Baseline\";\n        discount = 0;\n      elseif (scenario == \"Permanent\")\n        scenario_current = scenario;\n        discount = 100;\n      else\n        scenario_current = scenario;\n        discount = 0;\n      end\n\n      if (t != num_period_sim)\n        consumer_dist_sim[t + 1, :] = consumer_dist_sim[t, :]' * G_CCP_dict[scenario_current];\n      end\n\n      prob_buy_sim_vec[t] = consumer_dist_sim[t, :]' * CCP_dict[scenario_current][:, 2];\n      demand_vec[t] = prob_buy_sim_vec[t]' * num_consumer_sim;\n      revenue_vec[t] = sum(\n        (states_matrix[:, 1] .- discount) .* consumer_dist_sim[t, :] .* \n        CCP_dict[scenario_current][:, 2] .* num_consumer_sim\n      )\n\n    end\n\n  end\n\n  discount_sim_dict[scenario] = DataFrame(\n    prob_buy_sim = prob_buy_sim_vec,\n    demand = demand_vec,\n    revenue = revenue_vec,\n  )\n\nend\n\n\nplot(\n  1:num_period_sim,\n  (\n    discount_sim_dict[\"Permanent\"].prob_buy_sim - \n    discount_sim_dict[\"Baseline\"].prob_buy_sim\n  ),\n  label = \"Permanent Change\"\n)\nplot!(\n  1:num_period_sim,\n  (\n    discount_sim_dict[\"Temporary\"].prob_buy_sim - \n    discount_sim_dict[\"Baseline\"].prob_buy_sim\n  ),\n  label = \"Temporary Change\"\n)\n\nxlabel!(\"Period\")\nylabel!(\"Change in purchase probability\")"
  },
  {
    "objectID": "single_agent_dynamic_application.html#section-6",
    "href": "single_agent_dynamic_application.html#section-6",
    "title": "8  シングルエージェント動学モデルの推定（応用編）",
    "section": "8.4 8",
    "text": "8.4 8\n\nconsumer_dist_obs_edlp = combine(\n  groupby(\n    data_gen,\n    [:mileage]\n  ),\n  nrow\n)\ntransform!(\n    consumer_dist_obs_edlp,\n    :nrow => (x -> x / sum(x)) => :consumer_dist_obs\n);\n\n\nedlp_sim_dict = Dict();\n\nfor fixed_price in price_states\n\n  scenario_edlp = \"edlp_\" * string(fixed_price);\n\n  consumer_dist_sim = zeros((num_period_sim, num_mileage_states));\n  consumer_dist_sim[1, :] .= consumer_dist_obs_edlp.consumer_dist_obs;\n\n  prob_buy_sim_vec = zeros(num_period_sim);\n  demand_vec = zeros(num_period_sim);\n  revenue_vec = zeros(num_period_sim);\n\n  for t in 1:num_period_sim\n\n    if (t != num_period_sim)\n      consumer_dist_sim[t + 1, :] = consumer_dist_sim[t, :]' * G_CCP_dict[scenario_edlp];\n    end\n\n    prob_buy_sim_vec[t] = consumer_dist_sim[t, :]' * CCP_dict[scenario_edlp][:, 2];\n    demand_vec[t] = prob_buy_sim_vec[t]' * num_consumer_sim;\n    revenue_vec[t] = sum(\n      fixed_price .* consumer_dist_sim[t, :] .* \n      CCP_dict[scenario_edlp][:, 2] .* num_consumer_sim\n    )\n\n  end\n\n  edlp_sim_dict[fixed_price] = DataFrame(\n    prob_buy_sim = prob_buy_sim_vec,\n    demand = demand_vec,\n    revenue = revenue_vec,\n  )\n\nend\n\n\nplot()\nfor fixed_price in price_states\n  plot!(1:num_period_sim, edlp_sim_dict[fixed_price].demand, label = \"Price: \" * string(fixed_price))\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor fixed_price in price_states\n  plot!(1:num_period_sim, edlp_sim_dict[fixed_price].revenue, label = \"Price: \" * string(fixed_price))\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    discount_sim_dict[scenario].demand,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    discount_sim_dict[scenario].demand |> cumsum,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand (cumulative sum)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    (discount_sim_dict[scenario].demand |> cumsum) ./ (discount_sim_dict[\"Baseline\"].demand |> cumsum) .* 100,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand (cumulative sum, relative to Baseline)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    discount_sim_dict[scenario].revenue,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noutput_df = DataFrame(\n  scenario = [\n    [\"Baseline\", \"Temporary\", \"Permanent\"];\n    [\"edlp_\" * string(price) for price in price_states]\n  ],\n  demand = [\n    [\n      discount_sim_dict[scenario].demand |> sum\n      for scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n    ]; [\n      edlp_sim_dict[price].demand |> sum\n      for price in price_states\n    ]\n  ],\n  revenue = [\n    [\n      discount_sim_dict[scenario].revenue .* (beta .^((1:num_period_sim) .- 1)) |> sum\n      for scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n    ]; [\n      edlp_sim_dict[price].revenue .* (beta .^((1:num_period_sim) .- 1)) |> sum\n      for price in price_states\n    ]\n  ]\n)\n\noutput_df[!, :per_rev] = output_df[:, :revenue] ./ output_df[:, :demand] ./ 10;\n\noutput_df\n\n\n9×4 DataFrameRowscenariodemandrevenueper_revStringFloat64Float64Float641Baseline583.3251.19795e6205.3652Temporary586.1791.20157e6204.9843Permanent623.7691.22583e6196.524edlp_2000711.8081.30044e6182.6955edlp_2100664.1111.27258e6191.6226edlp_2200620.5181.24426e6200.5197edlp_2300580.3191.21512e6209.3888edlp_2400542.9541.18489e6218.239edlp_2500507.9821.15335e6227.046"
  },
  {
    "objectID": "dynamic_game_data.html",
    "href": "dynamic_game_data.html",
    "title": "9  動学ゲームの推定（疑似データの生成）",
    "section": "",
    "text": "10 3"
  },
  {
    "objectID": "dynamic_game_data.html#step-1",
    "href": "dynamic_game_data.html#step-1",
    "title": "9  動学ゲームの推定（疑似データの生成）",
    "section": "10.1 Step 1",
    "text": "10.1 Step 1\n\nCCP1 = repeat([0.5], 8);\nCCP2 = repeat([0.5], 8);\n\n\n\nCCP Transform\nfunction CCP1Transform(x)\n\n    return [\n        0 x[1] 1-x[1];\n        0 x[2] 1-x[2];\n        1-x[3] x[3] 0;\n        1-x[4] x[4] 0;\n        0 x[5] 1-x[5];\n        0 x[6] 1-x[6];\n        1-x[7] x[7] 0;\n        1-x[8] x[8] 0;\n    ]\n\nend;\n\nfunction CCP2Transform(x)\n\n    return [\n        0 x[1] 1-x[1];\n        1-x[2] x[2] 0;\n        0 x[3] 1-x[3];\n        1-x[4] x[4] 0;\n        0 x[5] 1-x[5];\n        1-x[6] x[6] 0;\n        0 x[7] 1-x[7];\n        1-x[8] x[8] 0;\n    ]\n\nend;\n\n\n\nCCP1Mat = CCP1Transform(CCP1);\nCCP2Mat = CCP2Transform(CCP2);\n\n\n\nfP\nfunction fP(Matrix1, Vec1, Vec2)\n\n    TempMat0 = kron(Matrix1, ones(4, 4));\n\n    TempMat1 = [\n        Vec1[1] 1-Vec1[1];\n        Vec1[2] 1-Vec1[2];\n        1-Vec1[3] Vec1[3];\n        1-Vec1[4] Vec1[4];\n        Vec1[5] 1-Vec1[5];\n        Vec1[6] 1-Vec1[6];\n        1-Vec1[7] Vec1[7];\n        1-Vec1[8] Vec1[8];\n    ];\n    TempMat1 = kron(TempMat1, [1 1]);\n    TempMat1 = hcat(TempMat1, TempMat1);\n\n    TempMat2 = [\n        Vec2[1] 1-Vec2[1];\n        1-Vec2[2] Vec2[2];\n        Vec2[3] 1-Vec2[3];\n        1-Vec2[4] Vec2[4];\n        Vec2[5] 1-Vec2[5];\n        1-Vec2[6] Vec2[6];\n        Vec2[7] 1-Vec2[7];\n        1-Vec2[8] Vec2[8];\n    ];\n    TempMat2 = kron(ones(1, 4), TempMat2);\n\n    return TempMat0 .* TempMat1 .* TempMat2;\n\nend;\n\n\n\nfPsigma = fP(TransitionMat, CCP1, CCP2);\n\n\n\npiPsigma Gen\nfunction pi1PsigmaGen(pi1, Mat2)\n\n    pi1_dec = pi1[:, 1];\n    pi1_0 = pi1[:, 2];\n    pi1_inc = pi1[:, 3];\n\n    pi1_dec = (pi1_dec .* Mat2) * ones(3);\n    pi1_0 = (pi1_0 .* Mat2) * ones(3);\n    pi1_inc = (pi1_inc .* Mat2) * ones(3);\n\n    return hcat(\n        pi1_dec, pi1_0, pi1_inc\n    )\n\nend\n\nfunction pi2PsigmaGen(pi2, Mat1)\n\n    pi2_dec = pi2[:, 1];\n    pi2_0 = pi2[:, 2];\n    pi2_inc = pi2[:, 3];\n\n    pi2_dec = (pi2_dec .* Mat1) * ones(3);\n    pi2_0 = (pi2_0 .* Mat1) * ones(3);\n    pi2_inc = (pi2_inc .* Mat1) * ones(3);\n\n    return hcat(\n        pi2_dec, pi2_0, pi2_inc\n    )\n\nend\n\n\npi2PsigmaGen (generic function with 1 method)\n\n\n\npi1Psigma = pi1PsigmaGen(pi1, CCP2Mat);\npi2Psigma = pi2PsigmaGen(pi2, CCP1Mat);\n\n\n\nCCP Log Transform\nfunction CCP1LogTransform(x)\n\n    return [\n        0 log(x[1]) log(1 - x[1]);\n        0 log(x[2]) log(1 - x[2]);\n        log(1 - x[3]) log(x[3]) 0;\n        log(1 - x[4]) log(x[4]) 0;\n        0 log(x[5]) log(1 - x[5]);\n        0 log(x[6]) log(1 - x[6]);\n        log(1 - x[7]) log(x[7]) 0;\n        log(1 - x[8]) log(x[8]) 0;\n    ]\n\nend\n\nfunction CCP2LogTransform(x)\n\n    return [\n        0 log(x[1]) log(1 - x[1]);\n        log(1 - x[2]) log(x[2]) 0;\n        0 log(x[3]) log(1 - x[3]);\n        log(1 - x[4]) log(x[4]) 0;\n        0 log(x[5]) log(1 - x[5]);\n        log(1 - x[6]) log(x[6]) 0;\n        0 log(x[7]) log(1 - x[7]);\n        log(1 - x[8]) log(x[8]) 0;\n    ]\n\nend\n\n\nCCP2LogTransform (generic function with 1 method)\n\n\n\neP1 = eulergamma .- CCP1LogTransform(CCP1);\neP2 = eulergamma .- CCP2LogTransform(CCP2);\n\n\nExanteV1 = (\n    (diagm(ones(8)) - beta .* fPsigma) \\ \n    ((CCP1Mat .* (pi1Psigma + eP1)) * ones(3))\n);\n\nExanteV2 = (\n    (diagm(ones(8)) - beta .* fPsigma) \\ \n    ((CCP2Mat .* (pi2Psigma + eP2)) * ones(3))\n);\n\n\n\nfP a given\nfunction fP_a1given(Matrix1, Vec2)\n\n    TempMat0 = kron(Matrix1, ones(4, 4));\n\n    TempMat2 = [\n        Vec2[1] 1-Vec2[1] Vec2[1] 1-Vec2[1];\n        1-Vec2[2] Vec2[2] 1-Vec2[2] Vec2[2];\n        Vec2[3] 1-Vec2[3] Vec2[3] 1-Vec2[3];\n        1-Vec2[4] Vec2[4] 1-Vec2[4] Vec2[4];\n        Vec2[5] 1-Vec2[5] Vec2[5] 1-Vec2[5];\n        1-Vec2[6] Vec2[6] 1-Vec2[6] Vec2[6];\n        Vec2[7] 1-Vec2[7] Vec2[7] 1-Vec2[7];\n        1-Vec2[8] Vec2[8] 1-Vec2[8] Vec2[8];\n    ];\n    TempMat2 = hcat(TempMat2, TempMat2);\n\n    MatAdjustMinus1 = repeat(vcat(\n        zeros(2, 8), ones(2, 8)\n    ), 2);\n    MatAdjustMinus2 = repeat(vcat(\n        ones(2, 8), zeros(2, 8)\n    ), 2)';\n    output1 = TempMat0 .* TempMat2 .* MatAdjustMinus1 .* MatAdjustMinus2;\n\n\n    ForZero = diagm(ones(2));\n    MatAdjustZero = kron(ForZero, ones(2, 2));\n    MatAdjustZero = hcat(MatAdjustZero, MatAdjustZero);\n    MatAdjustZero = vcat(MatAdjustZero, MatAdjustZero);\n    output2 = TempMat0 .* TempMat2 .* MatAdjustZero;\n\n\n    MatAdjustPlus1 = repeat(vcat(\n        ones(2, 8), zeros(2, 8)\n    ), 2);\n    MatAdjustPlus2 = repeat(vcat(\n        zeros(2, 8), ones(2, 8)\n    ), 2)';\n    output3 = TempMat0 .* TempMat2 .* MatAdjustPlus1 .* MatAdjustPlus2;\n\n    return [output1, output2, output3]\nend\n\nfunction fP_a2given(Matrix1, Vec1)\n\n    TempMat0 = kron(Matrix1, ones(4, 4));\n\n    TempMat1 = [\n        Vec1[1] Vec1[1] 1-Vec1[1] 1-Vec1[1];\n        Vec1[2] Vec1[2] 1-Vec1[2] 1-Vec1[2];\n        1-Vec1[3] 1-Vec1[3] Vec1[3] Vec1[3];\n        1-Vec1[4] 1-Vec1[4] Vec1[4] Vec1[4];\n        Vec1[5] Vec1[5] 1-Vec1[5] 1-Vec1[5];\n        Vec1[6] Vec1[6] 1-Vec1[6] 1-Vec1[6];\n        1-Vec1[7] 1-Vec1[7] Vec1[7] Vec1[7];\n        1-Vec1[8] 1-Vec1[8] Vec1[8] Vec1[8];\n    ];\n    TempMat1 = kron(ones(1, 2), TempMat1);\n\n    MatAdjustMinus1 = repeat(vcat(zeros(1, 8), ones(1, 8)), 4);\n    MatAdjustMinus2 = repeat(vcat(ones(1, 8), zeros(1, 8)), 4)';\n    output1 = TempMat0 .* TempMat1 .* MatAdjustMinus1 .* MatAdjustMinus2;\n\n\n    MatAdjustZero = repeat(vcat(\n        repeat([1, 0], 4)',\n        repeat([0, 1], 4)',\n    ), 4);\n    output2 = TempMat0 .* TempMat1 .* MatAdjustZero;\n\n\n    MatAdjustPlus1 = repeat(vcat(ones(1, 8), zeros(1, 8)), 4);\n    MatAdjustPlus2 = repeat(vcat(zeros(1, 8), ones(1, 8)), 4)';\n    output3 = TempMat0 .* TempMat1 .* MatAdjustPlus1 .* MatAdjustPlus2;\n\n    return [output1, output2, output3]\nend\n\n\nfP_a2given (generic function with 1 method)\n\n\n\nfP_a1 = fP_a1given(TransitionMat, CCP2);\nfP_a2 = fP_a2given(TransitionMat, CCP1);\n\n\nNewSigmaSeed1 = (\n    pi1Psigma + beta .* hcat(fP_a1[1] * ExanteV1, fP_a1[2] * ExanteV1, fP_a1[3] * ExanteV1) .* CCP1Adjuster\n);\nNewSigmaDeno1 = (\n    sum(exp.(NewSigmaSeed1), dims = 2) .- 1\n);\nNewSigma1 = exp.(NewSigmaSeed1) ./ NewSigmaDeno1;\nCCP1UpdatedMat = NewSigma1 .* CCP1Adjuster;\nCCP1Updated = CCP1UpdatedMat[:, 2];\n\nNewSigmaSeed2 = (\n    pi2Psigma + beta .* hcat(fP_a2[1] * ExanteV2, fP_a2[2] * ExanteV2, fP_a2[3] * ExanteV2) .* CCP2Adjuster\n);\nNewSigmaDeno2 = (\n    sum(exp.(NewSigmaSeed2), dims = 2) .- 1\n);\nNewSigma2 = exp.(NewSigmaSeed2) ./ NewSigmaDeno2;\nCCP2UpdatedMat = NewSigma2 .* CCP2Adjuster;\nCCP2Updated = CCP2UpdatedMat[:, 2];"
  },
  {
    "objectID": "dynamic_game_data.html#step-4",
    "href": "dynamic_game_data.html#step-4",
    "title": "9  動学ゲームの推定（疑似データの生成）",
    "section": "10.2 Step 4",
    "text": "10.2 Step 4\n\nfPsigma = fP(TransitionMat, CCP1Updated, CCP2Updated);\n\npi1Psigma = pi1PsigmaGen(pi1, CCP2UpdatedMat);\npi2Psigma = pi2PsigmaGen(pi2, CCP1UpdatedMat);\n\neP1 = eulergamma .- CCP1LogTransform(CCP1Updated);\neP2 = eulergamma .- CCP2LogTransform(CCP2Updated);\n\nExanteV1Updated = (\n    (diagm(ones(8)) - beta .* fPsigma) \\ \n    ((CCP1UpdatedMat .* (pi1Psigma + eP1)) * ones(3))\n);\n\nExanteV2Updated = (\n    (diagm(ones(8)) - beta .* fPsigma) \\ \n    ((CCP2UpdatedMat .* (pi2Psigma + eP2)) * ones(3))\n);"
  },
  {
    "objectID": "dynamic_game_data.html#step-5",
    "href": "dynamic_game_data.html#step-5",
    "title": "9  動学ゲームの推定（疑似データの生成）",
    "section": "10.3 Step 5",
    "text": "10.3 Step 5\n\nDiffExanteV = 1;\niter = 0;\n\n@time while (DiffExanteV > 1e-12)\n\n    CCP1 = CCP1Updated[:];\n    CCP2 = CCP2Updated[:];\n\n    ExanteV1 = ExanteV1Updated[:];\n    ExanteV2 = ExanteV2Updated[:];\n\n    fP_a1 = fP_a1given(TransitionMat, CCP2);\n    fP_a2 = fP_a2given(TransitionMat, CCP1);\n\n    NewSigmaSeed1 = (\n        pi1Psigma + beta .* hcat(fP_a1[1] * ExanteV1, fP_a1[2] * ExanteV1, fP_a1[3] * ExanteV1) .* CCP1Adjuster\n    );\n    NewSigmaDeno1 = (\n        sum(exp.(NewSigmaSeed1), dims = 2) .- 1\n    );\n    NewSigma1 = exp.(NewSigmaSeed1) ./ NewSigmaDeno1;\n    CCP1UpdatedMat = NewSigma1 .* CCP1Adjuster;\n    CCP1Updated = CCP1UpdatedMat[:, 2];\n\n    NewSigmaSeed2 = (\n        pi2Psigma + beta .* hcat(fP_a2[1] * ExanteV2, fP_a2[2] * ExanteV2, fP_a2[3] * ExanteV2) .* CCP2Adjuster\n    );\n    NewSigmaDeno2 = (\n        sum(exp.(NewSigmaSeed2), dims = 2) .- 1\n    );\n    NewSigma2 = exp.(NewSigmaSeed2) ./ NewSigmaDeno2;\n    CCP2UpdatedMat = NewSigma2 .* CCP2Adjuster;\n    CCP2Updated = CCP2UpdatedMat[:, 2];\n\n    fPsigma = fP(TransitionMat, CCP1Updated, CCP2Updated);\n\n    pi1Psigma = pi1PsigmaGen(pi1, CCP2UpdatedMat);\n    pi2Psigma = pi2PsigmaGen(pi2, CCP1UpdatedMat);\n\n    eP1 = eulergamma .- CCP1LogTransform(CCP1Updated);\n    eP2 = eulergamma .- CCP2LogTransform(CCP2Updated);\n\n    ExanteV1Updated = (\n        (diagm(ones(8)) - beta .* fPsigma) \\ \n        ((CCP1UpdatedMat .* (pi1Psigma + eP1)) * ones(3))\n    );\n\n    ExanteV2Updated = (\n        (diagm(ones(8)) - beta .* fPsigma) \\ \n        ((CCP2UpdatedMat .* (pi2Psigma + eP2)) * ones(3))\n    );\n\n    DiffExanteV = sum((ExanteV1Updated - ExanteV1).^2 + (ExanteV2Updated - ExanteV2).^2);\n\nend;\n\n  0.069669 seconds (205.19 k allocations: 13.977 MiB, 9.60% gc time, 98.91% compilation time)\n\n\n\nCCP1UpdatedMat\n\n8×3 Matrix{Float64}:\n 0.0       0.683563  0.316437\n 0.0       0.712662  0.287338\n 0.184349  0.815651  0.0\n 0.206181  0.793819  0.0\n 0.0       0.708067  0.291933\n 0.0       0.735965  0.264035\n 0.202453  0.797547  0.0\n 0.225863  0.774137  0.0\n\n\n\nCCP2UpdatedMat\n\n8×3 Matrix{Float64}:\n 0.0       0.714725  0.285275\n 0.207591  0.792409  0.0\n 0.0       0.741697  0.258303\n 0.231269  0.768731  0.0\n 0.0       0.737685  0.262315\n 0.227294  0.772706  0.0\n 0.0       0.76353   0.23647\n 0.2527    0.7473    0.0"
  },
  {
    "objectID": "dynamic_game_data.html#step-6",
    "href": "dynamic_game_data.html#step-6",
    "title": "9  動学ゲームの推定（疑似データの生成）",
    "section": "10.4 Step 6",
    "text": "10.4 Step 6\n\nNumSimMarkets = 500;\nNumSimPeriods = 50;\nNumSimFirms = 2;\n\n\nInitialState = sample(1:8, NumSimMarkets);\n\nRandomNumbers = reshape(\n    rand(NumSimMarkets * NumSimPeriods * (NumSimFirms + 1)),\n    (NumSimMarkets, NumSimPeriods, NumSimFirms + 1)\n);\n\n\nFakeData = zeros(NumSimMarkets * NumSimPeriods, 8);\n\nfor m in 1:NumSimMarkets, t in 1:NumSimPeriods\n\n    FakeData[(m - 1) * NumSimPeriods + t, 1] = m;\n    FakeData[(m - 1) * NumSimPeriods + t, 2] = t;\n\n    if t == 1\n\n        FakeData[(m - 1) * NumSimPeriods + 1, 3] = InitialState[m];\n\n        FakeData[(m - 1) * NumSimPeriods + 1, 4] = (\n            (InitialState[m] >= 1) & (InitialState[m] <= 4) ? 1 :\n            2\n        );\n\n    else\n\n        sprev = FakeData[(m - 1) * NumSimPeriods + t - 1, 3]\n        a1prev = FakeData[(m - 1) * NumSimPeriods + t - 1, 7]\n        a2prev = FakeData[(m - 1) * NumSimPeriods + t - 1, 8]\n\n        if (sprev >= 1) & (sprev <= 4)\n            FakeData[(m - 1) * NumSimPeriods + t, 4] = (\n                (RandomNumbers[m, t, 3] < TransitionMat[1, 1]) ? 1 :\n                2\n            );\n        else\n            FakeData[(m - 1) * NumSimPeriods + t, 4] = (\n                (RandomNumbers[m, t, 3] < TransitionMat[2, 2]) ? 2 :\n                1\n            );\n        end\n\n        snow = FakeData[(m - 1) * NumSimPeriods + t, 4];\n        n1t = FakeData[(m - 1) * NumSimPeriods + t - 1, 5] + a1prev;\n        n2t = FakeData[(m - 1) * NumSimPeriods + t - 1, 6] + a2prev;\n\n        FakeData[(m - 1) * NumSimPeriods + t, 3] = (\n            (snow == 1) & (n1t == 0) & (n2t == 0) ? 1 :\n            (snow == 1) & (n1t == 0) & (n2t == 1) ? 2 :\n            (snow == 1) & (n1t == 1) & (n2t == 0) ? 3 :\n            (snow == 1) & (n1t == 1) & (n2t == 1) ? 4 :\n            (snow == 2) & (n1t == 0) & (n2t == 0) ? 5 :\n            (snow == 2) & (n1t == 0) & (n2t == 1) ? 6 :\n            (snow == 2) & (n1t == 1) & (n2t == 0) ? 7 :\n            (snow == 2) & (n1t == 1) & (n2t == 1) ? 8 :\n            0\n        );\n\n    end\n\n    s = Int(FakeData[(m - 1) * NumSimPeriods + t, 3]);\n\n    if s == 1\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 0, 0];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 2\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 0, 1];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    elseif s == 3\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 1, 0];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 4\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 1, 1];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    elseif s == 5\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 0, 0];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 6\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 0, 1];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    elseif s == 7\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 1, 0];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 8\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 1, 1];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    end\nend\n\n\nCSV.write(\"tmp/dynamic_game/FakeData.csv\", Tables.table(FakeData), writeheader = false)\n\n\"tmp/dynamic_game/FakeData.csv\""
  }
]