[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "【非公式】実証ビジネス・エコノミクス Juliaでの実装",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "2  About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "1_demand_estimation_1.html",
    "href": "1_demand_estimation_1.html",
    "title": "2  需要モデルの推定（基礎編1）",
    "section": "",
    "text": "using CSV\nusing DataFrames\nusing StringEncodings\nusing FixedEffectModels\nusing RegressionTables\nusing Plots\nusing Optim\nusing Printf\nusing GLM\n\n\ndata = CSV.File(\n    open(read, \"data/1_demand_estimation_1/CleanData_20180222.csv\", enc\"shift-jis\"),\n    missingstring = [\"NA\", \"\"],\n    ) |> DataFrame\nfirst(data, 5)\n\n\n5×36 DataFrameRowMakerTypeNameYearSalescommentModelYear_trueMonthpricekudoukataTransMissionWheelBaseMinRideHeightweightcapacitySeatRawNumofDoorbase_coloroption_color種類engine過給器displacementFuelTypeTankCapacityHorsePowerMaxTorqueFuelEfficiencyoverall_lengthoverall_widthoverall_heightinterior_lengthinterior_widthinterior_heightString15String7String31Int64Int64String?StringInt64Int64Float64String3String15String3Int64Int64?Int64Int64Int64Int64StringStringString31String15StringInt64String15Int64?Int64?Float64?Float64?Int64Int64Int64Int64?Int64?Int64?1AudiForeignA1シリーズ20114206missing1.4 TFSI20111289.0FFDBA-8XCAX7AT24651151190423アマルフィホワイト、ブリリアントブラック、スクーバブルーメタリック、シラーズレッドメタリック、ティークブラウンメタリック、キュミュラスブルー、スフィアブルーメタリック、アイスシルバーメタリックミサノレッドパールエフェクト、ファントムブラックパールエフェクト直列4気筒DOHCCAXターボ1389ハイオク4512220.419.4397017401440missingmissingmissing2AudiForeignA1シリーズ20124502missing1.4 TFSI20121273.0FFDBA-8XCAX7AT24651151190423アマルフィホワイト、ブリリアントブラック、スクーバブルーメタリック、シラーズレッドメタリック、ティークブラウンメタリック、キュミュラスブルー、スフィアブルーメタリック、アイスシルバーメタリックミサノレッドパールエフェクト、ファントムブラックパールエフェクト直列4気筒DOHCCAXターボ1389ハイオク4512220.419.4397017401440missingmissingmissing3AudiForeignA1シリーズ20135071missing1.4 TFSI20121273.0FFDBA-8XCAX7AT24651151190423アマルフィホワイト、ブリリアントブラック、スクーバブルーメタリック、シラーズレッドメタリック、ティークブラウンメタリック、キュミュラスブルー、スフィアブルーメタリック、アイスシルバーメタリックミサノレッドパールエフェクト、ファントムブラックパールエフェクト直列4気筒DOHCCAXターボ1389ハイオク4512220.419.4397017401440missingmissingmissing4AudiForeignA3シリーズ20064830missingアトラクション20061284.0FFGH-8PBSE6AT25751401360525シルバーレイクメタリック、エボニーブラックパールエフェクト、ドルフィングレーメタリック、アークティックホワイト、ブリリアントレッド、モロブルーパールエフェクト、モーリシャスブルーパールエフェクト、アーコヤンシルバーメタリックアルパカベージュメタリック直列4気筒SOHCBSEなし1595ハイオク5510215.112.2428517651430missingmissingmissing5AudiForeignA3シリーズ20073874missingアトラクション20071286.0FFGH-8PBSE6AT25751401360525ドルフィングレーメタリック、ブリリアントレッド、シルバーメタリックモロブルーパールエフェクト、モーリシャスブルーパールエフェクト、ファントムブラックパールエフェクト直列4気筒SOHCBSEなし1595ハイオク5510215.112.2428517651430missingmissingmissing"
  },
  {
    "objectID": "1_demand_estimation_1.html#data-cleaning",
    "href": "1_demand_estimation_1.html#data-cleaning",
    "title": "2  需要モデルの推定（基礎編1-1）",
    "section": "2.1 Data cleaning",
    "text": "2.1 Data cleaning\n\ndata = data[!, [\n        :Maker, :Type, :Name, :Year, :Sales, \n        :Model, :price, :kata, :weight, :FuelEfficiency, \n        :HorsePower, :overall_length, :overall_width, :overall_height\n        ]]\nrename!(data, \"Year\" => \"year\")\ndata = leftjoin(data, dataHH, on = :year)\ndata = leftjoin(data, dataCPI, on = :year)\nfirst(data, 5)\n\n\n5×16 DataFrameRowMakerTypeNameyearSalesModelpricekataweightFuelEfficiencyHorsePoweroverall_lengthoverall_widthoverall_heightHHCPIString15String7String31Int64Int64StringFloat64String15Int64Float64?Int64?Int64Int64Int64Int64?Float64?1AudiForeignA1シリーズ201142061.4 TFSI289.0DBA-8XCAX119019.41223970174014405378343596.32AudiForeignA1シリーズ201245021.4 TFSI273.0DBA-8XCAX119019.41223970174014405417147596.23AudiForeignA1シリーズ201350711.4 TFSI273.0DBA-8XCAX119019.41223970174014405459474496.64AudiForeignA3シリーズ20064830アトラクション284.0GH-8PBSE136012.21024285176514305110200597.25AudiForeignA3シリーズ20073874アトラクション286.0GH-8PBSE136012.21024285176514305171304897.2\n\n\n\ndropmissing!(data, :FuelEfficiency);\n\n\ncpi2016 = dataCPI[dataCPI.year .== 2016, \"CPI\"][1]\ndata[!, :price] = data.price ./ (data.CPI / cpi2016) / 100;\n\n\ndata[!, :size] = (data[:, :overall_length] / 1000) .* (data[:, :overall_width] / 1000) .* (data[:, :overall_height] / 1000);\ndata[!, :hppw] = data[:, :HorsePower] ./ data[:, :weight];\n\nunique_name = unique(data[!, [:Name]])\nunique_name[!, :NameID] = rownumber.(eachrow(unique_name))\ndata = leftjoin(data, unique_name, on = :Name);\n\ndata = transform(\n    groupby(data, :year),\n    :Sales => sum => :inside_total\n);\ndata[!, :outside_total] = data.HH .- data.inside_total;\ndata[!, :share] = data.Sales ./ data.HH;\ndata[!, :share0] = data.outside_total ./ data.HH;\n\n\ntransform!(\n    groupby(data, [:year, :Maker]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_own, :FuelEfficiency_sum_own, :size_sum_own],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_own, :FuelEfficiency_sqr_sum_own, :size_sqr_sum_own],\n    nrow => \"group_n\"\n);\ntransform!(\n    groupby(data, [:year]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_mkt, :FuelEfficiency_sum_mkt, :size_sum_mkt],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_mkt, :FuelEfficiency_sqr_sum_mkt, :size_sqr_sum_mkt],\n    nrow => \"mkt_n\"\n);\n\n\ndata[!, :iv_BLP_own_hppw]             = data[:, :hppw_sum_own]           .- data[:, :hppw];\ndata[!, :iv_BLP_own_FuelEfficiency]   = data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency];\ndata[!, :iv_BLP_own_size]             = data[:, :size_sum_own]           .- data[:, :size];\ndata[!, :iv_BLP_other_hppw]           = data[:, :hppw_sum_mkt]           .- data[:, :hppw_sum_own];\ndata[!, :iv_BLP_other_FuelEfficiency] = data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own];\ndata[!, :iv_BLP_other_size]           = data[:, :size_sum_mkt]           .- data[:, :size_sum_own];\n\n\ndata[!, :iv_GH_own_hppw]             = (\n    (data[:, :group_n] .- 1) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_own] .- data[:, :hppw].^2) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_own] .- data[:, :hppw])\n);\ndata[!, :iv_GH_own_FuelEfficiency]   = (\n    (data[:, :group_n] .- 1) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_own] .- data[:, :FuelEfficiency].^2) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency])\n);\ndata[!, :iv_GH_own_size]             = (\n    (data[:, :group_n] .- 1) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_own] .- data[:, :size].^2) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_own] .- data[:, :size])\n);\ndata[!, :iv_GH_other_hppw]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_mkt] .- data[:, :hppw_sqr_sum_own]) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_mkt] .- data[:, :hppw_sum_own])\n);\ndata[!, :iv_GH_other_FuelEfficiency] = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_mkt] .- data[:, :FuelEfficiency_sqr_sum_own]) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own])\n);\ndata[!, :iv_GH_other_size]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_mkt] .- data[:, :size_sqr_sum_own]) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_mkt] .- data[:, :size_sum_own])\n);\n\n\nNIPPYOautoIDvec = [\n    260, 4, 76, 104, 64, 54, 152, 153, 71, 197,\n    42, 45, 114, 208, 209, 77, 236, 58, 127, 187,\n    79, 175, 19, 117, 216, 112, 256, 119, 37, 158\n];\n\n\ndata_NIPPYO = data[in(NIPPYOautoIDvec).(data[:, :NameID]), [:Sales, :price, :hppw, :FuelEfficiency, :size]];\ndata_NIPPYO[!, :log_sales] = log.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log_price] = log.(data_NIPPYO[:, :price]);\ndata_NIPPYO[!, :log10_sales] = log10.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log10_price] = log10.(data_NIPPYO[:, :price]);\n\n\nols_intro = reg(\n    data_NIPPYO, \n    @formula(log_sales ~ log_price + hppw + FuelEfficiency + size),\n    Vcov.robust()\n)\n\n                                 FixedEffectModel                                 \n==================================================================================\nNumber of obs:                       196  Converged:                          true\ndof (model):                           4  dof (residuals):                     190\nR²:                                0.217  R² adjusted:                       0.201\nF-statistic:                     19.1148  P-value:                           0.000\n==================================================================================\n                  Estimate  Std. Error    t-stat  Pr(>|t|)    Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────────────────\nlog_price       -1.24828     0.309545   -4.03262    <1e-04   -1.85886    -0.63769\nhppw            -4.19685     3.97622    -1.05549    0.2925  -12.0401      3.64635\nFuelEfficiency   0.0886034   0.0283887   3.12108    0.0021    0.0326059   0.144601\nsize             0.306896    0.0588927   5.2111     <1e-06    0.190728    0.423063\n(Intercept)      5.76211     1.06127     5.42946    <1e-06    3.66873     7.85549\n==================================================================================\n\n\n\nfit_line = predict(\n    lm(@formula(log10_sales ~ log10_price), data_NIPPYO)\n    );\nplot(\n    data_NIPPYO.price, \n    data_NIPPYO.Sales, \n    seriestype = :scatter, \n    legend = false,\n    xscale = :log10,\n    yscale = :log10,\n    xlabel = \"Price\",\n    ylabel = \"Sales\",\n    xticks = ([1, 3, 10], [1, 3, 10]),\n)\nplot!(\n    data_NIPPYO.price, \n    10 .^ fit_line,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndescribe(data[:, [:Sales, :price, :FuelEfficiency, :size, :hppw]])\n\n\n5×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64RealFloat64RealInt64DataType1Sales24586.4108544.03176750Int642price2.530470.7051762.0504212.62650Float643FuelEfficiency16.15975.515.440.80Float644size11.50535.90911.472519.15480Float645hppw0.09913120.0450.09268290.3238640Float64\n\n\n\ndata[!, :logit_share] = log.(data[:, :share]) .- log.(data[:, :share0]);\n\n\nols_res = reg(data, @formula(logit_share ~ price + hppw + FuelEfficiency + size), Vcov.robust());\niv_BLP_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust()\n);\niv_GH_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust(),\n    save = true\n);\n\n\nregtable(ols_res, iv_BLP_res, iv_GH_res)\n\n\n--------------------------------------------------------------\n                                       logit_share            \n                          ------------------------------------\n                                 (1)          (2)          (3)\n--------------------------------------------------------------\n(Intercept)               -12.255***   -12.323***   -12.973***\n                             (0.365)      (0.382)      (0.393)\nprice                      -0.255***    -0.283***    -0.552***\n                             (0.026)      (0.067)      (0.080)\nhppw                          -0.654        0.213      8.426**\n                             (1.284)      (2.298)      (2.638)\nFuelEfficiency              0.130***     0.130***     0.127***\n                             (0.010)      (0.010)      (0.010)\nsize                        0.182***     0.187***     0.236***\n                             (0.019)      (0.021)      (0.022)\n--------------------------------------------------------------\nEstimator                        OLS           IV           IV\n--------------------------------------------------------------\nN                              1,823        1,823        1,823\nR2                             0.222        0.222        0.180\nWithin-R2                                                     \nFirst-stage F statistic                    33.926       51.583\n--------------------------------------------------------------\n\n\n\n\niv1st_BLP_res = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n        ),\n    Vcov.robust()\n);\niv1st_GH_res = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n        ),\n    Vcov.robust()\n);\n\n\nregtable(iv1st_BLP_res, iv1st_GH_res)\n\n\n---------------------------------------------------\n                                      price        \n                              ---------------------\n                                    (1)         (2)\n---------------------------------------------------\n(Intercept)                      -3.159    -1.325**\n                                (1.685)     (0.423)\nhppw                          28.749***   23.508***\n                                (0.993)     (1.547)\nFuelEfficiency                   -0.011   -0.072***\n                                (0.008)     (0.014)\nsize                           0.202***    0.189***\n                                (0.015)     (0.020)\niv_BLP_own_hppw                 -0.728*            \n                                (0.336)            \niv_BLP_own_FuelEfficiency     -0.007***            \n                                (0.001)            \niv_BLP_own_size                0.013***            \n                                (0.004)            \niv_BLP_other_hppw                 0.165            \n                                (0.255)            \niv_BLP_other_FuelEfficiency     0.001**            \n                                (0.000)            \niv_BLP_other_size                -0.002            \n                                (0.003)            \niv_GH_own_hppw                            -1.889***\n                                            (0.439)\niv_GH_own_FuelEfficiency                      0.000\n                                            (0.000)\niv_GH_own_size                            -0.001***\n                                            (0.000)\niv_GH_other_hppw                           0.423***\n                                            (0.096)\niv_GH_other_FuelEfficiency                 0.000***\n                                            (0.000)\niv_GH_other_size                           0.000***\n                                            (0.000)\n---------------------------------------------------\nN                                 1,823       1,823\nR2                                0.616       0.623\n---------------------------------------------------\n\n\n\n\ndata[!, :own_elas_ols]   = ols_res.coef[ols_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\ndata[!, :own_elas_ivblp] = iv_BLP_res.coef[iv_BLP_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\ndata[!, :own_elas_ivgh]  = iv_GH_res.coef[iv_GH_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\n\n\ndescribe(data[:, r\"^own_elas\"])\n\n\n3×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64Float64Float64Float64Int64DataType1own_elas_ols-0.645328-3.22104-0.522324-0.1798920Float642own_elas_ivblp-0.717085-3.5792-0.580404-0.1998950Float643own_elas_ivgh-1.3967-6.9714-1.13048-0.3893460Float64\n\n\n\ndt_application = data[:, [:NameID, :year, :Sales, :price, :FuelEfficiency, :size, :hppw, :HH, :share]];\ndt_application[!, :xi_fit] = iv_GH_res.residuals;\n\n\nNameID_target = 197\ndt_application[(dt_application.year .== 2016) .& (dt_application.NameID .== NameID_target), :]\n\n\n1×10 DataFrameRowNameIDyearSalespriceFuelEfficiencysizehppwHHsharexi_fitInt64?Int64Int64Float64Float64Float64Float64Int64?Float64Float64?11972016370693.19811.617.09440.0947917569507570.0006508961.16401\n\n\n\nfunction f_share(\n        price_cand,\n        year, \n        NameID_target,\n        dt,\n        est_res\n    )\n    \n    dt = dt[dt.year .== year, :]\n    dt[!, :temp_price] = dt[:, :price]\n    dt[(dt[:, :NameID] .== NameID_target), :temp_price] .= price_cand\n    dt[!, :delta] = (\n        est_res.coef[est_res.coefnames .== \"(Intercept)\"] .+\n        est_res.coef[est_res.coefnames .== \"hppw\"] .* dt[:, :hppw] .+\n        est_res.coef[est_res.coefnames .== \"FuelEfficiency\"] .* dt[:, :FuelEfficiency] .+\n        est_res.coef[est_res.coefnames .== \"size\"] .* dt[:, :size] .+\n        est_res.coef[est_res.coefnames .== \"price\"] .* dt[:, :temp_price] .+\n        dt[:, :xi_fit]\n    )\n    dt[!, :denom] .= 1 .+ sum(exp.(dt[:, :delta]))\n    dt[!, :pred_sales] = exp.(dt[:, :delta]) ./ dt[:, :denom] .* dt[:, :HH]\n    dt = dt[dt.NameID .== NameID_target, :]\n    \n    return dt.pred_sales[1]\n    \nend\n\nf_share (generic function with 1 method)\n\n\n\npricevec = range(0.3, 5, step = 0.05);\nquantvec = f_share.(pricevec, 2016, NameID_target, Ref(dt_application), Ref(iv_GH_res));\n\n\nplot(quantvec, pricevec, xticks = [50000, 100000, 150000], legend = false)\nxlabel!(\"Sales\")\nylabel!(\"Price (million JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(pricevec, pricevec .* quantvec / 1000, legend = false)\nxlabel!(\"Price (million JPY)\")\nylabel!(\"Revenue (billion JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nopt_res = optimize(\n    x -> - f_share(x[1], 2016, NameID_target, dt_application, iv_GH_res) * x[1],\n    [1.0]\n);\n\n@printf(\"Revenue-maximizing price: %.3f \\n\", opt_res.minimizer[1])\n@printf(\"Max revenue : %.3f\", -opt_res.minimum)\n\nRevenue-maximizing price: 1.814 \nMax revenue : 144273.836"
  },
  {
    "objectID": "1_demand_estimation_2.html#section",
    "href": "1_demand_estimation_2.html#section",
    "title": "3  需要モデルの推定（基礎編1-2）",
    "section": "3.1 4.1",
    "text": "3.1 4.1\n\nNIPPYOautoIDvec = [\n    260, 4, 76, 104, 64, 54, 152, 153, 71, 197,\n    42, 45, 114, 208, 209, 77, 236, 58, 127, 187,\n    79, 175, 19, 117, 216, 112, 256, 119, 37, 158\n];\ndata_NIPPYO = data[\n    in(NIPPYOautoIDvec).(data[:, :NameID]), \n    [:year, :share, :NameID, :Sales, :price, :hppw, :FuelEfficiency, :size, :Name]\n    ];\ndata_NIPPYO[!, :log_sales] = log.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log_price] = log.(data_NIPPYO[:, :price]);\ndata_NIPPYO[!, :log10_sales] = log10.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log10_price] = log10.(data_NIPPYO[:, :price]);\n## 4.2\ndata[!, :logit_share] = log.(data[:, :share]) .- log.(data[:, :share0]);\n\niv_GH_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust(),\n    save = true\n);\n\ndt_2016 = data_NIPPYO[data_NIPPYO.year .== 2016, [:price, :share, :NameID, :Name]]\n\nprice = dt_2016.price\nshare = dt_2016.share\nNameID = dt_2016.NameID\n\nown_elas = iv_GH_res.coef[iv_GH_res.coefnames .== \"price\"][1] .* price .* (1.0 .- share);\ncross_elas = (-1.0) .* iv_GH_res.coef[iv_GH_res.coefnames .== \"price\"][1] .* price .* share;\nJ = length(own_elas);\n\nelas_mat = reduce(hcat, [cross_elas for j = 1:J]);\nelas_mat[diagind(elas_mat)] = own_elas;\n\nelas_mat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -1.76455       0.00114929    0.00114929   0.00114929\n  0.00122042   -0.818689      0.00122042   0.00122042\n  0.000148175   0.000148175  -0.959449     0.000148175\n  0.00184509    0.00184509    0.00184509  -0.67175"
  },
  {
    "objectID": "1_demand_estimation_2.html#section-1",
    "href": "1_demand_estimation_2.html#section-1",
    "title": "3  需要モデルの推定（基礎編1-2）",
    "section": "3.2 5",
    "text": "3.2 5\n\ntransform!(\n    groupby(data, [:year, :Maker, :Type]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_own, :FuelEfficiency_sum_own, :size_sum_own],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_own, :FuelEfficiency_sqr_sum_own, :size_sqr_sum_own],\n    nrow => \"group_n\"\n);\ntransform!(\n    groupby(data, [:year, :Type]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_mkt, :FuelEfficiency_sum_mkt, :size_sum_mkt],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_mkt, :FuelEfficiency_sqr_sum_mkt, :size_sqr_sum_mkt],\n    nrow => \"mkt_n\"\n);\n\ndata[!, :iv_BLP_own_hppw_nest]             = data[:, :hppw_sum_own]           .- data[:, :hppw];\ndata[!, :iv_BLP_own_FuelEfficiency_nest]   = data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency];\ndata[!, :iv_BLP_own_size_nest]             = data[:, :size_sum_own]           .- data[:, :size];\ndata[!, :iv_BLP_own_num_nest]              = data[:, :group_n]                .- 1;\n\ndata[!, :iv_BLP_other_hppw_nest]           = data[:, :hppw_sum_mkt]           .- data[:, :hppw_sum_own];\ndata[!, :iv_BLP_other_FuelEfficiency_nest] = data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own];\ndata[!, :iv_BLP_other_size_nest]           = data[:, :size_sum_mkt]           .- data[:, :size_sum_own];\ndata[!, :iv_BLP_other_num_nest]            = data[:, :mkt_n]                  .- data[:, :group_n];\ndata[!, :iv_GH_own_hppw_nest]             = (\n    (data[:, :group_n] .- 1) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_own] .- data[:, :hppw].^2) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_own] .- data[:, :hppw])\n);\ndata[!, :iv_GH_own_FuelEfficiency_nest]   = (\n    (data[:, :group_n] .- 1) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_own] .- data[:, :FuelEfficiency].^2) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency])\n);\ndata[!, :iv_GH_own_size_nest]             = (\n    (data[:, :group_n] .- 1) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_own] .- data[:, :size].^2) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_own] .- data[:, :size])\n);\ndata[!, :iv_GH_other_hppw_nest]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_mkt] .- data[:, :hppw_sqr_sum_own]) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_mkt] .- data[:, :hppw_sum_own])\n);\ndata[!, :iv_GH_other_FuelEfficiency_nest] = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_mkt] .- data[:, :FuelEfficiency_sqr_sum_own]) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own])\n);\ndata[!, :iv_GH_other_size_nest]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_mkt] .- data[:, :size_sqr_sum_own]) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_mkt] .- data[:, :size_sum_own])\n);"
  },
  {
    "objectID": "1_demand_estimation_2.html#section-2",
    "href": "1_demand_estimation_2.html#section-2",
    "title": "3  需要モデルの推定（基礎編1-2）",
    "section": "3.3 6",
    "text": "3.3 6\n\ndata = transform(\n    groupby(data, [:year, :Type]),\n    :Sales => sum => :sum_year_body\n);\ndata[!, :inside_share] = data.Sales ./ data.sum_year_body;\ndata[!, :log_inside_share] = log.(data.Sales ./ data.sum_year_body);\nols_res = reg(data, @formula(logit_share ~ price + log_inside_share + hppw + FuelEfficiency + size))\n\niv_BLP2_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price + log_inside_share ~ iv_BLP_own_hppw_nest + iv_BLP_own_FuelEfficiency_nest + iv_BLP_own_size_nest + \n            iv_BLP_other_hppw_nest + iv_BLP_other_FuelEfficiency_nest + iv_BLP_other_size_nest +\n            iv_BLP_own_num_nest + iv_BLP_other_num_nest\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust()\n);\n\nregtable(ols_res, iv_BLP2_res)\n\n\n-----------------------------------------------\n                               logit_share     \n                          ---------------------\n                                (1)         (2)\n-----------------------------------------------\n(Intercept)               -7.557***   -9.548***\n                            (0.166)     (0.239)\nprice                     -0.307***   -0.654***\n                            (0.013)     (0.053)\nlog_inside_share           0.782***    0.595***\n                            (0.009)     (0.035)\nhppw                      10.636***   18.925***\n                            (0.657)     (1.965)\nFuelEfficiency             0.055***    0.069***\n                            (0.004)     (0.006)\nsize                       0.156***    0.227***\n                            (0.008)     (0.012)\n-----------------------------------------------\nEstimator                       OLS          IV\n-----------------------------------------------\nN                             1,823       1,823\nR2                            0.862       0.765\nWithin-R2                                      \nFirst-stage F statistic                   1.667\n-----------------------------------------------"
  },
  {
    "objectID": "1_demand_estimation_2.html#section-3",
    "href": "1_demand_estimation_2.html#section-3",
    "title": "3  需要モデルの推定（基礎編1-2）",
    "section": "3.4 6.1",
    "text": "3.4 6.1\n\nalpha1 = ols_res.coef[ols_res.coefnames .== \"price\"][1]\nsigma1 = ols_res.coef[ols_res.coefnames .== \"log_inside_share\"][1]\n\nalpha2 = iv_BLP2_res.coef[iv_BLP2_res.coefnames .== \"price\"][1]\nsigma2 = iv_BLP2_res.coef[iv_BLP2_res.coefnames .== \"log_inside_share\"][1]\n\ndata[!, :own_elas_ols] = alpha1 .* data[:, :price] .* (\n    1.0 .- sigma1 .* data[:, :inside_share] .- \n    (1.0 .- sigma1) .* data[:, :share]\n) ./ (1.0 .- sigma1);\ndata[!, :own_elas_ivglp] = alpha2 .* data[:, :price] .* (\n    1.0 .- sigma2 .* data[:, :inside_share] .- \n    (1.0 .- sigma2) .* data[:, :share]\n) ./ (1.0 .- sigma2);\n\ndescribe(data[:, r\"^own_elas\"], :mean, :std, :median, :min, :max)\ndata_NIPPYO = data[\n    in(NIPPYOautoIDvec).(data[:, :NameID]), \n    [:year, :share, :Type, :inside_share, :NameID, :Sales, :price, :hppw, :FuelEfficiency, :size, :Name]\n    ];\ndata_NIPPYO[!, :log_sales] = log.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log_price] = log.(data_NIPPYO[:, :price]);\n\ndt_2016 = data_NIPPYO[data_NIPPYO.year .== 2016, [:price, :Type, :share, :inside_share, :NameID, :Name]]\n\nprice = dt_2016.price;\nshare = dt_2016.share;\nNameID = dt_2016.NameID;\ninside_share = dt_2016.inside_share;\ngroup = dt_2016.Type;\nown_elas = alpha2 .* price .* (1.0 .- sigma2 .* inside_share .- (1.0 .- sigma2) .* share) ./ (1.0 .- sigma2);\ncross_elas_othergroup = (-1.0) .* alpha2 .* price .* share;\nJ = length(own_elas);\n\ncross_elas_othergroup = reduce(hcat, [cross_elas_othergroup for j = 1:J]);\nelas_mat[diagind(elas_mat)] = own_elas;\n\nprice_1_mat       = reduce(hcat, [price for j = 1:J]);\nshare_1_mat       = reduce(hcat, [share for j = 1:J]);\ninsideshare_1_mat = reduce(hcat, [inside_share for j = 1:J]);\n\ncross_elas_samegroup = (-1.0) .* alpha2 .* price_1_mat .* (\n    sigma2 .* insideshare_1_mat .+ (1.0 .- sigma2) .* share_1_mat\n) ./ (1.0 .- sigma2);\n\ntemp_mat1 = reduce(hcat, [group for j = 1:J]);\ntemp_mat2 = permutedims(temp_mat1);\nind_same_group  = (temp_mat1 .== temp_mat2);\nind_other_group = (temp_mat1 .!== temp_mat2);\n\nelas_mat_nl = cross_elas_samegroup .* ind_same_group .+ cross_elas_othergroup .* ind_other_group;\nelas_mat_nl[diagind(elas_mat_nl)] = own_elas;\n\nelas_mat_nl[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -5.1197       0.0477573    0.0477573    0.00136172\n  0.050713    -2.34881      0.050713     0.001446\n  0.00615725   0.00615725  -2.80217      0.000175564\n  0.00218614   0.00218614   0.00218614  -1.83296"
  },
  {
    "objectID": "1_demand_estimation_2.html#section-4",
    "href": "1_demand_estimation_2.html#section-4",
    "title": "3  需要モデルの推定（基礎編1-2）",
    "section": "3.5 7",
    "text": "3.5 7\n\n3.5.1 Step 1\n\nsort!(data, [:year, :NameID]);\nN = nrow(data);\nT = length(unique(data.year));\nX1 = hcat(repeat([1], N), Matrix(data[:, [:price, :FuelEfficiency, :hppw, :size]]));\nX2 = hcat(data.price, repeat([1], N), data.size);\nZ = hcat(\n    repeat([1], N),\n    Matrix(data[:, [:FuelEfficiency, :hppw, :size]]),\n    Matrix(data[:, r\"^iv_GH.*(?<!nest)$\"])\n    );\nRandom.seed!(123);\nNsim = 500;\n\ndraw_vec = reduce(hcat, [randn(size(X2, 2)) for j =1:Nsim]);\n\ntheta2 = [0.001, 0.001, 0.001];\n\nmarketindex = data.year;\nuniquemarketindex = sort(unique(data.year));\n\ntemp1 = reduce(hcat, [uniquemarketindex for j = 1:N])';\ntemp2 = reduce(hcat, [data.year for j = 1:T]);\ntempmat = (temp1 .== temp2);\nmutable struct datalist_struct\n    X1::Array{Float64,2};\n    X2::Array{Float64,2};\n    Z::Array{Float64,2};\n    ShareVec::Vector{Float64};\n    marketindex::Vector{Int64};\n    logitshare::Vector{Float64};\n    draw_vec::Array{Float64,2};\n    tempmat::BitMatrix\nend\n\nmutable struct parameter_struct\n    Nsim::Int;\n    T::Int;\n    N::Int;\nend\ndatalist = datalist_struct(X1, X2, Z, data.share, marketindex, data.logit_share, draw_vec, tempmat);\nparameter = parameter_struct(Nsim, T, N);\n\n\n\n3.5.2 Step 2\n\nfunction f_mktshare(\n        theta2,\n        datalist::datalist_struct,\n        parameter::parameter_struct,\n        delta\n    )\n        \n    mu = datalist.X2 * Diagonal(theta2) * datalist.draw_vec;\n    \n    delta_mu = delta .* ones((1, parameter.Nsim)) .+ mu;\n    exp_delta_mu = exp.(delta_mu .- maximum(delta_mu));\n    denom_outside = exp.(-maximum(delta_mu));\n    \n    denom_temp = (exp_delta_mu' * datalist.tempmat)' .+ denom_outside;\n    denom = datalist.tempmat * denom_temp;\n    \n    s_jt_i = exp_delta_mu ./ denom;\n    s_jt = vec(mean(s_jt_i, dims = 2));\n    \n    return s_jt\n    \nend\n@time f_mktshare([0.01, 0.01, 0.01], datalist, parameter, data.logit_share);\n\n  0.096863 seconds (42.00 k allocations: 37.354 MiB, 76.10% compilation time)\n\n\n\n\n3.5.3 Step 3\n\nfunction f_contraction(\n        theta2,\n        datalist::datalist_struct,\n        parameter::parameter_struct,\n        delta_ini\n    )\n    \n    tol = 1e-11;\n    norm = 1e+10\n\n    delta_old = delta_ini;\n    exp_delta_old = exp.(delta_old);\n    \n    iter = 0;\n        \n    while ((norm > tol) & (iter < 1000))\n        \n#         print(iter, \"\\n\")\n        \n        pred_mkt_share = f_mktshare(theta2, datalist, parameter, delta_old);\n        \n        exp_delta = exp_delta_old .* datalist.ShareVec ./ pred_mkt_share;\n        \n        norm = maximum(abs.(exp_delta .- exp_delta_old));\n        \n        exp_delta_old = exp_delta;\n        delta_old = log.(exp_delta);\n        iter += 1;\n        \n    end\n    \n#     print(iter, \"\\n\")\n    \n    return delta_old;\n    \nend\n    \n@time f_contraction([0.1, 0.01, 0.01], datalist, parameter, data.logit_share);\n\n  0.278492 seconds (18.44 k allocations: 280.696 MiB, 16.32% gc time, 15.77% compilation time)\n\n\n\n\n3.5.4 Step 4\n\nfunction f_GMMobj(\n        theta2,\n        parameter::parameter_struct,\n        datalist::datalist_struct,\n        delta_ini::Vector{Float64}\n    )\n    \n#     delta_ini = delta_global;\n#     delta_ini = datalist.logitshare;\n    delta = f_contraction(theta2, datalist, parameter, delta_ini);\n#     global delta_global = delta\n    \n#     if (datalist.weight_mat_option == \"2SLS\") \n        W = inv(datalist.Z' * datalist.Z);\n#     elseif (datalist.weight_mat_option == \"Ident\")\n#         W = I(size(datalist.Z, 2));\n#     end\n    \n    beta_hat = (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ (datalist.X1' * datalist.Z * W * datalist.Z' * delta);\n    \n    Xi = delta - datalist.X1 * beta_hat;\n    \n    output = Xi' * datalist.Z * W * datalist.Z' * Xi\n        \n    return output\n    \nend    \n    \ninitial_x = [0.1, 1.0, 0.1];\ndelta_ini = f_contraction(initial_x, datalist, parameter, datalist.logitshare);\n\n\nobjFunc_for_Optim = TwiceDifferentiable(\n    x -> f_GMMobj(x, parameter, datalist, delta_ini),\n    initial_x;\n    autodiff = :forward\n    );\n@time gmm_res = optimize(\n    objFunc_for_Optim,\n#     x -> f_GMMobj(x, parameter, datalist, delta_ini),\n    [0.0, 0.00, 0.00],\n    [Inf, Inf, Inf],\n    initial_x,\n    Optim.Options(show_trace = true)\n)\n\n\n\n * Status: success\n\n * Candidate solution\n    Final objective value:     1.720392e+02\n\n * Found with\n    Algorithm:     Interior Point Newton\n\n * Convergence measures\n    |x - x'|               = 0.00e+00 ≤ 0.0e+00\n    |x - x'|/|x'|          = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 9.27e+00 ≰ 1.0e-08\n\n * Work counters\n    Seconds run:   376  (vs limit Inf)\n    Iterations:    24\n    f(x) calls:    218\n    ∇f(x) calls:   218\n\n\n\ngmm_res.minimizer\n\n3-element Vector{Float64}:\n  0.28734533108108296\n 15.767041571288186\n  0.07564921477989821\n\n\n\nW = inv(datalist.Z' * datalist.Z);    \ndelta = f_contraction(gmm_res.minimizer, datalist, parameter, delta_ini);\nbeta_hat = (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ (datalist.X1' * datalist.Z * W * datalist.Z' * delta);\n\nbeta_hat\n\n5-element Vector{Float64}:\n -30.94355607145988\n  -0.9028865616490973\n   0.11090678367437005\n   9.193592802875408\n   0.28736901935168374\n\n\n\n\n3.5.5 Step 5\n\nXi = delta - X1 * beta_hat;\nOmega_hat = reduce(+, Z[i,:] * Z[i,:]' .* Xi[i]^2 ./ N for i = 1:N);\nDdelta = ForwardDiff.jacobian(x -> delta_ini = f_contraction(x, datalist, parameter, delta), gmm_res.minimizer);\nG = Z' * hcat(- X1, Ddelta) ./ N;\nAsyVarMat = (G' * W * G) \\ G' * W * Omega_hat * W * G * inv(G' * W * G);\nAse = sqrt.(diag(AsyVarMat) ./ N);\n\nDataFrame(\n    Var = [\"Const\", \"Price\", \"Fuel Efficiency\", \"hppw\", \"size\", \"random_price\", \"random_constant\", \"random_size\"],\n    Est = vcat(beta_hat, gmm_res.minimizer),\n    se = Ase\n)\n\n\n8×3 DataFrameRowVarEstseStringFloat64Float641Const-30.943615.51382Price-0.9028870.4330623Fuel Efficiency0.1109070.01105714hppw9.193593.113645size0.2873690.05171996random_price0.2873450.4324577random_constant15.767101.9688random_size0.07564920.290593"
  },
  {
    "objectID": "1_demand_estimation_2.html#section-5",
    "href": "1_demand_estimation_2.html#section-5",
    "title": "3  需要モデルの推定（基礎編1-2）",
    "section": "3.6 8",
    "text": "3.6 8\n\nmu = X2 * Diagonal(gmm_res.minimizer) * draw_vec;\ndelta_mu = delta .+ mu;\nexp_delta_mu = exp.(delta_mu);\ndenom_outside = exp.(0.0);\ndenom_temp = (exp_delta_mu' * tempmat)' .+ denom_outside;\ndenom = tempmat * denom_temp;\n\ns_jt_i = exp_delta_mu ./ denom;\ndraw_for_price = draw_vec[1,:];\nalpha_i = beta_hat[2] .+ gmm_res.minimizer[1] .* draw_for_price;\nyear = 2016\nJ_t = sum(data.year .== year);\n\nag_model_s_i = s_jt_i[data.year .== year, :]\nag_model_s = mean(ag_model_s_i, dims = 2);\nprice_t = data.price[data.year .== year];\n\nelasmat = zeros((J_t, J_t));\n\nfor k in 1:J_t, j in 1:J_t\n    if (k != j)\n        elasmat[k, j] = (-1.0) .* price_t[k] ./ ag_model_s[j] * mean(alpha_i .* ag_model_s_i[j, :] .* ag_model_s_i[k, :])\n    elseif (k == j)\n        elasmat[k, j] = price_t[j] ./ ag_model_s[j] * mean(alpha_i .* ag_model_s_i[j, :] .* (1.0 .- ag_model_s_i[j, :]))\n    end\nend\n\n\nelasmat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -1.10253      0.0451789    0.0435272    0.0324128\n  0.0153236   -0.832714     0.0153759    0.0109914\n  0.0184981    0.0192656   -1.12275      0.0138002\n  0.00450168   0.00450075   0.00450998  -2.50034"
  },
  {
    "objectID": "1_demand_estimation_2.html#section-6",
    "href": "1_demand_estimation_2.html#section-6",
    "title": "3  需要モデルの推定（基礎編1-2）",
    "section": "3.7 9",
    "text": "3.7 9\n\nfunction f_revenue(\n        price_cand,\n        data,\n        datalist,\n        parameter,\n        delta,\n        beta_hat,\n        theta2,\n        option\n    )\n\n    mc_betado = 3.198 * (1.0 - 1.0 / abs(-2.16720791));\n\n    tempprice = data.price[:];\n    tempprice[(data.NameID .== 197) .& (data.year .== 2016)] .= price_cand;\n    \n    X1_new = datalist.X1[:,:];\n    X2_new = datalist.X2[:,:];\n    X1_new[:, 2] = tempprice;\n    X2_new[:, 1] = tempprice;\n    \n    org_xi = delta .- datalist.X1 * beta_hat;\n    new_delta = X1_new * beta_hat .+ org_xi;\n    \n    datalist_temp = datalist_struct(\n        X1_new, X2_new, datalist.Z, data.share, datalist.marketindex, \n        data.logit_share, datalist.draw_vec, datalist.tempmat\n        );\n    \n    mktshare = f_mktshare(theta2, datalist_temp, parameter, new_delta);\n    \n    quant = mktshare .* data.HH;\n    revenue = tempprice .* quant;\n        \n    revenuevec  = revenue[(data.NameID .== 197) .& (data.year .== 2016)];\n    revenuevec2 = sum(revenue[in(NIPPYOautoIDvec).(data[:, :NameID]) .& (data.year .== 2016)]);\n    \n    pivec  = revenuevec  .- mc_betado .* quant[(data.NameID .== 197) .& (data.year .== 2016)];\n    pivec2 = revenuevec2 .- mc_betado .* quant[(data.NameID .== 197) .& (data.year .== 2016)];\n\n    if option == \"own\"\n        return(revenuevec[1])\n    elseif option == \"total\"\n        return(revenuevec2[1])\n    elseif option == \"ownpi\"\n        return(pivec[1])\n    elseif option == \"totalpi\"\n        return(pivec2[1])\n    end\n    \nend\nprice_range = range(1.8, 4.0, step = 0.05);\nownpi_res = f_revenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(parameter), Ref(delta), Ref(beta_hat), Ref(gmm_res.minimizer),\n    \"ownpi\"\n);\nplot(price_range, ownpi_res, legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprice_range = range(1.8, 4.0, step = 0.05);\ntotalpi_res = f_revenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(parameter), Ref(delta), Ref(beta_hat), Ref(gmm_res.minimizer),\n    \"totalpi\"\n);\nplot(price_range, totalpi_res, legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nownpi_optim_res = optimize(\n    x -> - f_revenue(x[1], data, datalist, parameter, delta, beta_hat, gmm_res.minimizer, \"ownpi\"),\n    [3.0]\n)\n\nownpi_optim_res.minimizer\n\n1-element Vector{Float64}:\n 2.967175245285034\n\n\n\ntotalpi_optim_res = optimize(\n    x -> - f_revenue(x[1], data, datalist, parameter, delta, beta_hat, gmm_res.minimizer, \"totalpi\"),\n    [3.0]\n)\ntotalpi_optim_res.minimizer\n\n1-element Vector{Float64}:\n 3.136022758483887"
  },
  {
    "objectID": "demand_estimation_2.html#section",
    "href": "demand_estimation_2.html#section",
    "title": "3  需要モデルの推定（基礎編 2）",
    "section": "3.1 4.1",
    "text": "3.1 4.1\n\nNIPPYOautoIDvec = [\n    260, 4, 76, 104, 64, 54, 152, 153, 71, 197,\n    42, 45, 114, 208, 209, 77, 236, 58, 127, 187,\n    79, 175, 19, 117, 216, 112, 256, 119, 37, 158\n];\ndata_NIPPYO = data[\n    in(NIPPYOautoIDvec).(data[:, :NameID]), \n    [:year, :share, :NameID, :Sales, :price, :hppw, :FuelEfficiency, :size, :Name]\n    ];\ndata_NIPPYO[!, :log_sales] = log.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log_price] = log.(data_NIPPYO[:, :price]);\ndata_NIPPYO[!, :log10_sales] = log10.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log10_price] = log10.(data_NIPPYO[:, :price]);\n## 4.2\ndata[!, :logit_share] = log.(data[:, :share]) .- log.(data[:, :share0]);\n\niv_GH_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust(),\n    save = true\n);\n\ndt_2016 = data_NIPPYO[data_NIPPYO.year .== 2016, [:price, :share, :NameID, :Name]]\n\nprice = dt_2016.price\nshare = dt_2016.share\nNameID = dt_2016.NameID\n\nown_elas = iv_GH_res.coef[iv_GH_res.coefnames .== \"price\"][1] .* price .* (1.0 .- share);\ncross_elas = (-1.0) .* iv_GH_res.coef[iv_GH_res.coefnames .== \"price\"][1] .* price .* share;\nJ = length(own_elas);\n\nelas_mat = reduce(hcat, [cross_elas for j = 1:J]);\nelas_mat[diagind(elas_mat)] = own_elas;\n\nelas_mat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -1.76455       0.00114929    0.00114929   0.00114929\n  0.00122042   -0.818689      0.00122042   0.00122042\n  0.000148175   0.000148175  -0.959449     0.000148175\n  0.00184509    0.00184509    0.00184509  -0.67175"
  },
  {
    "objectID": "demand_estimation_2.html#section-1",
    "href": "demand_estimation_2.html#section-1",
    "title": "3  需要モデルの推定（基礎編 2）",
    "section": "3.2 5",
    "text": "3.2 5\n\ntransform!(\n    groupby(data, [:year, :Maker, :Type]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_own, :FuelEfficiency_sum_own, :size_sum_own],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_own, :FuelEfficiency_sqr_sum_own, :size_sqr_sum_own],\n    nrow => \"group_n\"\n);\ntransform!(\n    groupby(data, [:year, :Type]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_mkt, :FuelEfficiency_sum_mkt, :size_sum_mkt],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_mkt, :FuelEfficiency_sqr_sum_mkt, :size_sqr_sum_mkt],\n    nrow => \"mkt_n\"\n);\n\ndata[!, :iv_BLP_own_hppw_nest]             = data[:, :hppw_sum_own]           .- data[:, :hppw];\ndata[!, :iv_BLP_own_FuelEfficiency_nest]   = data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency];\ndata[!, :iv_BLP_own_size_nest]             = data[:, :size_sum_own]           .- data[:, :size];\ndata[!, :iv_BLP_own_num_nest]              = data[:, :group_n]                .- 1;\n\ndata[!, :iv_BLP_other_hppw_nest]           = data[:, :hppw_sum_mkt]           .- data[:, :hppw_sum_own];\ndata[!, :iv_BLP_other_FuelEfficiency_nest] = data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own];\ndata[!, :iv_BLP_other_size_nest]           = data[:, :size_sum_mkt]           .- data[:, :size_sum_own];\ndata[!, :iv_BLP_other_num_nest]            = data[:, :mkt_n]                  .- data[:, :group_n];\ndata[!, :iv_GH_own_hppw_nest]             = (\n    (data[:, :group_n] .- 1) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_own] .- data[:, :hppw].^2) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_own] .- data[:, :hppw])\n);\ndata[!, :iv_GH_own_FuelEfficiency_nest]   = (\n    (data[:, :group_n] .- 1) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_own] .- data[:, :FuelEfficiency].^2) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency])\n);\ndata[!, :iv_GH_own_size_nest]             = (\n    (data[:, :group_n] .- 1) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_own] .- data[:, :size].^2) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_own] .- data[:, :size])\n);\ndata[!, :iv_GH_other_hppw_nest]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_mkt] .- data[:, :hppw_sqr_sum_own]) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_mkt] .- data[:, :hppw_sum_own])\n);\ndata[!, :iv_GH_other_FuelEfficiency_nest] = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_mkt] .- data[:, :FuelEfficiency_sqr_sum_own]) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own])\n);\ndata[!, :iv_GH_other_size_nest]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_mkt] .- data[:, :size_sqr_sum_own]) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_mkt] .- data[:, :size_sum_own])\n);"
  },
  {
    "objectID": "demand_estimation_2.html#section-2",
    "href": "demand_estimation_2.html#section-2",
    "title": "3  需要モデルの推定（基礎編 2）",
    "section": "3.3 6",
    "text": "3.3 6\n\ndata = transform(\n    groupby(data, [:year, :Type]),\n    :Sales => sum => :sum_year_body\n);\ndata[!, :inside_share] = data.Sales ./ data.sum_year_body;\ndata[!, :log_inside_share] = log.(data.Sales ./ data.sum_year_body);\nols_res = reg(data, @formula(logit_share ~ price + log_inside_share + hppw + FuelEfficiency + size))\n\niv_BLP2_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price + log_inside_share ~ iv_BLP_own_hppw_nest + iv_BLP_own_FuelEfficiency_nest + iv_BLP_own_size_nest + \n            iv_BLP_other_hppw_nest + iv_BLP_other_FuelEfficiency_nest + iv_BLP_other_size_nest +\n            iv_BLP_own_num_nest + iv_BLP_other_num_nest\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust()\n);\n\nregtable(ols_res, iv_BLP2_res)\n\n\n-----------------------------------------------\n                               logit_share     \n                          ---------------------\n                                (1)         (2)\n-----------------------------------------------\n(Intercept)               -7.557***   -9.548***\n                            (0.166)     (0.239)\nprice                     -0.307***   -0.654***\n                            (0.013)     (0.053)\nlog_inside_share           0.782***    0.595***\n                            (0.009)     (0.035)\nhppw                      10.636***   18.925***\n                            (0.657)     (1.965)\nFuelEfficiency             0.055***    0.069***\n                            (0.004)     (0.006)\nsize                       0.156***    0.227***\n                            (0.008)     (0.012)\n-----------------------------------------------\nEstimator                       OLS          IV\n-----------------------------------------------\nN                             1,823       1,823\nR2                            0.862       0.765\nWithin-R2                                      \nFirst-stage F statistic                   1.667\n-----------------------------------------------"
  },
  {
    "objectID": "demand_estimation_2.html#section-3",
    "href": "demand_estimation_2.html#section-3",
    "title": "3  需要モデルの推定（基礎編 2）",
    "section": "3.4 6.1",
    "text": "3.4 6.1\n\nalpha1 = ols_res.coef[ols_res.coefnames .== \"price\"][1]\nsigma1 = ols_res.coef[ols_res.coefnames .== \"log_inside_share\"][1]\n\nalpha2 = iv_BLP2_res.coef[iv_BLP2_res.coefnames .== \"price\"][1]\nsigma2 = iv_BLP2_res.coef[iv_BLP2_res.coefnames .== \"log_inside_share\"][1]\n\ndata[!, :own_elas_ols] = alpha1 .* data[:, :price] .* (\n    1.0 .- sigma1 .* data[:, :inside_share] .- \n    (1.0 .- sigma1) .* data[:, :share]\n) ./ (1.0 .- sigma1);\ndata[!, :own_elas_ivglp] = alpha2 .* data[:, :price] .* (\n    1.0 .- sigma2 .* data[:, :inside_share] .- \n    (1.0 .- sigma2) .* data[:, :share]\n) ./ (1.0 .- sigma2);\n\ndescribe(data[:, r\"^own_elas\"], :mean, :std, :median, :min, :max)\ndata_NIPPYO = data[\n    in(NIPPYOautoIDvec).(data[:, :NameID]), \n    [:year, :share, :Type, :inside_share, :NameID, :Sales, :price, :hppw, :FuelEfficiency, :size, :Name]\n    ];\ndata_NIPPYO[!, :log_sales] = log.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log_price] = log.(data_NIPPYO[:, :price]);\n\ndt_2016 = data_NIPPYO[data_NIPPYO.year .== 2016, [:price, :Type, :share, :inside_share, :NameID, :Name]]\n\nprice = dt_2016.price;\nshare = dt_2016.share;\nNameID = dt_2016.NameID;\ninside_share = dt_2016.inside_share;\ngroup = dt_2016.Type;\nown_elas = alpha2 .* price .* (1.0 .- sigma2 .* inside_share .- (1.0 .- sigma2) .* share) ./ (1.0 .- sigma2);\ncross_elas_othergroup = (-1.0) .* alpha2 .* price .* share;\nJ = length(own_elas);\n\ncross_elas_othergroup = reduce(hcat, [cross_elas_othergroup for j = 1:J]);\nelas_mat[diagind(elas_mat)] = own_elas;\n\nprice_1_mat       = reduce(hcat, [price for j = 1:J]);\nshare_1_mat       = reduce(hcat, [share for j = 1:J]);\ninsideshare_1_mat = reduce(hcat, [inside_share for j = 1:J]);\n\ncross_elas_samegroup = (-1.0) .* alpha2 .* price_1_mat .* (\n    sigma2 .* insideshare_1_mat .+ (1.0 .- sigma2) .* share_1_mat\n) ./ (1.0 .- sigma2);\n\ntemp_mat1 = reduce(hcat, [group for j = 1:J]);\ntemp_mat2 = permutedims(temp_mat1);\nind_same_group  = (temp_mat1 .== temp_mat2);\nind_other_group = (temp_mat1 .!== temp_mat2);\n\nelas_mat_nl = cross_elas_samegroup .* ind_same_group .+ cross_elas_othergroup .* ind_other_group;\nelas_mat_nl[diagind(elas_mat_nl)] = own_elas;\n\nelas_mat_nl[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -5.1197       0.0477573    0.0477573    0.00136172\n  0.050713    -2.34881      0.050713     0.001446\n  0.00615725   0.00615725  -2.80217      0.000175564\n  0.00218614   0.00218614   0.00218614  -1.83296"
  },
  {
    "objectID": "demand_estimation_2.html#section-4",
    "href": "demand_estimation_2.html#section-4",
    "title": "3  需要モデルの推定（基礎編 2）",
    "section": "3.5 7",
    "text": "3.5 7\n\n3.5.1 Step 1\n\nsort!(data, [:year, :NameID]);\nN = nrow(data);\nT = length(unique(data.year));\nX1 = hcat(repeat([1], N), Matrix(data[:, [:price, :FuelEfficiency, :hppw, :size]]));\nX2 = hcat(data.price, repeat([1], N), data.size);\nZ = hcat(\n    repeat([1], N),\n    Matrix(data[:, [:FuelEfficiency, :hppw, :size]]),\n    Matrix(data[:, r\"^iv_GH.*(?<!nest)$\"])\n    );\nRandom.seed!(123);\nNsim = 500;\n\ndraw_vec = reduce(hcat, [randn(size(X2, 2)) for j =1:Nsim]);\n\ntheta2 = [0.001, 0.001, 0.001];\n\nmarketindex = data.year;\nuniquemarketindex = sort(unique(data.year));\n\ntemp1 = reduce(hcat, [uniquemarketindex for j = 1:N])';\ntemp2 = reduce(hcat, [data.year for j = 1:T]);\ntempmat = (temp1 .== temp2);\nmutable struct datalist_struct\n    X1::Array{Float64,2};\n    X2::Array{Float64,2};\n    Z::Array{Float64,2};\n    ShareVec::Vector{Float64};\n    marketindex::Vector{Int64};\n    logitshare::Vector{Float64};\n    draw_vec::Array{Float64,2};\n    tempmat::BitMatrix\nend\n\nmutable struct parameter_struct\n    Nsim::Int;\n    T::Int;\n    N::Int;\nend\ndatalist = datalist_struct(X1, X2, Z, data.share, marketindex, data.logit_share, draw_vec, tempmat);\nparameter = parameter_struct(Nsim, T, N);\n\n\n\n3.5.2 Step 2\n\nfunction f_mktshare(\n        theta2,\n        datalist::datalist_struct,\n        parameter::parameter_struct,\n        delta\n    )\n        \n    mu = datalist.X2 * Diagonal(theta2) * datalist.draw_vec;\n    \n    delta_mu = delta .* ones((1, parameter.Nsim)) .+ mu;\n    exp_delta_mu = exp.(delta_mu .- maximum(delta_mu));\n    denom_outside = exp.(-maximum(delta_mu));\n    \n    denom_temp = (exp_delta_mu' * datalist.tempmat)' .+ denom_outside;\n    denom = datalist.tempmat * denom_temp;\n    \n    s_jt_i = exp_delta_mu ./ denom;\n    s_jt = vec(mean(s_jt_i, dims = 2));\n    \n    return s_jt\n    \nend\n@time f_mktshare([0.01, 0.01, 0.01], datalist, parameter, data.logit_share);\n\n  0.667970 seconds (2.42 M allocations: 182.419 MiB, 9.97% gc time, 93.71% compilation time)\n\n\n\n\n3.5.3 Step 3\n\nfunction f_contraction(\n        theta2,\n        datalist::datalist_struct,\n        parameter::parameter_struct,\n        delta_ini\n    )\n    \n    tol = 1e-11;\n    norm = 1e+10\n\n    delta_old = delta_ini;\n    exp_delta_old = exp.(delta_old);\n    \n    iter = 0;\n        \n    while ((norm > tol) & (iter < 1000))\n        \n#         print(iter, \"\\n\")\n        \n        pred_mkt_share = f_mktshare(theta2, datalist, parameter, delta_old);\n        \n        exp_delta = exp_delta_old .* datalist.ShareVec ./ pred_mkt_share;\n        \n        norm = maximum(abs.(exp_delta .- exp_delta_old));\n        \n        exp_delta_old = exp_delta;\n        delta_old = log.(exp_delta);\n        iter += 1;\n        \n    end\n    \n#     print(iter, \"\\n\")\n    \n    return delta_old;\n    \nend\n    \n@time f_contraction([0.1, 0.01, 0.01], datalist, parameter, data.logit_share);\n\n  0.316109 seconds (209.48 k allocations: 293.674 MiB, 13.47% gc time, 24.39% compilation time)\n\n\n\n\n3.5.4 Step 4\n\nfunction f_GMMobj(\n        theta2,\n        parameter::parameter_struct,\n        datalist::datalist_struct,\n        delta_ini::Vector{Float64}\n    )\n    \n#     delta_ini = delta_global;\n#     delta_ini = datalist.logitshare;\n    delta = f_contraction(theta2, datalist, parameter, delta_ini);\n#     global delta_global = delta\n    \n#     if (datalist.weight_mat_option == \"2SLS\") \n        W = inv(datalist.Z' * datalist.Z);\n#     elseif (datalist.weight_mat_option == \"Ident\")\n#         W = I(size(datalist.Z, 2));\n#     end\n    \n    beta_hat = (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ (datalist.X1' * datalist.Z * W * datalist.Z' * delta);\n    \n    Xi = delta - datalist.X1 * beta_hat;\n    \n    output = Xi' * datalist.Z * W * datalist.Z' * Xi\n        \n    return output\n    \nend    \n    \ninitial_x = [0.1, 1.0, 0.1];\ndelta_ini = f_contraction(initial_x, datalist, parameter, datalist.logitshare);\n\n\nobjFunc_for_Optim = TwiceDifferentiable(\n    x -> f_GMMobj(x, parameter, datalist, delta_ini),\n    initial_x;\n    autodiff = :forward\n    );\n@time gmm_res = optimize(\n    objFunc_for_Optim,\n#     x -> f_GMMobj(x, parameter, datalist, delta_ini),\n    [0.0, 0.00, 0.00],\n    [Inf, Inf, Inf],\n    initial_x,\n    Optim.Options(show_trace = true)\n)\n\n\n\n * Status: success\n\n * Candidate solution\n    Final objective value:     1.720392e+02\n\n * Found with\n    Algorithm:     Interior Point Newton\n\n * Convergence measures\n    |x - x'|               = 0.00e+00 ≤ 0.0e+00\n    |x - x'|/|x'|          = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 9.27e+00 ≰ 1.0e-08\n\n * Work counters\n    Seconds run:   376  (vs limit Inf)\n    Iterations:    24\n    f(x) calls:    218\n    ∇f(x) calls:   218\n\n\n\ngmm_res.minimizer\n\n3-element Vector{Float64}:\n  0.28734533108108296\n 15.767041571288186\n  0.07564921477989821\n\n\n\nW = inv(datalist.Z' * datalist.Z);    \ndelta = f_contraction(gmm_res.minimizer, datalist, parameter, delta_ini);\nbeta_hat = (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ (datalist.X1' * datalist.Z * W * datalist.Z' * delta);\n\nbeta_hat\n\n5-element Vector{Float64}:\n -30.94355607145988\n  -0.9028865616490973\n   0.11090678367437005\n   9.193592802875408\n   0.28736901935168374\n\n\n\n\n3.5.5 Step 5\n\nXi = delta - X1 * beta_hat;\nOmega_hat = reduce(+, Z[i,:] * Z[i,:]' .* Xi[i]^2 ./ N for i = 1:N);\nDdelta = ForwardDiff.jacobian(x -> delta_ini = f_contraction(x, datalist, parameter, delta), gmm_res.minimizer);\nG = Z' * hcat(- X1, Ddelta) ./ N;\nAsyVarMat = (G' * W * G) \\ G' * W * Omega_hat * W * G * inv(G' * W * G);\nAse = sqrt.(diag(AsyVarMat) ./ N);\n\nDataFrame(\n    Var = [\"Const\", \"Price\", \"Fuel Efficiency\", \"hppw\", \"size\", \"random_price\", \"random_constant\", \"random_size\"],\n    Est = vcat(beta_hat, gmm_res.minimizer),\n    se = Ase\n)\n\n\n8×3 DataFrameRowVarEstseStringFloat64Float641Const-30.943615.51382Price-0.9028870.4330623Fuel Efficiency0.1109070.01105714hppw9.193593.113645size0.2873690.05171996random_price0.2873450.4324577random_constant15.767101.9688random_size0.07564920.290593"
  },
  {
    "objectID": "demand_estimation_2.html#section-5",
    "href": "demand_estimation_2.html#section-5",
    "title": "3  需要モデルの推定（基礎編 2）",
    "section": "3.6 8",
    "text": "3.6 8\n\nmu = X2 * Diagonal(gmm_res.minimizer) * draw_vec;\ndelta_mu = delta .+ mu;\nexp_delta_mu = exp.(delta_mu);\ndenom_outside = exp.(0.0);\ndenom_temp = (exp_delta_mu' * tempmat)' .+ denom_outside;\ndenom = tempmat * denom_temp;\n\ns_jt_i = exp_delta_mu ./ denom;\ndraw_for_price = draw_vec[1,:];\nalpha_i = beta_hat[2] .+ gmm_res.minimizer[1] .* draw_for_price;\nyear = 2016\nJ_t = sum(data.year .== year);\n\nag_model_s_i = s_jt_i[data.year .== year, :]\nag_model_s = mean(ag_model_s_i, dims = 2);\nprice_t = data.price[data.year .== year];\n\nelasmat = zeros((J_t, J_t));\n\nfor k in 1:J_t, j in 1:J_t\n    if (k != j)\n        elasmat[k, j] = (-1.0) .* price_t[k] ./ ag_model_s[j] * mean(alpha_i .* ag_model_s_i[j, :] .* ag_model_s_i[k, :])\n    elseif (k == j)\n        elasmat[k, j] = price_t[j] ./ ag_model_s[j] * mean(alpha_i .* ag_model_s_i[j, :] .* (1.0 .- ag_model_s_i[j, :]))\n    end\nend\n\n\nelasmat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -1.10253      0.0451789    0.0435272    0.0324128\n  0.0153236   -0.832714     0.0153759    0.0109914\n  0.0184981    0.0192656   -1.12275      0.0138002\n  0.00450168   0.00450075   0.00450998  -2.50034"
  },
  {
    "objectID": "demand_estimation_2.html#section-6",
    "href": "demand_estimation_2.html#section-6",
    "title": "3  需要モデルの推定（基礎編 2）",
    "section": "3.7 9",
    "text": "3.7 9\n\nfunction f_revenue(\n        price_cand,\n        data,\n        datalist,\n        parameter,\n        delta,\n        beta_hat,\n        theta2,\n        option\n    )\n\n    mc_betado = 3.198 * (1.0 - 1.0 / abs(-2.16720791));\n\n    tempprice = data.price[:];\n    tempprice[(data.NameID .== 197) .& (data.year .== 2016)] .= price_cand;\n    \n    X1_new = datalist.X1[:,:];\n    X2_new = datalist.X2[:,:];\n    X1_new[:, 2] = tempprice;\n    X2_new[:, 1] = tempprice;\n    \n    org_xi = delta .- datalist.X1 * beta_hat;\n    new_delta = X1_new * beta_hat .+ org_xi;\n    \n    datalist_temp = datalist_struct(\n        X1_new, X2_new, datalist.Z, data.share, datalist.marketindex, \n        data.logit_share, datalist.draw_vec, datalist.tempmat\n        );\n    \n    mktshare = f_mktshare(theta2, datalist_temp, parameter, new_delta);\n    \n    quant = mktshare .* data.HH;\n    revenue = tempprice .* quant;\n        \n    revenuevec  = revenue[(data.NameID .== 197) .& (data.year .== 2016)];\n    revenuevec2 = sum(revenue[in(NIPPYOautoIDvec).(data[:, :NameID]) .& (data.year .== 2016)]);\n    \n    pivec  = revenuevec  .- mc_betado .* quant[(data.NameID .== 197) .& (data.year .== 2016)];\n    pivec2 = revenuevec2 .- mc_betado .* quant[(data.NameID .== 197) .& (data.year .== 2016)];\n\n    if option == \"own\"\n        return(revenuevec[1])\n    elseif option == \"total\"\n        return(revenuevec2[1])\n    elseif option == \"ownpi\"\n        return(pivec[1])\n    elseif option == \"totalpi\"\n        return(pivec2[1])\n    end\n    \nend\nprice_range = range(1.8, 4.0, step = 0.05);\nownpi_res = f_revenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(parameter), Ref(delta), Ref(beta_hat), Ref(gmm_res.minimizer),\n    \"ownpi\"\n);\nplot(price_range, ownpi_res, legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprice_range = range(1.8, 4.0, step = 0.05);\ntotalpi_res = f_revenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(parameter), Ref(delta), Ref(beta_hat), Ref(gmm_res.minimizer),\n    \"totalpi\"\n);\nplot(price_range, totalpi_res, legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nownpi_optim_res = optimize(\n    x -> - f_revenue(x[1], data, datalist, parameter, delta, beta_hat, gmm_res.minimizer, \"ownpi\"),\n    [3.0]\n)\n\nownpi_optim_res.minimizer\n\n1-element Vector{Float64}:\n 2.967175245285034\n\n\n\ntotalpi_optim_res = optimize(\n    x -> - f_revenue(x[1], data, datalist, parameter, delta, beta_hat, gmm_res.minimizer, \"totalpi\"),\n    [3.0]\n)\ntotalpi_optim_res.minimizer\n\n1-element Vector{Float64}:\n 3.136022758483887"
  },
  {
    "objectID": "demand_estimation_1.html#data-cleaning",
    "href": "demand_estimation_1.html#data-cleaning",
    "title": "2  需要モデルの推定（基礎編 1）",
    "section": "2.1 Data cleaning",
    "text": "2.1 Data cleaning\n\ndata = data[!, [\n        :Maker, :Type, :Name, :Year, :Sales, \n        :Model, :price, :kata, :weight, :FuelEfficiency, \n        :HorsePower, :overall_length, :overall_width, :overall_height\n        ]]\nrename!(data, \"Year\" => \"year\")\ndata = leftjoin(data, dataHH, on = :year)\ndata = leftjoin(data, dataCPI, on = :year)\nfirst(data, 5)\n\n\n5×16 DataFrameRowMakerTypeNameyearSalesModelpricekataweightFuelEfficiencyHorsePoweroverall_lengthoverall_widthoverall_heightHHCPIString15String7String31Int64Int64StringFloat64String15Int64Float64?Int64?Int64Int64Int64Int64?Float64?1AudiForeignA1シリーズ201142061.4 TFSI289.0DBA-8XCAX119019.41223970174014405378343596.32AudiForeignA1シリーズ201245021.4 TFSI273.0DBA-8XCAX119019.41223970174014405417147596.23AudiForeignA1シリーズ201350711.4 TFSI273.0DBA-8XCAX119019.41223970174014405459474496.64AudiForeignA3シリーズ20064830アトラクション284.0GH-8PBSE136012.21024285176514305110200597.25AudiForeignA3シリーズ20073874アトラクション286.0GH-8PBSE136012.21024285176514305171304897.2\n\n\n\ndropmissing!(data, :FuelEfficiency);\n\n\ncpi2016 = dataCPI[dataCPI.year .== 2016, \"CPI\"][1]\ndata[!, :price] = data.price ./ (data.CPI / cpi2016) / 100;\n\n\ndata[!, :size] = (data[:, :overall_length] / 1000) .* (data[:, :overall_width] / 1000) .* (data[:, :overall_height] / 1000);\ndata[!, :hppw] = data[:, :HorsePower] ./ data[:, :weight];\n\nunique_name = unique(data[!, [:Name]])\nunique_name[!, :NameID] = rownumber.(eachrow(unique_name))\ndata = leftjoin(data, unique_name, on = :Name);\n\ndata = transform(\n    groupby(data, :year),\n    :Sales => sum => :inside_total\n);\ndata[!, :outside_total] = data.HH .- data.inside_total;\ndata[!, :share] = data.Sales ./ data.HH;\ndata[!, :share0] = data.outside_total ./ data.HH;\n\n\ntransform!(\n    groupby(data, [:year, :Maker]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_own, :FuelEfficiency_sum_own, :size_sum_own],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_own, :FuelEfficiency_sqr_sum_own, :size_sqr_sum_own],\n    nrow => \"group_n\"\n);\ntransform!(\n    groupby(data, [:year]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_mkt, :FuelEfficiency_sum_mkt, :size_sum_mkt],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_mkt, :FuelEfficiency_sqr_sum_mkt, :size_sqr_sum_mkt],\n    nrow => \"mkt_n\"\n);\n\n\ndata[!, :iv_BLP_own_hppw]             = data[:, :hppw_sum_own]           .- data[:, :hppw];\ndata[!, :iv_BLP_own_FuelEfficiency]   = data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency];\ndata[!, :iv_BLP_own_size]             = data[:, :size_sum_own]           .- data[:, :size];\ndata[!, :iv_BLP_other_hppw]           = data[:, :hppw_sum_mkt]           .- data[:, :hppw_sum_own];\ndata[!, :iv_BLP_other_FuelEfficiency] = data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own];\ndata[!, :iv_BLP_other_size]           = data[:, :size_sum_mkt]           .- data[:, :size_sum_own];\n\n\ndata[!, :iv_GH_own_hppw]             = (\n    (data[:, :group_n] .- 1) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_own] .- data[:, :hppw].^2) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_own] .- data[:, :hppw])\n);\ndata[!, :iv_GH_own_FuelEfficiency]   = (\n    (data[:, :group_n] .- 1) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_own] .- data[:, :FuelEfficiency].^2) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency])\n);\ndata[!, :iv_GH_own_size]             = (\n    (data[:, :group_n] .- 1) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_own] .- data[:, :size].^2) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_own] .- data[:, :size])\n);\ndata[!, :iv_GH_other_hppw]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_mkt] .- data[:, :hppw_sqr_sum_own]) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_mkt] .- data[:, :hppw_sum_own])\n);\ndata[!, :iv_GH_other_FuelEfficiency] = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_mkt] .- data[:, :FuelEfficiency_sqr_sum_own]) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own])\n);\ndata[!, :iv_GH_other_size]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_mkt] .- data[:, :size_sqr_sum_own]) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_mkt] .- data[:, :size_sum_own])\n);\n\n\nNIPPYOautoIDvec = [\n    260, 4, 76, 104, 64, 54, 152, 153, 71, 197,\n    42, 45, 114, 208, 209, 77, 236, 58, 127, 187,\n    79, 175, 19, 117, 216, 112, 256, 119, 37, 158\n];\n\n\ndata_NIPPYO = data[in(NIPPYOautoIDvec).(data[:, :NameID]), [:Sales, :price, :hppw, :FuelEfficiency, :size]];\ndata_NIPPYO[!, :log_sales] = log.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log_price] = log.(data_NIPPYO[:, :price]);\ndata_NIPPYO[!, :log10_sales] = log10.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log10_price] = log10.(data_NIPPYO[:, :price]);\n\n\nols_intro = reg(\n    data_NIPPYO, \n    @formula(log_sales ~ log_price + hppw + FuelEfficiency + size),\n    Vcov.robust()\n)\n\n                                 FixedEffectModel                                 \n==================================================================================\nNumber of obs:                       196  Converged:                          true\ndof (model):                           4  dof (residuals):                     190\nR²:                                0.217  R² adjusted:                       0.201\nF-statistic:                     19.1148  P-value:                           0.000\n==================================================================================\n                  Estimate  Std. Error    t-stat  Pr(>|t|)    Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────────────────\nlog_price       -1.24828     0.309545   -4.03262    <1e-04   -1.85886    -0.63769\nhppw            -4.19685     3.97622    -1.05549    0.2925  -12.0401      3.64635\nFuelEfficiency   0.0886034   0.0283887   3.12108    0.0021    0.0326059   0.144601\nsize             0.306896    0.0588927   5.2111     <1e-06    0.190728    0.423063\n(Intercept)      5.76211     1.06127     5.42946    <1e-06    3.66873     7.85549\n==================================================================================\n\n\n\nfit_line = predict(\n    lm(@formula(log10_sales ~ log10_price), data_NIPPYO)\n    );\nplot(\n    data_NIPPYO.price, \n    data_NIPPYO.Sales, \n    seriestype = :scatter, \n    legend = false,\n    xscale = :log10,\n    yscale = :log10,\n    xlabel = \"Price\",\n    ylabel = \"Sales\",\n    xticks = ([1, 3, 10], [1, 3, 10]),\n)\nplot!(\n    data_NIPPYO.price, \n    10 .^ fit_line,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndescribe(data[:, [:Sales, :price, :FuelEfficiency, :size, :hppw]])\n\n\n5×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64RealFloat64RealInt64DataType1Sales24586.4108544.03176750Int642price2.530470.7051762.0504212.62650Float643FuelEfficiency16.15975.515.440.80Float644size11.50535.90911.472519.15480Float645hppw0.09913120.0450.09268290.3238640Float64\n\n\n\ndata[!, :logit_share] = log.(data[:, :share]) .- log.(data[:, :share0]);\n\n\nols_res = reg(data, @formula(logit_share ~ price + hppw + FuelEfficiency + size), Vcov.robust());\niv_BLP_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust()\n);\niv_GH_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust(),\n    save = true\n);\n\n\nregtable(ols_res, iv_BLP_res, iv_GH_res)\n\n\n--------------------------------------------------------------\n                                       logit_share            \n                          ------------------------------------\n                                 (1)          (2)          (3)\n--------------------------------------------------------------\n(Intercept)               -12.255***   -12.323***   -12.973***\n                             (0.365)      (0.382)      (0.393)\nprice                      -0.255***    -0.283***    -0.552***\n                             (0.026)      (0.067)      (0.080)\nhppw                          -0.654        0.213      8.426**\n                             (1.284)      (2.298)      (2.638)\nFuelEfficiency              0.130***     0.130***     0.127***\n                             (0.010)      (0.010)      (0.010)\nsize                        0.182***     0.187***     0.236***\n                             (0.019)      (0.021)      (0.022)\n--------------------------------------------------------------\nEstimator                        OLS           IV           IV\n--------------------------------------------------------------\nN                              1,823        1,823        1,823\nR2                             0.222        0.222        0.180\nWithin-R2                                                     \nFirst-stage F statistic                    33.926       51.583\n--------------------------------------------------------------\n\n\n\n\niv1st_BLP_res = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n        ),\n    Vcov.robust()\n);\niv1st_GH_res = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n        ),\n    Vcov.robust()\n);\n\n\nregtable(iv1st_BLP_res, iv1st_GH_res)\n\n\n---------------------------------------------------\n                                      price        \n                              ---------------------\n                                    (1)         (2)\n---------------------------------------------------\n(Intercept)                      -3.159    -1.325**\n                                (1.685)     (0.423)\nhppw                          28.749***   23.508***\n                                (0.993)     (1.547)\nFuelEfficiency                   -0.011   -0.072***\n                                (0.008)     (0.014)\nsize                           0.202***    0.189***\n                                (0.015)     (0.020)\niv_BLP_own_hppw                 -0.728*            \n                                (0.336)            \niv_BLP_own_FuelEfficiency     -0.007***            \n                                (0.001)            \niv_BLP_own_size                0.013***            \n                                (0.004)            \niv_BLP_other_hppw                 0.165            \n                                (0.255)            \niv_BLP_other_FuelEfficiency     0.001**            \n                                (0.000)            \niv_BLP_other_size                -0.002            \n                                (0.003)            \niv_GH_own_hppw                            -1.889***\n                                            (0.439)\niv_GH_own_FuelEfficiency                      0.000\n                                            (0.000)\niv_GH_own_size                            -0.001***\n                                            (0.000)\niv_GH_other_hppw                           0.423***\n                                            (0.096)\niv_GH_other_FuelEfficiency                 0.000***\n                                            (0.000)\niv_GH_other_size                           0.000***\n                                            (0.000)\n---------------------------------------------------\nN                                 1,823       1,823\nR2                                0.616       0.623\n---------------------------------------------------\n\n\n\n\ndata[!, :own_elas_ols]   = ols_res.coef[ols_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\ndata[!, :own_elas_ivblp] = iv_BLP_res.coef[iv_BLP_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\ndata[!, :own_elas_ivgh]  = iv_GH_res.coef[iv_GH_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\n\n\ndescribe(data[:, r\"^own_elas\"])\n\n\n3×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64Float64Float64Float64Int64DataType1own_elas_ols-0.645328-3.22104-0.522324-0.1798920Float642own_elas_ivblp-0.717085-3.5792-0.580404-0.1998950Float643own_elas_ivgh-1.3967-6.9714-1.13048-0.3893460Float64\n\n\n\ndt_application = data[:, [:NameID, :year, :Sales, :price, :FuelEfficiency, :size, :hppw, :HH, :share]];\ndt_application[!, :xi_fit] = iv_GH_res.residuals;\n\n\nNameID_target = 197\ndt_application[(dt_application.year .== 2016) .& (dt_application.NameID .== NameID_target), :]\n\n\n1×10 DataFrameRowNameIDyearSalespriceFuelEfficiencysizehppwHHsharexi_fitInt64?Int64Int64Float64Float64Float64Float64Int64?Float64Float64?11972016370693.19811.617.09440.0947917569507570.0006508961.16401\n\n\n\nfunction f_share(\n        price_cand,\n        year, \n        NameID_target,\n        dt,\n        est_res\n    )\n    \n    dt = dt[dt.year .== year, :]\n    dt[!, :temp_price] = dt[:, :price]\n    dt[(dt[:, :NameID] .== NameID_target), :temp_price] .= price_cand\n    dt[!, :delta] = (\n        est_res.coef[est_res.coefnames .== \"(Intercept)\"] .+\n        est_res.coef[est_res.coefnames .== \"hppw\"] .* dt[:, :hppw] .+\n        est_res.coef[est_res.coefnames .== \"FuelEfficiency\"] .* dt[:, :FuelEfficiency] .+\n        est_res.coef[est_res.coefnames .== \"size\"] .* dt[:, :size] .+\n        est_res.coef[est_res.coefnames .== \"price\"] .* dt[:, :temp_price] .+\n        dt[:, :xi_fit]\n    )\n    dt[!, :denom] .= 1 .+ sum(exp.(dt[:, :delta]))\n    dt[!, :pred_sales] = exp.(dt[:, :delta]) ./ dt[:, :denom] .* dt[:, :HH]\n    dt = dt[dt.NameID .== NameID_target, :]\n    \n    return dt.pred_sales[1]\n    \nend\n\nf_share (generic function with 1 method)\n\n\n\npricevec = range(0.3, 5, step = 0.05);\nquantvec = f_share.(pricevec, 2016, NameID_target, Ref(dt_application), Ref(iv_GH_res));\n\n\nplot(quantvec, pricevec, xticks = [50000, 100000, 150000], legend = false)\nxlabel!(\"Sales\")\nylabel!(\"Price (million JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(pricevec, pricevec .* quantvec / 1000, legend = false)\nxlabel!(\"Price (million JPY)\")\nylabel!(\"Revenue (billion JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nopt_res = optimize(\n    x -> - f_share(x[1], 2016, NameID_target, dt_application, iv_GH_res) * x[1],\n    [1.0]\n);\n\n@printf(\"Revenue-maximizing price: %.3f \\n\", opt_res.minimizer[1])\n@printf(\"Max revenue : %.3f\", -opt_res.minimum)\n\nRevenue-maximizing price: 1.814 \nMax revenue : 144273.836"
  },
  {
    "objectID": "demand_estimation_merger.html#data-cleaning",
    "href": "demand_estimation_merger.html#data-cleaning",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.1 Data cleaning",
    "text": "4.1 Data cleaning\n\ndata[!, :Foreign_d] = data[:, :Type] .== \"Foreign\";\ndata[!, :FuelRegular_d] = data[:, :FuelType] .== \"レギュラー\";\ndata[!, :capacity_d] = data[:, :capacity] .> 4;\ntransform!(data, [:year => ByRow(isequal(v))=> Symbol(\"year_\" * string(v)) for v in unique(data.year)]);\nselect!(data, Not(:year_2006));"
  },
  {
    "objectID": "demand_estimation_merger.html#section",
    "href": "demand_estimation_merger.html#section",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.2 4.2",
    "text": "4.2 4.2\n\nsort!(data, [:year, :Maker, :price]);\nN = nrow(data);\nT = length(unique(data.year));\nX1 = hcat(\n    repeat([1], N), \n    Matrix(data[:, [:price, :FuelEfficiency, :hppw, :size, :capacity_d, :FuelRegular_d, :Foreign_d]]),\n    Matrix(data[:, r\"^year_\"])    \n    );\nX2 = Matrix(data[:, [:price]]);\nZ = hcat(\n    repeat([1], N),\n    Matrix(data[:, [:FuelEfficiency, :hppw, :size, :capacity_d, :FuelRegular_d, :Foreign_d]]),\n    Matrix(data[:, r\"^year_\"]),\n    Matrix(data[:, r\"^iv_GH.*(?<!nest)$\"])\n    );\nRandom.seed!(42);\nNsim = 1000;\n\ndraw_vec = reduce(hcat, [randn(size(X2, 2)) for j =1:Nsim]);\n\nmarketindex = data.year;\nuniquemarketindex = sort(unique(data.year));\n\n\ntemp1 = reduce(hcat, [uniquemarketindex for j = 1:N])';\ntemp2 = reduce(hcat, [data.year for j = 1:T]);\nmkt_denom_d = (temp1 .== temp2);\n\nmutable struct datalist_struct\n    X1::Array{Float64,2};\n    X2::Array{Float64,2};\n    Z::Array{Float64,2};\n    ShareVec::Vector{Float64};\n    marketindex::Vector{Int64};\n    logitshare::Vector{Float64};\n    draw_vec::Array{Float64,2};\n    mkt_denom_d::BitMatrix\nend\n\nmutable struct parameter_struct\n    Nsim::Int;\n    T::Int;\n    N::Int;\nend\ndatalist = datalist_struct(X1, X2, Z, data.share, marketindex, data.logit_share, draw_vec, mkt_denom_d);\nparameter = parameter_struct(Nsim, T, N);"
  },
  {
    "objectID": "demand_estimation_merger.html#section-1",
    "href": "demand_estimation_merger.html#section-1",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.3 4.3",
    "text": "4.3 4.3\n\nfunction f_mktshare(\n        theta2,\n        datalist::datalist_struct,\n        parameter::parameter_struct,\n#         delta::Vector{Float64}\n        delta\n    )\n        \n    mu = datalist.X2 * Diagonal(theta2) * datalist.draw_vec;\n    \n    delta_mu = delta .* ones((1, parameter.Nsim)) .+ mu;\n    exp_delta_mu = exp.(delta_mu .- maximum(delta_mu));\n    denom_outside = exp.(-maximum(delta_mu));\n    \n    denom_temp = (exp_delta_mu' * datalist.mkt_denom_d)' .+ denom_outside;\n    denom = datalist.mkt_denom_d * denom_temp;\n    \n    s_jt_i = exp_delta_mu ./ denom;\n    s_jt = vec(mean(s_jt_i, dims = 2));\n    \n    return s_jt\n    \nend\n\nf_mktshare (generic function with 1 method)\n\n\n\nfunction f_contraction(\n        theta2,\n        datalist::datalist_struct,\n        parameter::parameter_struct,\n        delta_ini::Vector{Float64}\n    )\n    \n    tol = 1e-11;\n    norm = 1e+10\n\n    delta_old = delta_ini;\n    exp_delta_old = exp.(delta_old);\n    \n    iter = 0;\n        \n    while ((norm > tol) & (iter < 1000))\n        \n        # print(iter, \"\\n\")\n        \n        pred_mkt_share = f_mktshare(theta2, datalist, parameter, delta_old);\n        \n        exp_delta = exp_delta_old .* datalist.ShareVec ./ pred_mkt_share;\n        \n        norm = maximum(abs.(exp_delta .- exp_delta_old));\n        \n        exp_delta_old = exp_delta;\n        delta_old = log.(exp_delta_old);\n        iter += 1;\n        \n    end\n    \n#     print(iter, \"\\n\")\n    \n    return delta_old;\n    \nend\n\nf_contraction (generic function with 1 method)\n\n\n\nfunction f_GMMobj(\n        theta2,\n        parameter::parameter_struct,\n        datalist::datalist_struct,\n        delta_ini::Vector{Float64}\n    )\n    \n#     delta_ini = delta_global;\n#     delta_ini = datalist.logitshare;\n    delta = f_contraction(theta2, datalist, parameter, delta_ini);\n#     global delta_global = delta\n    \n#     if (datalist.weight_mat_option == \"2SLS\") \n        W = inv(datalist.Z' * datalist.Z);\n#     elseif (datalist.weight_mat_option == \"Ident\")\n#         W = I(size(datalist.Z, 2));\n#     end\n    \n    beta_hat = (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ (datalist.X1' * datalist.Z * W * datalist.Z' * delta);\n    \n    Xi = delta - datalist.X1 * beta_hat;\n    \n    output = Xi' * datalist.Z * W * datalist.Z' * Xi\n        \n    return output\n    \nend    \n\nf_GMMobj (generic function with 1 method)\n\n\n\ninitial_x = [0.1];\ndelta_ini = f_contraction(initial_x, datalist, parameter, datalist.logitshare);\nobjFunc_for_Optim = TwiceDifferentiable(\n    x -> f_GMMobj(x, parameter, datalist, delta_ini),\n    initial_x;\n    autodiff = :forward\n    );\n\n\n@time gmm_res = optimize(\n    objFunc_for_Optim,\n#     x -> f_GMMobj(x, parameter, datalist, delta_ini),\n    [0.0],\n    [Inf],\n    initial_x,\n    Optim.Options(show_trace = true)\n)\n\n\nW = inv(datalist.Z' * datalist.Z);    \ndelta = f_contraction(gmm_res.minimizer, datalist, parameter, delta_ini);\nbeta_hat = (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ (datalist.X1' * datalist.Z * W * datalist.Z' * delta);\n\n\nXi = delta - X1 * beta_hat;\nOmega_hat = reduce(+, Z[i,:] * Z[i,:]' .* Xi[i]^2 ./ N for i = 1:N);\nDdelta = ForwardDiff.jacobian(x -> delta_ini = f_contraction(x, datalist, parameter, delta), gmm_res.minimizer);\nG = Z' * hcat(- X1, Ddelta) ./ N;\nAsyVarMat = (G' * W * G) \\ G' * W * Omega_hat * W * G * inv(G' * W * G);\nAse = sqrt.(diag(AsyVarMat) ./ N);\nDataFrame(\n    Var = [\n        \"Const\", \"Price\", \"Fuel Efficiency\", \"hppw\", \"size\", \n        \"capacity_d\", \"FuelRegular_d\", \"Foreign_d\",\n        \"year_2007\", \"year_2008\", \"year_2009\", \n        \"year_2010\", \"year_2011\", \"year_2012\", \n        \"year_2013\", \"year_2014\", \"year_2015\", \"year_2016\", \n        \"random_price\"\n        ],\n    Est = vcat(beta_hat, gmm_res.minimizer),\n    se = Ase\n)\n\n\n19×3 DataFrameRowVarEstseStringFloat64Float641Const-13.87310.570262Price-2.267720.6542083Fuel Efficiency0.1953580.01254264hppw14.1233.470385size0.5453740.07553966capacity_d-0.3130330.1371747FuelRegular_d-1.092670.2833088Foreign_d1.020950.1888469year_2007-0.8329130.17399910year_2008-0.7013770.16762111year_2009-0.853050.16862512year_2010-0.09790130.1515613year_2011-0.2510120.15093514year_2012-0.4822760.15959315year_2013-0.6233620.16528716year_2014-1.044770.18009317year_2015-1.14340.17826418year_2016-1.245770.18107519random_price0.6473260.218627\n\n\n\nmu = X2 * Diagonal(gmm_res.minimizer) * draw_vec;\ndelta_mu = delta .+ mu;\nexp_delta_mu = exp.(delta_mu);\ndenom_outside = exp.(0.0);\ndenom_temp = (exp_delta_mu' * mkt_denom_d)' .+ denom_outside;\ndenom = mkt_denom_d * denom_temp;\n\ns_jt_i = exp_delta_mu ./ denom;\ndraw_for_price = draw_vec[1,:];\nalpha_i = beta_hat[2] .+ gmm_res.minimizer[1] .* draw_for_price;\nyear = 2016\nJ_t = sum(data.year .== year);\ndata_t = data[data.year .== year, :];\n\nag_model_s_i = s_jt_i[data.year .== year, :]\nag_model_s = mean(ag_model_s_i, dims = 2);\nprice_t = data.price[data.year .== year];\n\nelasmat_t = zeros((J_t, J_t));\n\nfor k in 1:J_t, j in 1:J_t\n    if (k != j)\n        elasmat_t[k, j] = (-1.0) .* price_t[k] ./ ag_model_s[j] * mean(alpha_i .* ag_model_s_i[j, :] .* ag_model_s_i[k, :])\n    elseif (k == j)\n        elasmat_t[k, j] = price_t[j] ./ ag_model_s[j] * mean(alpha_i .* ag_model_s_i[j, :] .* (1.0 .- ag_model_s_i[j, :]))\n    end\nend"
  },
  {
    "objectID": "demand_estimation_merger.html#section-2",
    "href": "demand_estimation_merger.html#section-2",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.4 5",
    "text": "4.4 5\n\nPricevec_t = data_t.price;\nSharevec_t = data_t.share;\n\nOwnership_t = data_t.Maker .== permutedims(data_t.Maker);\nDerivative_t = - elasmat_t .* Sharevec_t' ./ Pricevec_t;\nDelta_t = Derivative_t .* Ownership_t;\nMarginal_Cost_t = Pricevec_t - (Delta_t \\ Sharevec_t);\npred_mc_df = DataFrame(\n    Maker = data_t.Maker, \n    Name = data_t.Name, \n    Price = data_t.price,\n    MC = Vector{Float64}(Marginal_Cost_t),\n    Margin = (data_t.price .- Marginal_Cost_t) ./ data_t.price\n)\n\n\n169×5 DataFrame144 rows omittedRowMakerNamePriceMCMarginString15String31Float64Float64Float641AudiA3シリーズ3.282.375010.2759122AudiA4シリーズ5.183.632390.2987663BMWミニ2.41.681840.2992354BMW1シリーズ3.12.235820.2787685BMWX13.672.655280.2764896BMW2シリーズ3.812.753680.277257BMW3シリーズ4.493.20580.2860138Daihatsuミラ0.8850.3675910.5846439Daihatsuムーヴ1.1340.5908010.47901210Daihatsuブーン1.150.6050560.47386411Daihatsuキャスト1.220.6672930.45303912Daihatsuタント1.220.6672930.45303913Daihatsuウェイク1.350.7822940.420523⋮⋮⋮⋮⋮⋮158ToyotaFJクルーザー3.242.283540.295204159Toyotaエスティマ3.2712.305940.295034160ToyotaSAI3.3042.329690.294888161Toyotaクラウン3.8122.681830.296477162Toyotaランドクルーザー4.7283.255020.311544163Toyotaセンチュリー12.5387.49940.401866164Volkswagenポロ1.9991.34880.325264165Volkswagenゴルフ2.4991.764190.294041166Volkswagenビートル2.6991.925280.28667167Volkswagenパサート3.4862.526640.275203168Volvo40シリーズ3.242.34540.27611169Volvo60シリーズ4.543.244720.285305\n\n\n\nhistogram(pred_mc_df.Margin, bins = 40, legend = false)"
  },
  {
    "objectID": "demand_estimation_merger.html#section-3",
    "href": "demand_estimation_merger.html#section-3",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.5 6",
    "text": "4.5 6\n\ndata_2016 = data[data.year .== 2016, :];\ndata_2016 = leftjoin(data_2016, pred_mc_df, on = [\"Maker\", \"Name\"]);\ndropmissing!(data_2016);\n\ndata_2016[data_2016.Maker .== \"Honda\", :Maker] .= \"Nippyo\";\ndata_2016[data_2016.Maker .== \"Nissan\", :Maker] .= \"BrandA\";\ndata_2016[data_2016.Maker .== \"Subaru\", :Maker] .= \"BrandB\";\ndata_2016[data_2016.Maker .== \"Toyota\", :Maker] .= \"BrandC\";\n\ndata_2016[!, :MakerNippyoA] = data_2016[:, :Maker];\ndata_2016[!, :MakerNippyoB] = data_2016[:, :Maker];\ndata_2016[in([\"Nippyo\", \"BrandA\"]).(data_2016[:, :Maker]), :MakerNippyoA] .= \"NippyoA\";\ndata_2016[in([\"Nippyo\", \"BrandB\"]).(data_2016[:, :Maker]), :MakerNippyoB] .= \"NippyoB\";\nJ = nrow(data_2016);\n\nOwnership_true = data_2016.Maker .== permutedims(data_2016.Maker);\nOwnership_NippyoA = data_2016.MakerNippyoA .== permutedims(data_2016.MakerNippyoA);\nOwnership_NippyoB = data_2016.MakerNippyoB .== permutedims(data_2016.MakerNippyoB);"
  },
  {
    "objectID": "demand_estimation_merger.html#section-4",
    "href": "demand_estimation_merger.html#section-4",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.6 6.4",
    "text": "4.6 6.4\n\nmc = data_2016.MC;\ndatalist_2016 = datalist_struct(\n    X1[data.year .== 2016, :],\n    X2[data.year .== 2016, :],\n    Z[data.year .== 2016, :],\n    data_2016.share,\n    data_2016.year,\n    data_2016.logit_share,\n    datalist.draw_vec,\n    datalist.mkt_denom_d[data.year .== 2016, :]\n);\n\n\nfunction f_update(\n        datalist::datalist_struct,\n        p_old::Vector{Float64},\n        Ownership::BitMatrix,\n        parameter::parameter_struct,\n        theta1::Vector{Float64},\n        theta2::Vector{Float64},\n        mc::Vector{Float64},\n        Xi::Vector{Float64}\n    )\n    \n    X1_new = datalist.X1[:, :];\n    X2_new = reshape(p_old, (:, 1));\n    X1_new[:, 2] .= p_old;\n    \n    delta = (X1_new * theta1) .+ Xi;\n    datalist_new = datalist_struct(\n        X1_new, X2_new, datalist.Z, datalist.ShareVec, datalist.marketindex, \n        datalist.logitshare, datalist.draw_vec, datalist.mkt_denom_d\n        );\n    Sharevec = f_mktshare(\n        theta2, datalist_new, parameter, delta\n    );\n    \n    # elasticity\n    mu = datalist_new.X2 * Diagonal(theta2) * datalist_new.draw_vec;\n    delta_mu = delta .+ mu;\n    exp_delta_mu = exp.(delta_mu);\n    denom_outside = exp.(0.0);\n    denom_temp = (exp_delta_mu' * datalist_new.mkt_denom_d)' .+ denom_outside;\n    denom = datalist_new.mkt_denom_d * denom_temp;\n\n    s_jt_i = exp_delta_mu ./ denom;\n    draw_for_price = datalist_new.draw_vec[1,:];\n    alpha_i = theta1[2] .+ theta2[1] .* draw_for_price;\n    \n    J = size(X1_new, 1);\n    \n    ag_model_s = mean(s_jt_i, dims = 2);\n    elasmat = zeros((J, J));\n\n    for k in 1:J, j in 1:J\n        if (k != j)\n            elasmat[k, j] = (-1.0) .* p_old[k] ./ ag_model_s[j] * mean(alpha_i .* s_jt_i[j, :] .* s_jt_i[k, :])\n        elseif (k == j)\n            elasmat[k, j] = p_old[j] ./ ag_model_s[j] * mean(alpha_i .* s_jt_i[j, :] .* (1.0 .- s_jt_i[j, :]))\n        end\n    end\n\n    Derivative = - elasmat .* Sharevec' ./ p_old;\n    Delta = Derivative .* Ownership;\n    p_new = mc .+ (Delta \\ Sharevec)\n\n    return p_new\n    \nend\n\nf_update (generic function with 1 method)\n\n\n\nfunction f_eqprice(\n        datalist::datalist_struct,\n        p_ini::Vector{Float64},\n        Ownership::BitMatrix,\n        parameter::parameter_struct,\n        theta1::Vector{Float64},\n        theta2::Vector{Float64},\n        mc::Vector{Float64},\n        Xi::Vector{Float64}\n    )\n    \n    lambda = 1e-6;\n    p_old = p_ini;\n    distance = 10000;\n    \n    local p_new\n    \n    while (distance > lambda)\n        p_new = f_update(datalist, p_old, Ownership, parameter, theta1, theta2, mc, Xi);\n        distance = maximum(abs.(p_new - p_old));\n        p_old = p_new[:];\n        # print(distance, \"\\n\")\n    end\n    \n    return p_new\nend\n\nf_eqprice (generic function with 1 method)"
  },
  {
    "objectID": "demand_estimation_merger.html#section-5",
    "href": "demand_estimation_merger.html#section-5",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.7 6.5",
    "text": "4.7 6.5\n\np_ini = data_2016.price;\np_NippyoA = f_eqprice(\n    datalist_2016,\n    p_ini,\n    Ownership_NippyoA,\n    parameter,\n    beta_hat,\n    gmm_res.minimizer,\n    mc,\n    Xi[data.year .== 2016]\n);\n\np_ini = data_2016.price;\np_NippyoB = f_eqprice(\n    datalist_2016,\n    p_ini,\n    Ownership_NippyoB,\n    parameter,\n    beta_hat,\n    gmm_res.minimizer,\n    mc,\n    Xi[data.year .== 2016]\n);\n\n\nfunction f_mktshare_sim(\n        datalist::datalist_struct,\n        p::Vector{Float64},\n        parameter::parameter_struct,\n        theta1::Vector{Float64},\n        theta2::Vector{Float64},\n        Xi::Vector{Float64}\n    )\n    \n    X1_new = datalist.X1[:, :];\n    X2_new = reshape(p[:], (:, 1));\n    X1_new[:, 2] .= p;\n    \n    delta = (X1_new * theta1) .+ Xi;\n    datalist_new = datalist_struct(\n        X1_new, X2_new, datalist.Z, datalist.ShareVec, datalist.marketindex, \n        datalist.logitshare, datalist.draw_vec, datalist.mkt_denom_d\n        );\n    Sharevec = f_mktshare(\n        theta2, datalist_new, parameter, delta\n    );\n    \n    return(Sharevec)\n    \nend\n\nf_mktshare_sim (generic function with 1 method)"
  },
  {
    "objectID": "demand_estimation_merger.html#section-6",
    "href": "demand_estimation_merger.html#section-6",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.8 7",
    "text": "4.8 7"
  },
  {
    "objectID": "demand_estimation_merger.html#section-7",
    "href": "demand_estimation_merger.html#section-7",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.9 7.1",
    "text": "4.9 7.1\n\nmerger_sim_df = DataFrame(\n    Maker = data_2016.Maker, \n    Name = data_2016.Name, \n    Price_A = (p_NippyoA .- data_2016.price) ./ data_2016.price .* 100.0,\n    Share_A = (f_mktshare_sim(\n                datalist_2016,\n                p_NippyoA,\n                parameter,\n                beta_hat,\n                gmm_res.minimizer,\n                Xi[data.year .== 2016]\n            ) .- data_2016.share) ./ data_2016.share .* 100.0,\n    Price_B = (p_NippyoB .- data_2016.price) ./ data_2016.price .* 100.0,\n    Share_B = (f_mktshare_sim(\n                datalist_2016,\n                p_NippyoB,\n                parameter,\n                beta_hat,\n                gmm_res.minimizer,\n                Xi[data.year .== 2016]\n            ) .- data_2016.share) ./ data_2016.share .* 100.0,\n);\n\nmerger_sim_df[in([\"Nippyo\", \"BrandA\", \"BrandB\", \"BrandC\"]).(merger_sim_df.Maker), :]\n\n\n92×6 DataFrame67 rows omittedRowMakerNamePrice_AShare_APrice_BShare_BString15String31Float64Float64Float64Float641NippyoN-WGN0.528904-1.085730.200634-0.4122532NippyoN-ONE0.525627-1.093850.199727-0.4160643NippyoN-BOX0.514136-1.127080.196685-0.4317244Nippyoフィット0.510693-1.138940.19583-0.437345Nippyoバモス0.503396-1.168520.194146-0.4513916Nippyoシャトル0.486998-1.30150.192368-0.5154347Nippyoグレイス0.486127-1.324990.192777-0.5268828Nippyoフリード0.485831-1.381280.194403-0.554459Nippyoヴェゼル0.486195-1.39880.195076-0.56307110NippyoS6600.48711-1.425260.196225-0.57611711Nippyoステップワゴン0.497936-1.563930.204493-0.64505812NippyoCR-V0.5085-1.647770.211013-0.68709313Nippyoジェイド0.51258-1.675650.213399-0.701116⋮⋮⋮⋮⋮⋮⋮81BrandCエスクァイア0.005054230.04554170.002439670.018578882BrandCハイエースワゴン0.005052130.04593760.00244170.018769883BrandCハリアー0.00504530.04669280.002443930.019136284BrandCアルファード0.004954130.04993480.002418180.020737185BrandCヴェルファイア0.004954130.04993480.002418180.020737186BrandCカムリ0.004950220.05001520.00241660.020777487BrandCFJクルーザー0.004937050.05027250.002411210.020906688BrandCエスティマ0.004923340.05052160.002405440.02103289BrandCSAI0.00490770.05078660.002398710.021165790BrandCクラウン0.004506120.05487720.002204510.023269691BrandCランドクルーザー0.002841370.06245460.001321540.02734192BrandCセンチュリー-0.002464520.0523554-0.001591830.0219765"
  },
  {
    "objectID": "demand_estimation_merger.html#section-8",
    "href": "demand_estimation_merger.html#section-8",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.10 7.2",
    "text": "4.10 7.2\n\nPricevec = data_2016.price;\nSharevec = data_2016.share;\nOwnership = data_2016.MakerNippyoA .== permutedims(data_2016.MakerNippyoA);\nDerivative = - elasmat_t .* Sharevec' ./ Pricevec;\nDelta = Derivative .* Ownership;\nmc_NippyoA_pfix = Pricevec - (Delta \\ Sharevec);\nOwnership = data_2016.MakerNippyoB .== permutedims(data_2016.MakerNippyoB);\nDerivative = - elasmat_t .* Sharevec' ./ Pricevec;\nDelta = Derivative .* Ownership;\nmc_NippyoB_pfix = Pricevec - (Delta \\ Sharevec);\nmc_sim_df = DataFrame(\n    Maker = data_2016.Maker, \n    Name = data_2016.Name, \n    Nippyo_and_Brand_A = (mc_NippyoA_pfix .- mc) ./ mc .* 100.0,\n    Nippyo_and_Brand_B = (mc_NippyoB_pfix .- mc) ./ mc .* 100.0,\n);\n\nmc_sim_df[in([\"Nippyo\", \"BrandA\", \"BrandB\", \"BrandC\"]).(mc_sim_df.Maker), :]\n\n\n92×4 DataFrame67 rows omittedRowMakerNameNippyo_and_Brand_ANippyo_and_Brand_BString15String31Float64Float641NippyoN-WGN-0.913246-0.3472712NippyoN-ONE-0.895623-0.3411383NippyoN-BOX-0.83478-0.3200984Nippyoフィット-0.816657-0.3138825Nippyoバモス-0.777854-0.3006816Nippyoシャトル-0.672993-0.2664147Nippyoグレイス-0.661754-0.2629898Nippyoフリード-0.640238-0.2567439Nippyoヴェゼル-0.63483-0.25526510NippyoS660-0.627628-0.25338211Nippyoステップワゴン-0.604134-0.24868112NippyoCR-V-0.598054-0.24878413Nippyoジェイド-0.596997-0.249167⋮⋮⋮⋮⋮81BrandCエスクァイア0.00.082BrandCハイエースワゴン0.00.083BrandCハリアー0.00.084BrandCアルファード0.00.085BrandCヴェルファイア0.00.086BrandCカムリ0.00.087BrandCFJクルーザー0.00.088BrandCエスティマ0.00.089BrandCSAI0.00.090BrandCクラウン0.00.091BrandCランドクルーザー0.00.092BrandCセンチュリー0.00.0"
  },
  {
    "objectID": "demand_estimation_merger.html#section-9",
    "href": "demand_estimation_merger.html#section-9",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.11 7.4",
    "text": "4.11 7.4\n\nalpha_i = - (beta_hat[2] .+ gmm_res.minimizer[1] * draw_for_price)\ndata_2016.HH[1]\n\n56950757\n\n\n\nfunction f_CS(\n        datalist::datalist_struct,\n        p::Vector{Float64},\n        parameter::parameter_struct,\n        theta1::Vector{Float64},\n        theta2::Vector{Float64},\n        Xi::Vector{Float64},\n        HH::Int64\n    )\n    \n    X1_new = datalist.X1[:, :];\n    X2_new = reshape(p, (:, 1));\n    X1_new[:, 2] .= p;\n    \n    delta = (X1_new * theta1) .+ Xi;\n    \n    # elasticity\n    mu = X2_new * Diagonal(theta2) * datalist.draw_vec;\n    \n    V = delta .+ mu;\n    exp_V = exp.(V);\n    \n    numerator = log.(vec(sum(exp_V, dims = 1)) .+ 1.0);\n    \n    draw_for_price = datalist.draw_vec[1,:];\n    alpha_i = - (theta1[2] .+ theta2[1] .* draw_for_price);\n    \n    CS = mean(numerator ./ alpha_i) .* HH;\n\n    return CS\n    \nend\n\nCS_2016 = f_CS(\n    datalist_2016, \n    data_2016.price, \n    parameter, \n    beta_hat, \n    gmm_res.minimizer, \n    Xi[data.year .== 2016], \n    data_2016.HH[1]\n);\n\nCS_NippyoA = f_CS(\n    datalist_2016, \n    p_NippyoA, \n    parameter, \n    beta_hat, \n    gmm_res.minimizer, \n    Xi[data.year .== 2016], \n    data_2016.HH[1]\n);\n\nCS_NippyoB = f_CS(\n    datalist_2016, \n    p_NippyoB, \n    parameter, \n    beta_hat, \n    gmm_res.minimizer, \n    Xi[data.year .== 2016], \n    data_2016.HH[1]\n);\n\nCV_NippyoA = CS_NippyoA - CS_2016;\nCV_NippyoB = CS_NippyoB - CS_2016;\n\n\nf_profit = function(\n        Maker::AbstractVector, \n        price::Vector{Float64}, \n        mc::Vector{Float64}, \n        share::Vector{Float64}, \n        HH::Vector{Int64}\n    )\n    \n    dt = DataFrame(\n        Maker = Maker,\n        price = price,\n        mc = mc,\n        share = share,\n        HH = HH,\n        profit = (price - mc) .* share .* HH,\n        revenue = price.* share .* HH\n    )\n    \n    return(combine(groupby(dt, :Maker), [:profit, :revenue] .=> sum .=> [:profit, :revenue]))\nend\n\n#53 (generic function with 1 method)\n\n\n\npro_rev_2016 = f_profit(\n    data_2016.Maker,\n    data_2016.price,\n    mc,\n    data_2016.share,\n    data_2016.HH\n);\npro_rev_NippyoA = f_profit(\n    data_2016.Maker,\n    p_NippyoA,\n    mc,\n    f_mktshare_sim(\n                datalist_2016,\n                p_NippyoA,\n                parameter,\n                beta_hat,\n                gmm_res.minimizer,\n                Xi[data.year .== 2016]\n            ),\n    data_2016.HH\n);\npro_rev_NippyoB = f_profit(\n    data_2016.Maker,\n    p_NippyoB,\n    mc,\n    f_mktshare_sim(\n                datalist_2016,\n                p_NippyoB,\n                parameter,\n                beta_hat,\n                gmm_res.minimizer,\n                Xi[data.year .== 2016]\n            ),\n    data_2016.HH\n);\n\nTS_change_NippyoA = CV_NippyoA + sum(pro_rev_NippyoA.profit - pro_rev_2016.profit);\nTS_change_NippyoB = CV_NippyoB + sum(pro_rev_NippyoB.profit - pro_rev_2016.profit);\n\n\nDataFrame(\n    Measure = [\"Consumer surplus\", \"Total welfare\"],\n    Nippyo_and_Brand_A = [CV_NippyoA, TS_change_NippyoA],\n    Nippyo_and_Brand_B = [CV_NippyoB, TS_change_NippyoB],\n)\n\n\n2×3 DataFrameRowMeasureNippyo_and_Brand_ANippyo_and_Brand_BStringFloat64Float641Consumer surplus-11486.1-4617.722Total welfare-10275.0-4082.23\n\n\n\nresult_df = DataFrame(\n    Maker = pro_rev_2016.Maker,\n    Profits_NippyoA = pro_rev_NippyoA.profit - pro_rev_2016.profit,\n    Revenue_NippyoA = pro_rev_NippyoA.revenue - pro_rev_2016.revenue,\n    Profits_NippyoB = pro_rev_NippyoB.profit - pro_rev_2016.profit,\n    Revenue_NippyoB = pro_rev_NippyoB.revenue - pro_rev_2016.revenue,\n);\n\ntotal_df = combine(result_df, 2:5 .=> sum .=> names(result_df)[2:5]);\ntotal_df[!, :Maker] .= \"Total\"\nappend!(result_df, total_df)\n\n\n16×5 DataFrameRowMakerProfits_NippyoARevenue_NippyoAProfits_NippyoBRevenue_NippyoBString15Float64Float64Float64Float641Audi11.4239.36695.0077417.20942BMW37.8657123.31116.474452.91893Daihatsu108.936208.96844.234483.56854Fiat1.524184.142230.6396661.701645Lexas59.8269199.09825.930387.86Matsuda59.4818151.8324.849262.33227Mercedes52.2646174.88522.607277.13028Mitsubishi20.514150.37828.5334620.65989Suzuki114.119216.39446.314586.572410Volkswagen19.532758.88248.3463724.651111Volvo9.383332.00724.113613.884412Nippyo78.9811-9184.542.7737-3672.2813BrandA14.0327-10407.157.2739142.53314BrandB55.1002153.123-12.0312-4885.1415BrandC568.0911412.74240.429584.27716Total1211.07-16766.5535.496-7302.18"
  },
  {
    "objectID": "demand_estimation_merger.html#section-10",
    "href": "demand_estimation_merger.html#section-10",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.12 8",
    "text": "4.12 8\n\nfunction f_effect_cost_reduction(\n        cost_red::Float64,\n        cost_red_firm::AbstractVector,\n        Ownership::BitMatrix,\n        data::DataFrame,\n        mc::Vector{Float64},\n        datalist::datalist_struct,\n        parameter::parameter_struct,\n        theta1::Vector{Float64},\n        theta2::Vector{Float64},\n        HH::Vector{Int64},\n        p_pre::Vector{Float64},\n        pro_rev_pre::DataFrame,\n        CS_pre::Float64,\n        Xi::Vector{Float64}\n    )\n   \n    mc_new = mc[:];\n    mc_new[in(cost_red_firm).(data.Maker)] = mc_new[in(cost_red_firm).(data.Maker)] .* cost_red;\n    \n    p_post = f_eqprice(datalist, p_pre, Ownership, parameter, theta1, theta2, mc_new, Xi);\n    \n    CV = f_CS(datalist, p_post, parameter, theta1, theta2, Xi, HH[1]) - CS_pre;\n    \n    share_post = f_mktshare_sim(datalist, p_post, parameter, theta1, theta2, Xi);\n    pro_rev_post = f_profit(data.Maker, p_post, mc, share_post, HH);\n    \n    TS_change = CV + sum(pro_rev_post.profit .- pro_rev_pre.profit);\n    return TS_change\n    \nend\n\nf_effect_cost_reduction (generic function with 1 method)"
  },
  {
    "objectID": "demand_estimation_merger.html#section-11",
    "href": "demand_estimation_merger.html#section-11",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.13 8.2",
    "text": "4.13 8.2\n\ncost_red_firm = [\"Nippyo\", \"Brand_A\"];\ndistance = 100\nlambda = 1e-6;\nmax_cost_red = 1.0;\nmin_cost_red = 0.0;\n\niter = 1;\n\n\n@time while (distance > lambda) & (iter < 100)\n    \n    mid_cost_red = (max_cost_red + min_cost_red) / 2.0;\n    \n    mid_eval = f_effect_cost_reduction(\n        mid_cost_red,\n        cost_red_firm,\n        Ownership_NippyoA,\n        data_2016,\n        mc,\n        datalist_2016,\n        parameter,\n        beta_hat,\n        gmm_res.minimizer,\n        data_2016.HH,\n        p_NippyoA,\n        pro_rev_2016,\n        CS_2016,\n        Xi[data.year .== 2016]\n    );\n    \n    if mid_eval > 0\n        min_cost_red = mid_cost_red;\n    else\n        max_cost_red = mid_cost_red;\n    end\n    \n    distance = abs(mid_eval - 0);\n    print(distance, \"\\n\")\n#     print(min_cost_red, \",\", max_cost_red, \",\", mid_cost_red, \"\\n\")\n    iter += 1\n    \nend\ncost_red_NippyoA = (min_cost_red + min_cost_red) / 2.0;\n\n\n\n0.9856680991833855\n\n\n\nmc_NippyoA_TSfix = mc[:];\nmc_NippyoA_TSfix[in(cost_red_firm).(data_2016.Maker)] = (\n    mc_NippyoA_TSfix[in(cost_red_firm).(data_2016.Maker)] .* cost_red_NippyoA\n    );\n\n\np_NippyoA_TSfix = f_eqprice(\n    datalist_2016, \n    p_NippyoA, \n    Ownership_NippyoA, \n    parameter, \n    beta_hat, \n    gmm_res.minimizer, \n    mc_NippyoA_TSfix, \n    Xi[data.year .== 2016]\n    );\nshare_NippyoA_TSfix = f_mktshare_sim(\n    datalist_2016, \n    p_NippyoA_TSfix, \n    parameter, \n    beta_hat, \n    gmm_res.minimizer, \n    Xi[data.year .== 2016]\n    );"
  },
  {
    "objectID": "demand_estimation_merger.html#section-12",
    "href": "demand_estimation_merger.html#section-12",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.14 8.3",
    "text": "4.14 8.3\n\ncost_red_firm = [\"Nippyo\", \"Brand_B\"];\ndistance = 100\nlambda = 1e-6;\nmax_cost_red = 1.0;\nmin_cost_red = 0.0;\n\niter = 1;\n\n\n@time while (distance > lambda) & (iter < 100)\n    \n    mid_cost_red = (max_cost_red + min_cost_red) / 2.0;\n    \n    mid_eval = f_effect_cost_reduction(\n        mid_cost_red,\n        cost_red_firm,\n        Ownership_NippyoB,\n        data_2016,\n        mc,\n        datalist_2016,\n        parameter,\n        beta_hat,\n        gmm_res.minimizer,\n        data_2016.HH,\n        p_NippyoB,\n        pro_rev_2016,\n        CS_2016,\n        Xi[data.year .== 2016]\n    );\n    \n    if mid_eval > 0\n        min_cost_red = mid_cost_red;\n    else\n        max_cost_red = mid_cost_red;\n    end\n    \n    distance = abs(mid_eval - 0);\n    print(distance, \"\\n\")\n#     print(min_cost_red, \",\", max_cost_red, \",\", mid_cost_red, \"\\n\")\n    iter += 1\n    \nend\ncost_red_NippyoB = (min_cost_red + min_cost_red) / 2.0;\n\n\n\n0.9943264803296188\n\n\n\nmc_NippyoB_TSfix = mc[:];\nmc_NippyoB_TSfix[in(cost_red_firm).(data_2016.Maker)] = (\n    mc_NippyoB_TSfix[in(cost_red_firm).(data_2016.Maker)] .* cost_red_NippyoB\n    );\n\n\np_NippyoB_TSfix = f_eqprice(\n    datalist_2016, \n    p_NippyoB, \n    Ownership_NippyoB,\n    parameter, \n    beta_hat, \n    gmm_res.minimizer, \n    mc_NippyoB_TSfix, \n    Xi[data.year .== 2016]\n    );\nshare_NippyoB_TSfix = f_mktshare_sim(\n    datalist_2016, \n    p_NippyoB_TSfix, \n    parameter, \n    beta_hat, \n    gmm_res.minimizer, \n    Xi[data.year .== 2016]\n    );\n\n\n[1 - cost_red_NippyoA 1 - cost_red_NippyoB] .* 100\n\n1×2 Matrix{Float64}:\n 1.43319  0.567352"
  },
  {
    "objectID": "demand_estimation_merger.html#section-13",
    "href": "demand_estimation_merger.html#section-13",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.15 8.5",
    "text": "4.15 8.5\n\npro_rev_NippyoA_rc = f_profit(\n    data_2016.Maker,\n    p_NippyoA_TSfix,\n    mc_NippyoA_TSfix,\n    share_NippyoA_TSfix,\n    data_2016.HH\n);\npro_rev_NippyoB_rc = f_profit(\n    data_2016.Maker,\n    p_NippyoB_TSfix,\n    mc_NippyoB_TSfix,\n    share_NippyoB_TSfix,\n    data_2016.HH\n);\n\nresult2_df = DataFrame(\n    Maker = pro_rev_2016.Maker,\n    Profits_NippyoA = pro_rev_NippyoA_rc.profit - pro_rev_2016.profit,\n    Revenue_NippyoA = pro_rev_NippyoA_rc.revenue - pro_rev_2016.revenue,\n    Profits_NippyoB = pro_rev_NippyoB_rc.profit - pro_rev_2016.profit,\n    Revenue_NippyoB = pro_rev_NippyoB_rc.revenue - pro_rev_2016.revenue,\n    \n);\n\ntotal2_df = combine(result2_df, 2:5 .=> sum .=> names(result2_df)[2:5]);\ntotal2_df[!, :Maker] .= \"Total\";\nappend!(result2_df, total2_df)\n\n\n16×5 DataFrameRowMakerProfits_NippyoARevenue_NippyoAProfits_NippyoBRevenue_NippyoBString15Float64Float64Float64Float641Audi0.5782780.6376110.7093381.850862BMW1.163650.7433771.920484.303783Daihatsu-1.23683-3.209430.510195-0.6526914Fiat-0.000300335-0.03958730.0348650.04221455Lexas5.240577.23434.2922911.72826Matsuda-0.0455557-1.409671.231941.523147Mercedes4.448466.199753.6522910.24778Mitsubishi-0.0396423-0.4718210.3784460.4810879Suzuki-1.3003-3.301660.50768-0.63240510Volkswagen0.208558-0.2165590.6815911.2041211Volvo0.3803030.3549010.5439721.3312812Nippyo9976.9110995.03925.254286.0113BrandA-125.931-10955.23.062254.2864714BrandB0.323965-0.879382-34.1722-4980.6515BrandC4.27964-11.880816.772118.982516Total9864.9833.56953925.37-639.946"
  },
  {
    "objectID": "demand_estimation_merger.html#section-14",
    "href": "demand_estimation_merger.html#section-14",
    "title": "4  需要モデルの推定（応用編）",
    "section": "4.16 8.6",
    "text": "4.16 8.6\n\nprint(\"Change in profit by Brand A merger (%): \", (sum(pro_rev_NippyoA_rc.profit) .- sum(pro_rev_2016.profit)) ./ sum(pro_rev_2016.profit) .* 100.0, \"\\n\")\nprint(\"Change in revenue by Brand A merger (%): \", (sum(pro_rev_NippyoA_rc.revenue) .- sum(pro_rev_2016.revenue)) ./ sum(pro_rev_2016.revenue) .* 100.0, \"\\n\")\nprint(\"Change in profit by Brand B merger (%): \", (sum(pro_rev_NippyoB_rc.profit) .- sum(pro_rev_2016.profit)) ./ sum(pro_rev_2016.profit) .* 100.0, \"\\n\")\nprint(\"Change in revenue by Brand B merger (%): \", (sum(pro_rev_NippyoB_rc.revenue) .- sum(pro_rev_2016.revenue)) ./ sum(pro_rev_2016.revenue) .* 100.0, \"\\n\")\n\nChange in profit by Brand A merger (%): 0.36380146936382757\nChange in revenue by Brand A merger (%): 0.00044982645552334383\nChange in profit by Brand B merger (%): 0.14476020559469857\nChange in revenue by Brand B merger (%): -0.008575171067045903"
  },
  {
    "objectID": "entry_exit_basic.html#section",
    "href": "entry_exit_basic.html#section",
    "title": "5  参入ゲームの推定（基礎編）",
    "section": "5.1 4",
    "text": "5.1 4\n\nN_max = 6;\ndataset[dataset.NumMRI .> N_max, :NumMRI] .= N_max;\n\n\nfunction obj(\n        params,\n        dataset,\n        N_max\n    )\n\n    alpha1 = params[1];\n    alpha2 = -params[2:N_max];\n    alpha = vcat(alpha1, alpha2);\n    gamma = params[N_max + 1];\n    \n    NumMRI = dataset.NumMRI;\n    M = nrow(dataset);\n    pop = dataset.Pop .* ones((1, N_max));\n    \n    V = LowerTriangular(ones(N_max) .* alpha');\n        \n    VV = (V * ones(N_max, M))';\n    \n    F = gamma .* ones((M, N_max));\n    \n    profit = pop .* VV .- F;\n    \n    phi = cdf.(Normal(0, 1), profit);\n    \n    mat = hcat(ones(M) .- phi[:, 1], phi[:, 1:(N_max - 1)] .- phi[:, 2:N_max], phi[:, N_max]);\n    \n    ml = log.(reduce(.+, [(dataset.NumMRI .== i) .* mat[:, (i + 1)] for i = 0:N_max]));\n    \n    return - sum(ml) / M\n    \nend\n\nobj (generic function with 1 method)\n\n\n\nobj_for_Optim = TwiceDifferentiable(\n    x -> obj(x, dataset, N_max),\n    ones(N_max + 1);\n    autodiff = :forward\n);\n@time optim_res = optimize(\n    obj_for_Optim,\n    zeros(N_max + 1),\n    repeat([Inf], N_max + 1),\n    ones(N_max + 1),\n#     Optim.Options(show_trace = true)\n);\n\n  5.703398 seconds (15.37 M allocations: 2.026 GiB, 6.40% gc time, 95.32% compilation time)\n\n\n\nse = sqrt.(diag(inv(obj_for_Optim.H) ./ M));\nDataFrame(\n    estimates = optim_res.minimizer,\n    se = se\n)\n\n\n7×2 DataFrameRowestimatesseFloat64Float64154.62361.52851233.54331.361838.083460.48228444.236550.32650952.512150.26024161.632970.21518671.390410.046226"
  },
  {
    "objectID": "entry_exit_basic.html#section-1",
    "href": "entry_exit_basic.html#section-1",
    "title": "5  参入ゲームの推定（基礎編）",
    "section": "5.2 5",
    "text": "5.2 5\n\nalpha_est = optim_res.minimizer[1:N_max];\ngamma_est = optim_res.minimizer[N_max + 1];\n\nEntryThreshold = zeros(Int64, (N_max, 2));\n\ndeno = alpha_est[1];\nEntryThreshold[1,:] .= round(gamma_est / deno .* 1e+6);\nfor i = 2:N_max\n    deno = deno - alpha_est[i];\n    EntryThreshold[i, :] = round.([gamma_est / deno .* 1e+6, gamma_est / deno .* 1e+6 / i]);\nend\n\nEntryThreshold    \n\n6×2 Matrix{Int64}:\n  25454  25454\n  65958  32979\n 106981  35660\n 158717  39679\n 222532  44506\n 301269  50212"
  },
  {
    "objectID": "entry_exit_application.html#section",
    "href": "entry_exit_application.html#section",
    "title": "6  参入ゲームの推定（応用編）",
    "section": "6.1 4",
    "text": "6.1 4\n\ntable_mean = combine(\n    groupby(data_cleaned, :MRIOwnDum),\n    [:Kyukyu, :Kinou, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :NumBeds, :ZeroBedDum, :DaigakuDum] .=> x -> mean(skipmissing(x))\n);\ntable_sd = combine(\n    groupby(data_cleaned, :MRIOwnDum),\n    [:Kyukyu, :Kinou, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :NumBeds, :ZeroBedDum, :DaigakuDum] .=> x -> std(skipmissing(x))\n);\n\ntable_sumstat = DataFrame(table_mean[2, :]);\nappend!(table_sumstat, DataFrame(table_sd[2, :]));\nappend!(table_sumstat, DataFrame(table_mean[1, :]));\nappend!(table_sumstat, DataFrame(table_sd[1, :]));\n\nDataFrame([[names(table_sumstat)]; collect.(eachrow(table_sumstat))], [:column; Symbol.(axes(table_sumstat, 1))])\n\n\n10×5 DataFrameRowcolumn1234StringRealRealRealReal1MRIOwnDum11002Kyukyu_function0.7116930.4530420.3021310.4592233Kinou_function0.01994640.1398370.002549630.0504344Sien_function0.04763320.2130210.004006560.06317625Hyoka_function0.4334620.4956270.1693680.3751116DepNeurology_function0.3930810.4885070.1219910.3273067DepNeurosurgery_function0.5696430.49520.08211940.2745728NumBeds_function2.077281.94150.3918610.7105019ZeroBedDum_function0.0583160.2343750.4529340.49782510DaigakuDum_function0.04160480.1997140.004547940.067291\n\n\n\nfunction per_MRI_cal(df)\n\n    output = combine(df, nrow => :Total, :MRIOwnDum => sum => :MRIHos)\n    output[!, :PerMRI] = round.(output.MRIHos ./ output.Total .* 100.0, digits = 2)\n    \n    return Matrix(output)\n    \nend\n\nvcat(\n    per_MRI_cal(data_cleaned),\n    per_MRI_cal(dropmissing(data_cleaned, :Kyukyu)[dropmissing(data_cleaned, :Kyukyu).Kyukyu .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :Sien)[dropmissing(data_cleaned, :Sien).Sien .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :Hyoka)[dropmissing(data_cleaned, :Hyoka).Hyoka .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :DepNeurology)[dropmissing(data_cleaned, :DepNeurology).DepNeurology .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :DepNeurosurgery)[dropmissing(data_cleaned, :DepNeurosurgery).DepNeurosurgery .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :LogNumBeds)[dropmissing(data_cleaned, :LogNumBeds).LogNumBeds .>= log(1.2), :]),\n    per_MRI_cal(dropmissing(data_cleaned, :DaigakuDum)[dropmissing(data_cleaned, :DaigakuDum).DaigakuDum .== 1, :]),\n    per_MRI_cal(dropmissing(data_cleaned, :ZeroBedDum)[dropmissing(data_cleaned, :ZeroBedDum).ZeroBedDum .== 1, :]),\n)\n\n9×3 Matrix{Float64}:\n 8862.0  3365.0  37.97\n 4051.0  2392.0  59.05\n  182.0   160.0  87.91\n 2386.0  1456.0  61.02\n 1987.0  1318.0  66.33\n 2365.0  1914.0  80.93\n 2264.0  1932.0  85.34\n  165.0   140.0  84.85\n 2674.0   196.0   7.33"
  },
  {
    "objectID": "entry_exit_application.html#section-1",
    "href": "entry_exit_application.html#section-1",
    "title": "6  参入ゲームの推定（応用編）",
    "section": "6.2 5",
    "text": "6.2 5\n\ndata_processed_pre = dropmissing(data_cleaned[:, [\n            :CityCode, :Kyukyu, :Kinou, :Sien, :Hyoka,\n            :DepNeurology, :DepNeurosurgery, :LogNumBeds,\n            :ZeroBedDum, :DaigakuDum,\n            :Menseki, :LogPop, :LogIncome, :MRIOwnDum\n            ]]);\nfirst(data_processed_pre, 5)\n\n\n5×14 DataFrameRowCityCodeKyukyuKinouSienHyokaDepNeurologyDepNeurosurgeryLogNumBedsZeroBedDumDaigakuDumMensekiLogPopLogIncomeMRIOwnDumInt64Int64Int64Int64Int64Int64Int64Float64BoolBoolFloat64Float64Float64Int64111011000000.891998falsefalse0.4642-1.513271.104261211010000000.593327falsefalse0.4642-1.513271.104261311011000000.10436falsefalse0.4642-1.513271.104261411011000110.300105falsefalse0.4642-1.513271.104261511010000000.920283falsefalse0.4642-1.513271.104261\n\n\n\nfunction berry_process_data(df)\n    \n    data_processed = df[:, :];\n#     sort!(data_processed, :CityCode);\n    data_processed[!, :TieEntryOrder] = rand(Uniform(), nrow(df));\n    \n    transform!(\n        groupby(data_processed, :CityCode),\n        nrow => :NumPotenHos,\n        :MRIOwnDum => sum => :NumEntryObs\n    );\n    sort!(data_processed, [:CityCode, :LogNumBeds, :TieEntryOrder], rev = [false, true, true]);\n    transform!(groupby(data_processed, :CityCode), :NumPotenHos => (x -> 1:length(x)) => :EntryOrderId);\n    \n    return data_processed\n        \nend\n\nberry_process_data (generic function with 1 method)\n\n\n\nRandom.seed!(123)\ndata_processed = berry_process_data(data_processed_pre);\nfirst(data_processed, 5)\n\n\n5×18 DataFrameRowCityCodeKyukyuKinouSienHyokaDepNeurologyDepNeurosurgeryLogNumBedsZeroBedDumDaigakuDumMensekiLogPopLogIncomeMRIOwnDumTieEntryOrderNumPotenHosNumEntryObsEntryOrderIdInt64Int64Int64Int64Int64Int64Int64Float64BoolBoolFloat64Float64Float64Int64Float64Int64Int64Int64111011000112.19165falsetrue0.4642-1.513271.1042610.69220941171211011000112.0931falsefalse0.4642-1.513271.1042610.032096741172311010000101.61939falsefalse0.4642-1.513271.1042610.13655141173411010000101.59939falsefalse0.4642-1.513271.1042610.33415241174511010000001.14103falsefalse0.4642-1.513271.1042610.42732841175\n\n\n\nNumPotenHos_max = 4;\ndata_processed = data_processed[data_processed.EntryOrderId .<= NumPotenHos_max, :];\ntransform!(\n    groupby(data_processed, :CityCode),\n    :MRIOwnDum => sum => :NumEntryObs,\n    nrow => :NumPotenHos\n);\ndata_processed[!, :Const] = ones(nrow(data_processed));\ndata_processed[!, :LogEntryOrderId] = log.(data_processed[:, :EntryOrderId]);\nvcat(\n    per_MRI_cal(data_processed),\n    per_MRI_cal(dropmissing(data_processed, :Kyukyu)[dropmissing(data_processed, :Kyukyu).Kyukyu .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :Sien)[dropmissing(data_processed, :Sien).Sien .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :Hyoka)[dropmissing(data_processed, :Hyoka).Hyoka .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :DepNeurology)[dropmissing(data_processed, :DepNeurology).DepNeurology .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :DepNeurosurgery)[dropmissing(data_processed, :DepNeurosurgery).DepNeurosurgery .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :LogNumBeds)[dropmissing(data_processed, :LogNumBeds).LogNumBeds .>= log(1.2), :]),\n    per_MRI_cal(dropmissing(data_processed, :DaigakuDum)[dropmissing(data_processed, :DaigakuDum).DaigakuDum .== 1, :]),\n    per_MRI_cal(dropmissing(data_processed, :ZeroBedDum)[dropmissing(data_processed, :ZeroBedDum).ZeroBedDum .== 1, :]),\n)\n\n9×3 Matrix{Float64}:\n 4112.0  2246.0  54.62\n 2476.0  1745.0  70.48\n  151.0   141.0  93.38\n 1422.0  1097.0  77.14\n 1276.0  1014.0  79.47\n 1697.0  1472.0  86.74\n 1857.0  1628.0  87.67\n  125.0   115.0  92.0\n  646.0    41.0   6.35\n\n\n\nns = 100;\n\nuniqueCityCode = unique(data_processed.CityCode);\nM = length(uniqueCityCode);\nNumHos = nrow(data_processed);\nNumEntryObs = combine(groupby(data_processed, :CityCode), :NumEntryObs => mean).NumEntryObs_mean;\nNumPotenHos_vec = combine(first, groupby(data_processed, :CityCode)).NumPotenHos;\n\n\nu_m0 = (uniqueCityCode .== permutedims(data_processed.CityCode))' * rand(Normal(), (M, ns));\nu_mIm = rand(Normal(), (NumHos, ns));\n\n\nparam_init = [\n    -0.612340533,   -5.525423772,   -0.505275676,   \n    -0.32531026,    -1.04162392,    -0.991878025,   \n    -3.87040966,    -1.272714254,   2.684741676,    \n    0.040555764,    0.426448612,    -1.399627382,   \n    0.990975782,    0.958075433\n];\nfunction berry_obj(\n        param,\n        df::DataFrame,\n        u_m0::Matrix{Float64},\n        u_mIm::Matrix{Float64},\n        NumEntryObs::Vector{Float64},\n        uniqueCityCode::Vector{Int64},\n        NumPotenHos_vec::Vector{Int64}\n    )\n    \n    alpha = param[1:8];\n    beta = param[9:12];\n    delta = param[13];\n    rho = param[14];\n    \n    var_profit = Matrix(df[:, [:Const, :Menseki, :LogPop, :LogIncome]]) * beta .+ \n        rho .* u_m0;\n    fixed_cost = Matrix(df[:, [:Kyukyu, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :ZeroBedDum, :DaigakuDum]]) * alpha .-\n        (sqrt.(1.0 - rho^2) .* u_mIm);\n\n    prof_excl_comp = var_profit - fixed_cost;\n    \n    function each_entry_func(i)\n        entry_decision_df = hcat(df[:, [:CityCode]], DataFrame((prof_excl_comp .- delta .* log(i) .>= 0), :auto));\n        return (Matrix(combine(groupby(entry_decision_df, :CityCode), Not(:CityCode) .=> sum)[:, Not(:CityCode)]) .>= i) .* i\n    end\n    \n    each_entry_mat = max.(\n        each_entry_func(1),\n        each_entry_func(2),\n        each_entry_func(3),\n        each_entry_func(4)\n    );\n    n_exp = mean(each_entry_mat, dims = 2);\n    \n    diff = mean((NumEntryObs .- n_exp).^2);\n\n    return diff\n    \nend\n@time berry_obj(param_init, data_processed, u_m0, u_mIm, NumEntryObs, uniqueCityCode, NumPotenHos_vec)\n\n  0.095095 seconds (260.39 k allocations: 47.818 MiB, 11.21% gc time, 72.34% compilation time)\n\n\n0.3832595058339053\n\n\n\n# @benchmark berry_obj(param_init, data_processed, u_m0, u_mIm, NumEntryObs)\nfunction test_nlopt(x::Vector, grad::Vector)\n    if length(grad) != 0\n        ForwardDiff.gradient!(grad, x -> berry_obj(x, data_processed, u_m0, u_mIm, NumEntryObs, uniqueCityCode, NumPotenHos_vec), x)\n    end\n    return berry_obj(x, data_processed, u_m0, u_mIm, NumEntryObs, uniqueCityCode, NumPotenHos_vec)\nend\n\nparam_init = [\n    -0.612340533,   -5.525423772,   -0.505275676,   \n    -0.32531026,    -1.04162392,    -0.991878025,   \n    -3.87040966,    -1.272714254,   2.684741676,    \n    0.040555764,    0.426448612,    -1.399627382,   \n    0.990975782,    0.958075433\n];\n# param_init = vcat(repeat([0.0], 13), 0.95)\n\nopt = NLopt.Opt(:LN_NELDERMEAD, length(param_init))\nopt.lower_bounds = [repeat([-Inf], 13); -1.0]\nopt.upper_bounds = [repeat([Inf], 13); 1.0]\n# opt.xtol_rel = 1e-8\n\nopt.min_objective = test_nlopt\n@time (minf, minx, ret) = NLopt.optimize(opt, param_init)\n\n[param_init minx]\n\n 12.865786 seconds (31.97 M allocations: 29.278 GiB, 12.52% gc time, 0.56% compilation time)\n\n\n14×2 Matrix{Float64}:\n -0.612341    -0.623349\n -5.52542    -10.1976\n -0.505276    -0.541076\n -0.32531     -0.325195\n -1.04162     -1.15839\n -0.991878    -1.12713\n -3.87041     -3.56619\n -1.27271     -1.89788\n  2.68474      2.62547\n  0.0405558    0.0338055\n  0.426449     0.392436\n -1.39963     -1.44303\n  0.990976     1.06109\n  0.958075     0.973753"
  },
  {
    "objectID": "entry_exit_application.html#section-2",
    "href": "entry_exit_application.html#section-2",
    "title": "6  参入ゲームの推定（応用編）",
    "section": "6.3 6.2",
    "text": "6.3 6.2\n\nfunction entry_sim(df, delta, prof_excl_comp)\n    N = nrow(df);\n    n = ones(ns);\n    EntryCond = zeros(Int64, N, ns);\n    \n    for i = 1:N\n        net_prof = prof_excl_comp[i, :] .- delta * log.(n);\n        EntryCond[i, net_prof .> 0.0] .= 1;\n        n[net_prof .> 0.0] .+= 1;\n    end\n\n    return vec(mean(EntryCond, dims = 2))\nend\n\nberry_est = minx;\nalpha_est = berry_est[1:8];\nbeta_est = berry_est[9:12];\ndelta_est = berry_est[13];\nrho_est = berry_est[14];\n\nvar_profit = Matrix(data_processed[:, [:Const, :Menseki, :LogPop, :LogIncome]]) * beta_est .+ \n    rho_est .* u_m0;\nfixed_cost = Matrix(data_processed[:, [:Kyukyu, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :ZeroBedDum, :DaigakuDum]]) * alpha_est .-\n    (sqrt.(1.0 - rho_est^2) .* u_mIm);\n\nprof_excl_comp = var_profit - fixed_cost;\n\nEntryProb = map(\n    i -> entry_sim(data_processed[data_processed.CityCode .== i, :], delta_est, prof_excl_comp[data_processed.CityCode .== i, :]), \n    uniqueCityCode\n);\n\n\nEntryPred = reduce(vcat, EntryProb) .> 0.5;\ndata_predicted = copy(data_processed);\ndata_predicted[!, :EntryProb] = reduce(vcat, EntryProb);\ndata_predicted[!, :EntryPred] = EntryPred;\ndata_predicted_agg = combine(\n    groupby(data_predicted, :CityCode),\n    :MRIOwnDum => sum => :Actual,\n    :EntryPred => sum => :Predict\n);\n\ndata_predicted_agg = stack(data_predicted_agg, [:Actual, :Predict]);\ndata_predicted_sum = combine(groupby(data_predicted_agg, [:variable, :value]), nrow);\nsort!(data_predicted_sum, [:variable, :value]);\ngroupedbar(\n    data_predicted_sum.nrow, \n    group = data_predicted_sum.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)"
  },
  {
    "objectID": "entry_exit_application.html#section-3",
    "href": "entry_exit_application.html#section-3",
    "title": "6  参入ゲームの推定（応用編）",
    "section": "6.4 7",
    "text": "6.4 7\n\ndata_cf = copy(data_processed);\nsort!(data_cf, [:CityCode, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :TieEntryOrder], rev = [false, true, true, true, true]);\ntransform!(groupby(data_cf, :CityCode), :NumPotenHos => (x -> 1:length(x)) => :EntryOrderId);\nvar_profit_cf = Matrix(data_cf[:, [:Const, :Menseki, :LogPop, :LogIncome]]) * beta_est .+ \n    rho_est .* u_m0;\nfixed_cost_cf = Matrix(data_cf[:, [:Kyukyu, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :ZeroBedDum, :DaigakuDum]]) * alpha_est .-\n    (sqrt.(1.0 - rho_est^2) .* u_mIm);\n\nprof_excl_comp_cf = var_profit_cf - fixed_cost_cf;\nprof_excl_comp_cf[(data_cf.DepNeurology .== 1) .| (data_cf.DepNeurosurgery .== 1), :] .= 1e+5;\n\n\nEntryProb_cf = map(\n    i -> entry_sim(data_cf[data_cf.CityCode .== i, :], delta_est, prof_excl_comp_cf[data_cf.CityCode .== i, :]), \n    uniqueCityCode\n);\n\n\nEntryPred_cf = reduce(vcat, EntryProb_cf) .> 0.5;\ndata_predicted_cf = copy(data_processed);\ndata_predicted_cf[!, :EntryProb] = reduce(vcat, EntryProb_cf);\ndata_predicted_cf[!, :EntryPred] = EntryPred_cf;\ndata_predicted_cf_agg = combine(\n    groupby(data_predicted_cf, :CityCode),\n    :MRIOwnDum => sum => :Actual,\n    :EntryPred => sum => :CounterFactual\n);\n\ndata_predicted_cf_agg = stack(data_predicted_cf_agg, [:Actual, :CounterFactual]);\ndata_predicted_cf_sum = combine(groupby(data_predicted_cf_agg, [:variable, :value]), nrow);\nsort!(data_predicted_cf_sum, [:variable, :value]);\ngroupedbar(\n    data_predicted_cf_sum.nrow, \n    group = data_predicted_cf_sum.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncombine(groupby(data_predicted_cf_agg, :variable), :value => sum)\n\n\n2×2 DataFrameRowvariablevalue_sumStringInt641Actual22462CounterFactual2508"
  }
]