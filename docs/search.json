[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "【非公式】実証ビジネス・エコノミクス Juliaでの実装",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "single_agent_dynamic_basic.html#section",
    "href": "single_agent_dynamic_basic.html#section",
    "title": "7  シングルエージェント動学モデルの推定（基礎編）",
    "section": "7.1 4",
    "text": "7.1 4\n\ntransform!(\n    groupby(data_gen, :consumer_id), \n    [:price, :mileage, :action] .=> ShiftedArrays.lag\n    )\n\n\n120000×9 DataFrame119975 rows omittedRowstateactionperiodconsumer_idpricemileageprice_lagmileage_lagaction_lagInt64Int64Int64Int64Int64Int64Int64?Int64?Int64?160481125000missingmissingmissing2120482125005250000318048312500102500504140484121001025001005250485120002021001006280486123002020002007280487123002023002008270488122002023002009270489122002022002001034049012300252200200113104911200025230025012320492121002520002501334049312300252100250⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮119989630589100022005023004001199907105901000240055220050011999169059110002200552400550119992680592100021005522005501199936705931000200055210055011999468059410002100552000550119995750595100022006021005501199967305961000200060220060011999778059710002500602000600119998780598100025006025006001199997605991000230060250060012000078060010002500602300600\n\n\n\ncombine(\n    groupby(\n        data_gen |>\n            filter(:period => (x -> x != (num_period - num_period_obs + 1))),\n        [:mileage_lag, :mileage, :action_lag]\n    ),\n    nrow\n)\n\n\n122×4 DataFrame97 rows omittedRowmileage_lagmileageaction_lagnrowInt64?Int64Int64?Int64100057252001430502013405125010044165011475506858855119510024031051011115150485121001191310518⋮⋮⋮⋮⋮111909005311129095019011390100038114950162115955113116951015117959503731189510001561191000112512010051561211001011012210010001207\n\n\n\nnum_cond_obs_mileage = combine(\n    groupby(\n        transform(\n            data_gen |>\n                filter(:period => (x -> x != (num_period - num_period_obs + 1))),\n            [:mileage_lag, :mileage, :action_lag] =>\n            ByRow(\n                (mileage_lag, mileage, action_lag) ->\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 95) & (mileage_lag == mileage)) |\n                    ((action_lag == 1) & (mileage == 0))\n                    ) ? \"cond_obs_mileage1\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 5)) |\n                    ((action_lag == 1) & (mileage == 5))\n                    ) ? \"cond_obs_mileage2\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 10)) |\n                    ((action_lag == 1) & (mileage == 10))\n                    ) ? \"cond_obs_mileage3\" :\n                (\n                    ((action_lag == 0) & (mileage_lag == 95) & (mileage == 100))\n                    ) ? \"cond_obs_mileage4\" :\n                \"other\"\n            ) =>\n            :cond_obs_mileage\n            ),\n        [:cond_obs_mileage]\n        ),\n    nrow => :num_cond_obs\n) |> filter(:cond_obs_mileage => (x -> (x != \"other\")));\n\nnum_cond_obs_mileage = Dict(\n    k => v[1, \"num_cond_obs\"] \n    for ((k, ), v) in pairs(groupby(num_cond_obs_mileage, :cond_obs_mileage))\n    );\n\n\nkappa_est = zeros(2);\n\nkappa_est[1] = num_cond_obs_mileage[\"cond_obs_mileage2\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est[2] = num_cond_obs_mileage[\"cond_obs_mileage3\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est\n\n2-element Vector{Float64}:\n 0.2507060588583926\n 0.05038686722769128\n\n\n\nInfomat_mileage_est = zeros((2, 2));\n\nInfomat_mileage_est[1, 1] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] / kappa_est[1]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[1, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[2, 1] = Infomat_mileage_est[1, 2];\n\nInfomat_mileage_est[2, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage3\"] / kappa_est[2]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nkappa_se = sqrt.(diag(inv(Infomat_mileage_est)));\n\n\nDataFrame(kappa_est = kappa_est, kappa_se = kappa_se)\n\n\n2×2 DataFrameRowkappa_estkappa_seFloat64Float6410.2507060.001309820.05038690.000662066\n\n\n\nnum_cond_obs_price = combine(\n    groupby(\n        data_gen |>\n            filter(:period => (x -> x != (num_period - num_period_obs + 1))),\n        [:price_lag, :price]\n    ),\n    nrow => :num_cond_obs\n)\n\nnum_cond_obs_price = [\n    (\n        num_cond_obs_price |> \n            filter([:price_lag, :price] => ((price_lag, price) -> ((price_lag == p_lag) & (price == p))))\n    )[1, :num_cond_obs]\n    for p_lag in price_states, p in price_states\n]\n\nlambda_est_mat = num_cond_obs_price ./ sum(num_cond_obs_price, dims = 2)\n\n6×6 Matrix{Float64}:\n 0.0992722  0.101205   0.196952  0.198431  0.205254  0.198886\n 0.104459   0.10081    0.200023  0.201733  0.20447   0.188505\n 0.0998312  0.0979389  0.29888   0.205646  0.197719  0.0999847\n 0.101128   0.098588   0.197836  0.300843  0.200477  0.101128\n 0.0495297  0.0498236  0.1       0.100911  0.50047   0.199265\n 0.0486584  0.0509654  0.103705  0.100511  0.198112  0.498048\n\n\n\n# TODO\nlambda_se = zeros(num_price_states)\n\n6-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\nlambda_est = lambda_est_mat'[lambda_est_mat' .!= diag(lambda_est_mat)]\n\n30-element Vector{Float64}:\n 0.10120536729588356\n 0.1969524675915397\n 0.19843074823743462\n 0.2052535819877189\n 0.1988856038207869\n 0.10445888926901585\n 0.20002280761774432\n 0.20173337894856883\n 0.20447029307788803\n 0.1885049606568594\n 0.09983122794456094\n 0.09793893520175932\n 0.2056461924001432\n ⋮\n 0.20047744819179195\n 0.10112759041040227\n 0.04952968841857731\n 0.04982363315696649\n 0.1\n 0.10091122868900647\n 0.19926513815402705\n 0.04865843270868825\n 0.050965360590573536\n 0.1037052810902896\n 0.10051107325383304\n 0.19811186825667235"
  },
  {
    "objectID": "single_agent_dynamic_basic.html#section-1",
    "href": "single_agent_dynamic_basic.html#section-1",
    "title": "7  シングルエージェント動学モデルの推定（基礎編）",
    "section": "7.2 5",
    "text": "7.2 5\n\nfunction logLH_stat(\n    theta,\n    states_matrix::Matrix{Int},\n    data_gen::DataFrame\n)\n    U = flow_utility(theta, states_matrix);\n    prob_C_stat = exp.(U) ./ sum(exp.(U), dims = 2);\n    return sum(log.([prob_C_stat[x.state, x.action + 1] for x in eachrow(data_gen)]))\nend\n\nlogLH_stat (generic function with 1 method)\n\n\n\nobjFunc_for_Optim_stat = TwiceDifferentiable(\n    x -> - logLH_stat(x, states_matrix, data_gen),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time logit_stat_opt = optimize(\n    objFunc_for_Optim_stat,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     2.297333e+04     7.561388e+06\n\n\n * time: 0.008087158203125\n\n\n     1     1.468656e+04     3.971824e+06\n * time: 0.38202714920043945\n\n\n     2     1.407678e+04     3.143506e+06\n * time: 0.47128820419311523\n\n\n     3     1.355774e+04     1.214883e+06\n * time: 0.5628252029418945\n\n\n     4     1.350421e+04     2.487112e+04\n * time: 0.646827220916748\n\n\n     5     1.350416e+04     2.355812e+01\n * time: 0.7299971580505371\n\n\n     6     1.350416e+04     7.915900e-06\n * time: 0.839440107345581\n\n\n     7     1.350416e+04     3.805326e-09\n * time: 0.9212141036987305\n\n\n  2.674864 seconds (23.67 M allocations: 987.043 MiB, 6.26% gc time, 73.81% compilation time)\n\n\n * Status: success\n\n * Candidate solution\n    Final objective value:     1.350416e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 5.38e-14 ≰ 0.0e+00\n    |x - x'|/|x'|          = 1.26e-12 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.35e-16 ≰ 0.0e+00\n    |g(x)|                 = 3.81e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    7\n    f(x) calls:    17\n    ∇f(x) calls:   17\n    ∇²f(x) calls:  7\n\n\n\ntheta_est_stat = logit_stat_opt.minimizer;\n\nhessian_stat = ForwardDiff.hessian(\n    x -> - logLH_stat(x, states_matrix, data_gen),\n    logit_stat_opt.minimizer\n    );\n\ntheta_se_stat = sqrt.(diag(inv(hessian_stat)));\n\n\nDataFrame(theta_est_stat = theta_est_stat, theta_se_stat = theta_se_stat)\n\n\n2×2 DataFrameRowtheta_est_stattheta_se_statFloat64Float6410.04281710.00069209920.002376471.9178e-5\n\n\n\n7.2.1 5.2\n\nmileage_trans_mat_hat = zeros((num_mileage_states, num_mileage_states, num_choice));\ngen_mileage_trans!(kappa_est, num_mileage_states, mileage_trans_mat_hat);\n\nprice_trans_mat_hat = zeros(num_price_states, num_price_states);\ngen_price_trans!(lambda_est, num_price_states, price_trans_mat_hat);\n\ntrans_mat_hat = Array{Float64}(undef, num_states, num_states, num_choice);\nfor i in 1:num_choice\n    trans_mat_hat[:, :, i] = kron(mileage_trans_mat_hat[:, :, i], price_trans_mat_hat);\nend\n\n\nfunction logLH(\n    theta,\n    beta::Float64,\n    trans_mat::Array{Float64, 3},\n    states_matrix::Matrix{Int},\n    data_gen::DataFrame\n)\n\n    EV = contraction(theta, beta, trans_mat, states_matrix);\n    \n    U = flow_utility(theta, states_matrix);\n    V_CS = U + beta .* EV;\n\n    prob_C = exp.(V_CS) ./ sum(exp.(V_CS), dims = 2);\n\n    return sum(log.([prob_C[x.state, x.action + 1] for x in eachrow(data_gen)]))\nend\n\nlogLH (generic function with 1 method)\n\n\n\nobjFunc_for_Optim = TwiceDifferentiable(\n    x -> - logLH(x, beta, trans_mat_hat, states_matrix, data_gen),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time NFXP_opt = optimize(\n    objFunc_for_Optim,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     1.333725e+04     5.946862e+03\n * time: 0.00010704994201660156\n\n\n     1     1.333722e+04     3.170489e+00\n * time: 1.4230759143829346\n\n\n     2     1.333722e+04     4.639569e-07\n * time: 2.8048579692840576\n\n\n     3     1.333722e+04     3.080640e-08\n * time: 3.8495359420776367\n\n\n     4     1.333722e+04     4.640242e-08\n * time: 4.886625051498413\n\n\n     5     1.333722e+04     3.628702e-08\n * time: 5.93510103225708\n\n\n     6     1.333722e+04     6.017217e-09\n * time: 6.601719856262207\n\n\n  9.994022 seconds (25.64 M allocations: 22.485 GiB, 14.20% gc time, 25.74% compilation time)\n\n\n * Status: success (objective increased between iterations)\n\n * Candidate solution\n    Final objective value:     1.333722e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 9.54e-18 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.37e-15 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.36e-16 ≰ 0.0e+00\n    |g(x)|                 = 6.02e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   7  (vs limit Inf)\n    Iterations:    6\n    f(x) calls:    15\n    ∇f(x) calls:   15\n    ∇²f(x) calls:  6\n\n\n\ntheta_est = NFXP_opt.minimizer;\n\nhessian = ForwardDiff.hessian(\n    x -> - logLH(x, beta, trans_mat_hat, states_matrix, data_gen),\n    NFXP_opt.minimizer\n    );\n\ntheta_se = sqrt.(diag(inv(hessian)));\n\n\nDataFrame(theta_est = theta_est, theta_se = theta_se)\n\n\n2×2 DataFrameRowtheta_esttheta_seFloat64Float6410.004018268.88337e-520.003004553.67953e-5"
  }
]