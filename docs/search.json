[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "【非公式】実証ビジネス・エコノミクス Juliaでの実装",
    "section": "",
    "text": "このウェブサイトは『経済セミナー』で連載されていた『実証ビジネス・エコノミクス』で取り上げられた分析を、Juliaで再現したものです。 元の分析はRで実装されており、ここでコードを見ることができます。 本ウェブサイトは完全に筆者の趣味で作られたものであり、経済セミナー及び『実証ビジネス・エコノミクス』の公式のものではないことをご了承ください。 また、コードのリファクタリングがあまりされておらず、読みにくい箇所も多々あるかと思いますが、ご了承ください。\nコードに不備や疑問点などありましたら、GitHubのIssuesまでご連絡いただけますと幸いです。 いつか時間が取れたときにリファクタリングを行おうとも考えているので、お手伝いをしていただける方がいましたら連絡をいただければと思います。\n本サイトにおけるコードの運用につきましては十分にご確認をいただき、ご自身の責任とご判断によって行ってください。 これらの情報の運用結果により損害等が生じた場合でも、著者はいかなる責任を負うことはできませんので、ご留意ください。"
  },
  {
    "objectID": "single_agent_dynamic_basic.html#section",
    "href": "single_agent_dynamic_basic.html#section",
    "title": "7  基礎編",
    "section": "7.1 4",
    "text": "7.1 4\n\ntransform!(\n    groupby(data_gen, :consumer_id), \n    [:price, :mileage, :action] .=> ShiftedArrays.lag\n    )\n\n\n120000×9 DataFrame119975 rows omittedRowstateactionperiodconsumer_idpricemileageprice_lagmileage_lagaction_lagInt64Int64Int64Int64Int64Int64Int64?Int64?Int64?160481125000missingmissingmissing2120482125005250000318048312500102500504140484121001025001005250485120002021001006280486123002020002007280487123002023002008270488122002023002009270489122002022002001034049012300252200200113104911200025230025012320492121002520002501334049312300252100250⋮⋮⋮⋮⋮⋮⋮⋮⋮⋮119989630589100022005023004001199907105901000240055220050011999169059110002200552400550119992680592100021005522005501199936705931000200055210055011999468059410002100552000550119995750595100022006021005501199967305961000200060220060011999778059710002500602000600119998780598100025006025006001199997605991000230060250060012000078060010002500602300600\n\n\n\nnum_cond_obs_mileage = combine(\n    groupby(\n        transform(\n            data_gen |>\n                filter(:period => (x -> x != (num_period - num_period_obs + 1))),\n            [:mileage_lag, :mileage, :action_lag] =>\n            ByRow(\n                (mileage_lag, mileage, action_lag) ->\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 95) & (mileage_lag == mileage)) |\n                    ((action_lag == 1) & (mileage == 0))\n                    ) ? \"cond_obs_mileage1\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 5)) |\n                    ((action_lag == 1) & (mileage == 5))\n                    ) ? \"cond_obs_mileage2\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 10)) |\n                    ((action_lag == 1) & (mileage == 10))\n                    ) ? \"cond_obs_mileage3\" :\n                (\n                    ((action_lag == 0) & (mileage_lag == 95) & (mileage == 100))\n                    ) ? \"cond_obs_mileage4\" :\n                \"other\"\n            ) =>\n            :cond_obs_mileage\n            ),\n        [:cond_obs_mileage]\n        ),\n    nrow => :num_cond_obs\n) |> filter(:cond_obs_mileage => (x -> (x != \"other\")));\n\nnum_cond_obs_mileage = Dict(\n    k => v[1, \"num_cond_obs\"] \n    for ((k, ), v) in pairs(groupby(num_cond_obs_mileage, :cond_obs_mileage))\n    );\n\n\nkappa_est = zeros(2);\n\nkappa_est[1] = num_cond_obs_mileage[\"cond_obs_mileage2\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est[2] = num_cond_obs_mileage[\"cond_obs_mileage3\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est\n\n2-element Vector{Float64}:\n 0.2507060588583926\n 0.05038686722769128\n\n\n\nInfomat_mileage_est = zeros((2, 2));\n\nInfomat_mileage_est[1, 1] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] / kappa_est[1]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[1, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[2, 1] = Infomat_mileage_est[1, 2];\n\nInfomat_mileage_est[2, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage3\"] / kappa_est[2]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nkappa_se = sqrt.(diag(inv(Infomat_mileage_est)));\n\n\nDataFrame(kappa_est = kappa_est, kappa_se = kappa_se)\n\n\n2×2 DataFrameRowkappa_estkappa_seFloat64Float6410.2507060.001309820.05038690.000662066\n\n\n\nnum_cond_obs_price = combine(\n    groupby(\n        data_gen |>\n            filter(:period => (x -> x != (num_period - num_period_obs + 1))),\n        [:price_lag, :price]\n    ),\n    nrow => :num_cond_obs\n)\n\nnum_cond_obs_price = [\n    (\n        num_cond_obs_price |> \n            filter([:price_lag, :price] => ((price_lag, price) -> ((price_lag == p_lag) & (price == p))))\n    )[1, :num_cond_obs]\n    for p_lag in price_states, p in price_states\n]\n\nlambda_est_mat = num_cond_obs_price ./ sum(num_cond_obs_price, dims = 2)\n\n6×6 Matrix{Float64}:\n 0.0992722  0.101205   0.196952  0.198431  0.205254  0.198886\n 0.104459   0.10081    0.200023  0.201733  0.20447   0.188505\n 0.0998312  0.0979389  0.29888   0.205646  0.197719  0.0999847\n 0.101128   0.098588   0.197836  0.300843  0.200477  0.101128\n 0.0495297  0.0498236  0.1       0.100911  0.50047   0.199265\n 0.0486584  0.0509654  0.103705  0.100511  0.198112  0.498048\n\n\n\n# TODO\nlambda_se = zeros(num_price_states)\n\n6-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\nlambda_est = lambda_est_mat'[lambda_est_mat' .!= diag(lambda_est_mat)]\n\n30-element Vector{Float64}:\n 0.10120536729588356\n 0.1969524675915397\n 0.19843074823743462\n 0.2052535819877189\n 0.1988856038207869\n 0.10445888926901585\n 0.20002280761774432\n 0.20173337894856883\n 0.20447029307788803\n 0.1885049606568594\n 0.09983122794456094\n 0.09793893520175932\n 0.2056461924001432\n ⋮\n 0.20047744819179195\n 0.10112759041040227\n 0.04952968841857731\n 0.04982363315696649\n 0.1\n 0.10091122868900647\n 0.19926513815402705\n 0.04865843270868825\n 0.050965360590573536\n 0.1037052810902896\n 0.10051107325383304\n 0.19811186825667235"
  },
  {
    "objectID": "single_agent_dynamic_basic.html#section-1",
    "href": "single_agent_dynamic_basic.html#section-1",
    "title": "7  基礎編",
    "section": "7.2 5",
    "text": "7.2 5\n\nfunction logLH_stat(\n    theta,\n    states_matrix::Matrix{Int},\n    data_gen::DataFrame\n)\n    U = flow_utility(theta, states_matrix);\n    prob_C_stat = exp.(U) ./ sum(exp.(U), dims = 2);\n    return sum(log.([prob_C_stat[x.state, x.action + 1] for x in eachrow(data_gen)]))\nend\n\nlogLH_stat (generic function with 1 method)\n\n\n\nobjFunc_for_Optim_stat = TwiceDifferentiable(\n    x -> - logLH_stat(x, states_matrix, data_gen),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time logit_stat_opt = optimize(\n    objFunc_for_Optim_stat,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     2.297333e+04     7.561388e+06\n\n\n * time: 0.008973121643066406\n\n\n     1     1.468656e+04     3.971824e+06\n * time: 0.40418004989624023\n\n\n     2     1.407678e+04     3.143506e+06\n * time: 0.5036160945892334\n\n\n     3     1.355774e+04     1.214883e+06\n * time: 0.594635009765625\n\n\n     4     1.350421e+04     2.487112e+04\n * time: 0.6803030967712402\n\n\n     5     1.350416e+04     2.355812e+01\n * time: 0.7731211185455322\n\n\n     6     1.350416e+04     7.915900e-06\n * time: 0.8903989791870117\n\n\n     7     1.350416e+04     3.805326e-09\n * time: 0.9775240421295166\n\n\n  2.906696 seconds (23.66 M allocations: 986.520 MiB, 8.03% gc time, 73.82% compilation time)\n\n\n * Status: success\n\n * Candidate solution\n    Final objective value:     1.350416e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 5.38e-14 ≰ 0.0e+00\n    |x - x'|/|x'|          = 1.26e-12 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.35e-16 ≰ 0.0e+00\n    |g(x)|                 = 3.81e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    7\n    f(x) calls:    17\n    ∇f(x) calls:   17\n    ∇²f(x) calls:  7\n\n\n\ntheta_est_stat = logit_stat_opt.minimizer;\n\nhessian_stat = ForwardDiff.hessian(\n    x -> - logLH_stat(x, states_matrix, data_gen),\n    logit_stat_opt.minimizer\n    );\n\ntheta_se_stat = sqrt.(diag(inv(hessian_stat)));\n\n\nDataFrame(theta_est_stat = theta_est_stat, theta_se_stat = theta_se_stat)\n\n\n2×2 DataFrameRowtheta_est_stattheta_se_statFloat64Float6410.04281710.00069209920.002376471.9178e-5\n\n\n\n7.2.1 5.2\n\nmileage_trans_mat_hat = zeros((num_mileage_states, num_mileage_states, num_choice));\ngen_mileage_trans!(kappa_est, num_mileage_states, mileage_trans_mat_hat);\n\nprice_trans_mat_hat = zeros(num_price_states, num_price_states);\ngen_price_trans!(lambda_est, num_price_states, price_trans_mat_hat);\n\ntrans_mat_hat = Array{Float64}(undef, num_states, num_states, num_choice);\nfor i in 1:num_choice\n    trans_mat_hat[:, :, i] = kron(mileage_trans_mat_hat[:, :, i], price_trans_mat_hat);\nend\n\n\nfunction logLH(\n    theta,\n    beta::Float64,\n    trans_mat::Array{Float64, 3},\n    states_matrix::Matrix{Int},\n    data_gen::DataFrame\n)\n\n    EV = contraction(theta, beta, trans_mat, states_matrix);\n    \n    U = flow_utility(theta, states_matrix);\n    V_CS = U + beta .* EV;\n\n    prob_C = exp.(V_CS) ./ sum(exp.(V_CS), dims = 2);\n\n    return sum(log.([prob_C[x.state, x.action + 1] for x in eachrow(data_gen)]))\nend\n\nlogLH (generic function with 1 method)\n\n\n\nobjFunc_for_Optim = TwiceDifferentiable(\n    x -> - logLH(x, beta, trans_mat_hat, states_matrix, data_gen),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time NFXP_opt = optimize(\n    objFunc_for_Optim,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     1.333725e+04     5.946862e+03\n * time: 9.703636169433594e-5\n\n\n     1     1.333722e+04     3.170489e+00\n * time: 1.545522928237915\n\n\n     2     1.333722e+04     4.639569e-07\n * time: 3.088191032409668\n\n\n     3     1.333722e+04     3.080640e-08\n * time: 4.257920026779175\n\n\n     4     1.333722e+04     4.640242e-08\n * time: 5.4366021156311035\n\n\n     5     1.333722e+04     3.628702e-08\n * time: 6.69084906578064\n\n\n     6     1.333722e+04     6.017217e-09\n * time: 7.392544984817505\n\n\n 11.174516 seconds (25.64 M allocations: 22.486 GiB, 16.95% gc time, 25.35% compilation time)\n\n\n * Status: success (objective increased between iterations)\n\n * Candidate solution\n    Final objective value:     1.333722e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 9.54e-18 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.37e-15 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.36e-16 ≰ 0.0e+00\n    |g(x)|                 = 6.02e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   7  (vs limit Inf)\n    Iterations:    6\n    f(x) calls:    15\n    ∇f(x) calls:   15\n    ∇²f(x) calls:  6\n\n\n\ntheta_est = NFXP_opt.minimizer;\n\nhessian = ForwardDiff.hessian(\n    x -> - logLH(x, beta, trans_mat_hat, states_matrix, data_gen),\n    NFXP_opt.minimizer\n    );\n\ntheta_se = sqrt.(diag(inv(hessian)));\n\n\nDataFrame(theta_est = theta_est, theta_se = theta_se)\n\n\n2×2 DataFrameRowtheta_esttheta_seFloat64Float6410.004018268.88337e-520.003004553.67953e-5\n\n\n\nCSV.write(\"tmp/single_agent_dynamic_basic/data_gen.csv\", data_gen);"
  },
  {
    "objectID": "demand_estimation_1.html#data-cleaning",
    "href": "demand_estimation_1.html#data-cleaning",
    "title": "2  基礎編 1",
    "section": "2.1 Data cleaning",
    "text": "2.1 Data cleaning\n\ndata = data[!, [\n        :Maker, :Type, :Name, :Year, :Sales, \n        :Model, :price, :kata, :weight, :FuelEfficiency, \n        :HorsePower, :overall_length, :overall_width, :overall_height\n        ]]\nrename!(data, \"Year\" => \"year\")\ndata = leftjoin(data, dataHH, on = :year)\ndata = leftjoin(data, dataCPI, on = :year)\nfirst(data, 5)\n\n\n5×16 DataFrameRowMakerTypeNameyearSalesModelpricekataweightFuelEfficiencyHorsePoweroverall_lengthoverall_widthoverall_heightHHCPIString15String7String31Int64Int64StringFloat64String15Int64Float64?Int64?Int64Int64Int64Int64?Float64?1AudiForeignA1シリーズ201142061.4 TFSI289.0DBA-8XCAX119019.41223970174014405378343596.32AudiForeignA1シリーズ201245021.4 TFSI273.0DBA-8XCAX119019.41223970174014405417147596.23AudiForeignA1シリーズ201350711.4 TFSI273.0DBA-8XCAX119019.41223970174014405459474496.64AudiForeignA3シリーズ20064830アトラクション284.0GH-8PBSE136012.21024285176514305110200597.25AudiForeignA3シリーズ20073874アトラクション286.0GH-8PBSE136012.21024285176514305171304897.2\n\n\n\ndropmissing!(data, :FuelEfficiency);\n\n\ncpi2016 = dataCPI[dataCPI.year .== 2016, \"CPI\"][1]\ndata[!, :price] = data.price ./ (data.CPI / cpi2016) / 100;\n\n\ndata[!, :size] = (data[:, :overall_length] / 1000) .* (data[:, :overall_width] / 1000) .* (data[:, :overall_height] / 1000);\ndata[!, :hppw] = data[:, :HorsePower] ./ data[:, :weight];\n\nunique_name = unique(data[!, [:Name]])\nunique_name[!, :NameID] = rownumber.(eachrow(unique_name))\ndata = leftjoin(data, unique_name, on = :Name);\n\ndata = transform(\n    groupby(data, :year),\n    :Sales => sum => :inside_total\n);\ndata[!, :outside_total] = data.HH .- data.inside_total;\ndata[!, :share] = data.Sales ./ data.HH;\ndata[!, :share0] = data.outside_total ./ data.HH;\n\n\ntransform!(\n    groupby(data, [:year, :Maker]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_own, :FuelEfficiency_sum_own, :size_sum_own],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_own, :FuelEfficiency_sqr_sum_own, :size_sqr_sum_own],\n    nrow => \"group_n\"\n);\ntransform!(\n    groupby(data, [:year]),\n    [:hppw, :FuelEfficiency, :size] .=> sum .=> [:hppw_sum_mkt, :FuelEfficiency_sum_mkt, :size_sum_mkt],\n    [:hppw, :FuelEfficiency, :size] .=> (x -> sum(x.^2)) .=> [:hppw_sqr_sum_mkt, :FuelEfficiency_sqr_sum_mkt, :size_sqr_sum_mkt],\n    nrow => \"mkt_n\"\n);\n\n\ndata[!, :iv_BLP_own_hppw]             = data[:, :hppw_sum_own]           .- data[:, :hppw];\ndata[!, :iv_BLP_own_FuelEfficiency]   = data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency];\ndata[!, :iv_BLP_own_size]             = data[:, :size_sum_own]           .- data[:, :size];\ndata[!, :iv_BLP_other_hppw]           = data[:, :hppw_sum_mkt]           .- data[:, :hppw_sum_own];\ndata[!, :iv_BLP_other_FuelEfficiency] = data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own];\ndata[!, :iv_BLP_other_size]           = data[:, :size_sum_mkt]           .- data[:, :size_sum_own];\n\n\ndata[!, :iv_GH_own_hppw]             = (\n    (data[:, :group_n] .- 1) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_own] .- data[:, :hppw].^2) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_own] .- data[:, :hppw])\n);\ndata[!, :iv_GH_own_FuelEfficiency]   = (\n    (data[:, :group_n] .- 1) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_own] .- data[:, :FuelEfficiency].^2) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_own] .- data[:, :FuelEfficiency])\n);\ndata[!, :iv_GH_own_size]             = (\n    (data[:, :group_n] .- 1) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_own] .- data[:, :size].^2) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_own] .- data[:, :size])\n);\ndata[!, :iv_GH_other_hppw]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :hppw].^2 .+ \n    (data[:, :hppw_sqr_sum_mkt] .- data[:, :hppw_sqr_sum_own]) .- \n    2 .* data[:, :hppw] .* (data[:, :hppw_sum_mkt] .- data[:, :hppw_sum_own])\n);\ndata[!, :iv_GH_other_FuelEfficiency] = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :FuelEfficiency].^2 .+ \n    (data[:, :FuelEfficiency_sqr_sum_mkt] .- data[:, :FuelEfficiency_sqr_sum_own]) .- \n    2 .* data[:, :FuelEfficiency] .* (data[:, :FuelEfficiency_sum_mkt] .- data[:, :FuelEfficiency_sum_own])\n);\ndata[!, :iv_GH_other_size]           = (\n    (data[:, :mkt_n] .- data[:, :group_n]) .* data[:, :size].^2 .+ \n    (data[:, :size_sqr_sum_mkt] .- data[:, :size_sqr_sum_own]) .- \n    2 .* data[:, :size] .* (data[:, :size_sum_mkt] .- data[:, :size_sum_own])\n);\n\n\nNIPPYOautoIDvec = [\n    260, 4, 76, 104, 64, 54, 152, 153, 71, 197,\n    42, 45, 114, 208, 209, 77, 236, 58, 127, 187,\n    79, 175, 19, 117, 216, 112, 256, 119, 37, 158\n];\n\n\ndata_NIPPYO = data[in(NIPPYOautoIDvec).(data[:, :NameID]), [:Sales, :price, :hppw, :FuelEfficiency, :size]];\ndata_NIPPYO[!, :log_sales] = log.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log_price] = log.(data_NIPPYO[:, :price]);\ndata_NIPPYO[!, :log10_sales] = log10.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log10_price] = log10.(data_NIPPYO[:, :price]);\n\n\nols_intro = reg(\n    data_NIPPYO, \n    @formula(log_sales ~ log_price + hppw + FuelEfficiency + size),\n    Vcov.robust()\n)\n\n                                 FixedEffectModel                                 \n==================================================================================\nNumber of obs:                       196  Converged:                          true\ndof (model):                           4  dof (residuals):                     190\nR²:                                0.217  R² adjusted:                       0.201\nF-statistic:                     19.1148  P-value:                           0.000\n==================================================================================\n                  Estimate  Std. Error    t-stat  Pr(>|t|)    Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────────────────\nlog_price       -1.24828     0.309545   -4.03262    <1e-04   -1.85886    -0.63769\nhppw            -4.19685     3.97622    -1.05549    0.2925  -12.0401      3.64635\nFuelEfficiency   0.0886034   0.0283887   3.12108    0.0021    0.0326059   0.144601\nsize             0.306896    0.0588927   5.2111     <1e-06    0.190728    0.423063\n(Intercept)      5.76211     1.06127     5.42946    <1e-06    3.66873     7.85549\n==================================================================================\n\n\n\nfit_line = predict(\n    lm(@formula(log10_sales ~ log10_price), data_NIPPYO)\n    );\nplot(\n    data_NIPPYO.price, \n    data_NIPPYO.Sales, \n    seriestype = :scatter, \n    legend = false,\n    xscale = :log10,\n    yscale = :log10,\n    xlabel = \"Price\",\n    ylabel = \"Sales\",\n    xticks = ([1, 3, 10], [1, 3, 10]),\n)\nplot!(\n    data_NIPPYO.price, \n    10 .^ fit_line,\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndescribe(data[:, [:Sales, :price, :FuelEfficiency, :size, :hppw]])\n\n\n5×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64RealFloat64RealInt64DataType1Sales24586.4108544.03176750Int642price2.530470.7051762.0504212.62650Float643FuelEfficiency16.15975.515.440.80Float644size11.50535.90911.472519.15480Float645hppw0.09913120.0450.09268290.3238640Float64\n\n\n\ndata[!, :logit_share] = log.(data[:, :share]) .- log.(data[:, :share0]);\n\n\nols_res = reg(data, @formula(logit_share ~ price + hppw + FuelEfficiency + size), Vcov.robust());\niv_BLP_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust()\n);\niv_GH_res = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust(),\n    save = true\n);\n\n\nregtable(ols_res, iv_BLP_res, iv_GH_res)\n\n\n--------------------------------------------------------------\n                                       logit_share            \n                          ------------------------------------\n                                 (1)          (2)          (3)\n--------------------------------------------------------------\n(Intercept)               -12.255***   -12.323***   -12.973***\n                             (0.365)      (0.382)      (0.393)\nprice                      -0.255***    -0.283***    -0.552***\n                             (0.026)      (0.067)      (0.080)\nhppw                          -0.654        0.213      8.426**\n                             (1.284)      (2.298)      (2.638)\nFuelEfficiency              0.130***     0.130***     0.127***\n                             (0.010)      (0.010)      (0.010)\nsize                        0.182***     0.187***     0.236***\n                             (0.019)      (0.021)      (0.022)\n--------------------------------------------------------------\nEstimator                        OLS           IV           IV\n--------------------------------------------------------------\nN                              1,823        1,823        1,823\nR2                             0.222        0.222        0.180\nWithin-R2                                                     \nFirst-stage F statistic                    33.926       51.583\n--------------------------------------------------------------\n\n\n\n\niv1st_BLP_res = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n        ),\n    Vcov.robust()\n);\niv1st_GH_res = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n        ),\n    Vcov.robust()\n);\n\n\nregtable(iv1st_BLP_res, iv1st_GH_res)\n\n\n---------------------------------------------------\n                                      price        \n                              ---------------------\n                                    (1)         (2)\n---------------------------------------------------\n(Intercept)                      -3.159    -1.325**\n                                (1.685)     (0.423)\nhppw                          28.749***   23.508***\n                                (0.993)     (1.547)\nFuelEfficiency                   -0.011   -0.072***\n                                (0.008)     (0.014)\nsize                           0.202***    0.189***\n                                (0.015)     (0.020)\niv_BLP_own_hppw                 -0.728*            \n                                (0.336)            \niv_BLP_own_FuelEfficiency     -0.007***            \n                                (0.001)            \niv_BLP_own_size                0.013***            \n                                (0.004)            \niv_BLP_other_hppw                 0.165            \n                                (0.255)            \niv_BLP_other_FuelEfficiency     0.001**            \n                                (0.000)            \niv_BLP_other_size                -0.002            \n                                (0.003)            \niv_GH_own_hppw                            -1.889***\n                                            (0.439)\niv_GH_own_FuelEfficiency                      0.000\n                                            (0.000)\niv_GH_own_size                            -0.001***\n                                            (0.000)\niv_GH_other_hppw                           0.423***\n                                            (0.096)\niv_GH_other_FuelEfficiency                 0.000***\n                                            (0.000)\niv_GH_other_size                           0.000***\n                                            (0.000)\n---------------------------------------------------\nN                                 1,823       1,823\nR2                                0.616       0.623\n---------------------------------------------------\n\n\n\n\ndata[!, :own_elas_ols]   = ols_res.coef[ols_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\ndata[!, :own_elas_ivblp] = iv_BLP_res.coef[iv_BLP_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\ndata[!, :own_elas_ivgh]  = iv_GH_res.coef[iv_GH_res.coefnames .== \"price\"] .* data[:, :price] .* (1 .- data[:, :share]);\n\n\ndescribe(data[:, r\"^own_elas\"])\n\n\n3×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64Float64Float64Float64Int64DataType1own_elas_ols-0.645328-3.22104-0.522324-0.1798920Float642own_elas_ivblp-0.717085-3.5792-0.580404-0.1998950Float643own_elas_ivgh-1.3967-6.9714-1.13048-0.3893460Float64\n\n\n\ndt_application = data[:, [:NameID, :year, :Sales, :price, :FuelEfficiency, :size, :hppw, :HH, :share]];\ndt_application[!, :xi_fit] = iv_GH_res.residuals;\n\n\nNameID_target = 197\ndt_application[(dt_application.year .== 2016) .& (dt_application.NameID .== NameID_target), :]\n\n\n1×10 DataFrameRowNameIDyearSalespriceFuelEfficiencysizehppwHHsharexi_fitInt64?Int64Int64Float64Float64Float64Float64Int64?Float64Float64?11972016370693.19811.617.09440.0947917569507570.0006508961.16401\n\n\n\nfunction f_share(\n        price_cand,\n        year, \n        NameID_target,\n        dt,\n        est_res\n    )\n    \n    dt = dt[dt.year .== year, :]\n    dt[!, :temp_price] = dt[:, :price]\n    dt[(dt[:, :NameID] .== NameID_target), :temp_price] .= price_cand\n    dt[!, :delta] = (\n        est_res.coef[est_res.coefnames .== \"(Intercept)\"] .+\n        est_res.coef[est_res.coefnames .== \"hppw\"] .* dt[:, :hppw] .+\n        est_res.coef[est_res.coefnames .== \"FuelEfficiency\"] .* dt[:, :FuelEfficiency] .+\n        est_res.coef[est_res.coefnames .== \"size\"] .* dt[:, :size] .+\n        est_res.coef[est_res.coefnames .== \"price\"] .* dt[:, :temp_price] .+\n        dt[:, :xi_fit]\n    )\n    dt[!, :denom] .= 1 .+ sum(exp.(dt[:, :delta]))\n    dt[!, :pred_sales] = exp.(dt[:, :delta]) ./ dt[:, :denom] .* dt[:, :HH]\n    dt = dt[dt.NameID .== NameID_target, :]\n    \n    return dt.pred_sales[1]\n    \nend\n\nf_share (generic function with 1 method)\n\n\n\npricevec = range(0.3, 5, step = 0.05);\nquantvec = f_share.(pricevec, 2016, NameID_target, Ref(dt_application), Ref(iv_GH_res));\n\n\nplot(quantvec, pricevec, xticks = [50000, 100000, 150000], legend = false)\nxlabel!(\"Sales\")\nylabel!(\"Price (million JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(pricevec, pricevec .* quantvec / 1000, legend = false)\nxlabel!(\"Price (million JPY)\")\nylabel!(\"Revenue (billion JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nopt_res = optimize(\n    x -> - f_share(x[1], 2016, NameID_target, dt_application, iv_GH_res) * x[1],\n    [1.0]\n);\n\n@printf(\"Revenue-maximizing price: %.3f \\n\", opt_res.minimizer[1])\n@printf(\"Max revenue : %.3f\", -opt_res.minimum)\n\nRevenue-maximizing price: 1.814 \nMax revenue : 144273.836"
  },
  {
    "objectID": "single_agent_dynamic_application.html#section",
    "href": "single_agent_dynamic_application.html#section",
    "title": "8  応用編",
    "section": "8.1 4",
    "text": "8.1 4\n\ntheta_true = [0.004, 0.003];\n\nbeta = 0.99;\n\nEuler_const = Float64(MathConstants.eulergamma);\n\nnum_choice = 2;\n\n\nnum_cond_obs_mileage = combine(\n    groupby(\n        transform(\n            data_gen |>\n                filter(:period => (x -> x != minimum(data_gen.period))),\n            [:mileage_lag, :mileage, :action_lag] =>\n            ByRow(\n                (mileage_lag, mileage, action_lag) ->\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 95) & (mileage_lag == mileage)) |\n                    ((action_lag == 1) & (mileage == 0))\n                    ) ? \"cond_obs_mileage1\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 5)) |\n                    ((action_lag == 1) & (mileage == 5))\n                    ) ? \"cond_obs_mileage2\" :\n                (\n                    ((action_lag == 0) & (5 <= mileage_lag <= 90) & (mileage_lag == mileage - 10)) |\n                    ((action_lag == 1) & (mileage == 10))\n                    ) ? \"cond_obs_mileage3\" :\n                (\n                    ((action_lag == 0) & (mileage_lag == 95) & (mileage == 100))\n                    ) ? \"cond_obs_mileage4\" :\n                \"other\"\n            ) =>\n            :cond_obs_mileage\n            ),\n        [:cond_obs_mileage]\n        ),\n    nrow => :num_cond_obs\n) |> filter(:cond_obs_mileage => (x -> (x != \"other\")));\n\nnum_cond_obs_mileage = Dict(\n    k => v[1, \"num_cond_obs\"] \n    for ((k, ), v) in pairs(groupby(num_cond_obs_mileage, :cond_obs_mileage))\n    );\n\n\nkappa_est = zeros(2);\n\nkappa_est[1] = num_cond_obs_mileage[\"cond_obs_mileage2\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est[2] = num_cond_obs_mileage[\"cond_obs_mileage3\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] + num_cond_obs_mileage[\"cond_obs_mileage3\"]) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est\n\n2-element Vector{Float64}:\n 0.2507060588583926\n 0.05038686722769128\n\n\n\nInfomat_mileage_est = zeros((2, 2));\n\nInfomat_mileage_est[1, 1] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] / kappa_est[1]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[1, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nInfomat_mileage_est[2, 1] = Infomat_mileage_est[1, 2];\n\nInfomat_mileage_est[2, 2] = (\n    (num_cond_obs_mileage[\"cond_obs_mileage1\"] / (1 - kappa_est[1] - kappa_est[2])^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage3\"] / kappa_est[2]^2) +\n    (num_cond_obs_mileage[\"cond_obs_mileage4\"] / (kappa_est[1] + kappa_est[2])^2)\n);\n\nkappa_se = sqrt.(diag(inv(Infomat_mileage_est)));\n\n\nDataFrame(kappa_est = kappa_est, kappa_se = kappa_se)\n\n\n2×2 DataFrameRowkappa_estkappa_seFloat64Float6410.2507060.001309820.05038690.000662066\n\n\n\nnum_cond_obs_price = combine(\n    groupby(\n        data_gen |>\n            filter(:period => (x -> x != (minimum(data_gen.period)))),\n        [:price_lag, :price]\n    ),\n    nrow => :num_cond_obs\n)\n\nnum_cond_obs_price = [\n    (\n        num_cond_obs_price |> \n            filter([:price_lag, :price] => ((price_lag, price) -> ((price_lag == p_lag) & (price == p))))\n    )[1, :num_cond_obs]\n    for p_lag in price_states, p in price_states\n]\n\nlambda_est_mat = num_cond_obs_price ./ sum(num_cond_obs_price, dims = 2)\n\n6×6 Matrix{Float64}:\n 0.0992722  0.101205   0.196952  0.198431  0.205254  0.198886\n 0.104459   0.10081    0.200023  0.201733  0.20447   0.188505\n 0.0998312  0.0979389  0.29888   0.205646  0.197719  0.0999847\n 0.101128   0.098588   0.197836  0.300843  0.200477  0.101128\n 0.0495297  0.0498236  0.1       0.100911  0.50047   0.199265\n 0.0486584  0.0509654  0.103705  0.100511  0.198112  0.498048\n\n\n\n# TODO\nlambda_se = zeros(num_price_states)\n\n6-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\nlambda_est = lambda_est_mat'[lambda_est_mat' .!= diag(lambda_est_mat)]\n\n30-element Vector{Float64}:\n 0.10120536729588356\n 0.1969524675915397\n 0.19843074823743462\n 0.2052535819877189\n 0.1988856038207869\n 0.10445888926901585\n 0.20002280761774432\n 0.20173337894856883\n 0.20447029307788803\n 0.1885049606568594\n 0.09983122794456094\n 0.09793893520175932\n 0.2056461924001432\n ⋮\n 0.20047744819179195\n 0.10112759041040227\n 0.04952968841857731\n 0.04982363315696649\n 0.1\n 0.10091122868900647\n 0.19926513815402705\n 0.04865843270868825\n 0.050965360590573536\n 0.1037052810902896\n 0.10051107325383304\n 0.19811186825667235\n\n\n\nfunction gen_mileage_trans!(\n    kappa::Vector{Float64},\n    num_mileage_states::Int,\n    mileage_trans_mat::Array{Float64, 3}\n    )\n    kappa_1 = kappa[1];\n    kappa_2 = kappa[2];\n\n    mileage_trans_mat[:, :, :] .= 0;\n    for i in 1:num_mileage_states, j in 1:num_mileage_states\n        if (i == j)\n            mileage_trans_mat[i, j, 1] = 1 - kappa_1 - kappa_2;\n        elseif (i == j - 1)\n            mileage_trans_mat[i, j, 1] = kappa_1;\n        elseif (i == j - 2)\n            mileage_trans_mat[i, j, 1] = kappa_2;\n        end\n    end\n    mileage_trans_mat[num_mileage_states - 1, num_mileage_states, 1] = kappa_1 + kappa_2;\n    mileage_trans_mat[num_mileage_states, num_mileage_states, 1] = 1;\n\n    mileage_trans_mat[:, :, 2] = repeat(mileage_trans_mat[1, :, 1]', num_mileage_states);\nend\n\ngen_mileage_trans! (generic function with 1 method)\n\n\n\nfunction gen_price_trans!(\n    lambda::Vector{Float64},\n    num_price_states::Int,\n    price_trans_mat::Array{Float64, 2}\n    )\n\n    price_trans_mat[:, :] .= 0;\n\n    price_trans_mat[1, 2:end] = lambda[1:(num_price_states - 1)];\n    price_trans_mat[1, 1] = 1 - sum(price_trans_mat[1, :]);\n\n    for i in 2:(num_price_states - 1)\n        price_trans_mat[i, 1:(i - 1)] = lambda[\n            ((i - 1) * (num_price_states - 1) + 1):((i - 1) * (num_price_states - 1) + (i - 1))\n            ];\n        price_trans_mat[i, (i + 1):end] = lambda[\n            ((i - 1) * (num_price_states - 1) + i):(i * (num_price_states - 1))\n            ];\n        price_trans_mat[i, i] = 1 - sum(price_trans_mat[i, :]);\n    end\n\n    price_trans_mat[num_price_states, 1:(end - 1)] = lambda[((num_price_states - 1) * (num_price_states - 1) + 1):end];\n    price_trans_mat[num_price_states, num_price_states] = 1 - sum(price_trans_mat[num_price_states, :]);\n\nend\n\ngen_price_trans! (generic function with 1 method)\n\n\n\nmileage_trans_mat_hat = zeros((num_mileage_states, num_mileage_states, num_choice));\ngen_mileage_trans!(kappa_est, num_mileage_states, mileage_trans_mat_hat);\n\nprice_trans_mat_hat = zeros(num_price_states, num_price_states);\ngen_price_trans!(lambda_est, num_price_states, price_trans_mat_hat);\n\ntrans_mat_hat = Array{Float64}(undef, num_states, num_states, num_choice);\nfor i in 1:num_choice\n    trans_mat_hat[:, :, i] = kron(mileage_trans_mat_hat[:, :, i], price_trans_mat_hat);\nend\n\n\nlogit_model = glm(\n  @formula(action ~ price + price^2 + mileage + mileage^2), data_gen, Binomial(), LogitLink()\n  );\n\n\nCCP_1st = hcat(\n  1 .- predict(logit_model, DataFrame(price = states_matrix[:, 1], mileage = states_matrix[:, 2])), \n  predict(logit_model, DataFrame(price = states_matrix[:, 1], mileage = states_matrix[:, 2]))\n  );\nCCP_1st = convert(Matrix{Float64}, CCP_1st);\n\n\nfunction flow_utility(\n    theta,\n    states_matrix::Matrix{Int}\n    )\n\n    theta_c = theta[1];\n    theta_p = theta[2];\n\n    return hcat(\n        - theta_c .* states_matrix[:, 2],\n        - theta_p .* states_matrix[:, 1]\n    );\nend\n\nflow_utility (generic function with 1 method)\n\n\n\nfunction policy_operator_mat_inv(\n  theta,\n  CCP::Matrix{Float64},\n  beta::Float64,\n  trans_mat::Array{Float64, 3},\n  states_matrix::Matrix{Int};\n  num_states::Int = num_states,\n  Euler_const::Float64 = Euler_const\n)\n\n  U = flow_utility(theta, states_matrix);\n\n  psi = Euler_const .- log.(CCP);\n\n  V = (\n    diagm(ones(num_states)) - \n    beta .* (CCP[:, 1] .* trans_mat[:, :, 1] + CCP[:, 2] .* trans_mat[:, :, 2])\n  ) \\ sum(CCP .* (U + psi), dims = 2);\n\n  CV = U + beta .* hcat(trans_mat[:, :, 1] * V, trans_mat[:, :, 2] * V);\n\n  CCP = exp.(CV) ./ sum(exp.(CV), dims = 2)\n\n  return CCP\n\nend\n\npolicy_operator_mat_inv (generic function with 1 method)\n\n\n\nfunction likelihood_fun(\n  theta,\n  CCP::Matrix{Float64},\n  data_gen::DataFrame,\n  beta::Float64,\n  trans_mat::Array{Float64, 3},\n  states_matrix::Matrix{Int},\n  policy_operator\n  )\n\n  CCP = policy_operator(theta, CCP, beta, trans_mat, states_matrix);\n\n  return sum(log.([CCP[x.state, x.action + 1] for x in eachrow(data_gen)]))\n\nend\n\nlikelihood_fun (generic function with 1 method)\n\n\n\nobjFunc_for_Optim_mat_inv = TwiceDifferentiable(\n    x -> - likelihood_fun(x, CCP_1st, data_gen, beta, trans_mat_hat, states_matrix, policy_operator_mat_inv),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time mat_inv_opt_mat_inv = optimize(\n    objFunc_for_Optim_mat_inv,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     1.333730e+04     2.473233e+03\n\n\n * time: 0.009277105331420898\n\n\n     1     1.333729e+04     2.826419e+00\n * time: 0.5131659507751465\n\n\n     2     1.333729e+04     3.092846e-07\n * time: 0.7227869033813477\n\n\n     3     1.333729e+04     1.539229e-08\n * time: 0.9409499168395996\n\n\n     4     1.333729e+04     2.988236e-08\n * time: 1.1034069061279297\n\n\n     5     1.333729e+04     5.530183e-09\n * time: 1.1971309185028076\n\n\n  6.140650 seconds (27.69 M allocations: 1.396 GiB, 7.14% gc time, 83.19% compilation time)\n\n\n * Status: success (objective increased between iterations)\n\n * Candidate solution\n    Final objective value:     1.333729e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 9.19e-17 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.29e-14 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.36e-16 ≰ 0.0e+00\n    |g(x)|                 = 5.53e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    5\n    f(x) calls:    13\n    ∇f(x) calls:   13\n    ∇²f(x) calls:  5\n\n\n\ntheta_mat_inv = mat_inv_opt_mat_inv.minimizer;\n\nhessian_mat_inv = ForwardDiff.hessian(\n    x -> - likelihood_fun(x, CCP_1st, data_gen, beta, trans_mat_hat, states_matrix, policy_operator_mat_inv),\n    mat_inv_opt_mat_inv.minimizer\n    );\n\ntheta_se_mat_inv = sqrt.(diag(inv(hessian_mat_inv)));\n\n\nDataFrame(theta_mat_inv = theta_mat_inv, theta_se_mat_inv = theta_se_mat_inv)\n\n\n2×2 DataFrameRowtheta_mat_invtheta_se_mat_invFloat64Float6410.004009058.65791e-520.003002453.63389e-5\n\n\n\n8.1.1 4.2.2\n\nfunction policy_operator_finite_dep(\n  theta,\n  CCP::Matrix{Float64},\n  beta::Float64,\n  trans_mat::Array{Float64, 3},\n  states_matrix::Matrix{Int}\n  )\n\n  U = flow_utility(theta, states_matrix);\n\n  CV_dif = (\n    U[:, 2] - U[:, 1] +\n    beta .* (trans_mat[:, :, 2] * (- log.(CCP[:, 2])) -  trans_mat[:, :, 1] * (- log.(CCP[:, 2])))\n  );\n\n  prob_buy = exp.(CV_dif) ./ (1 .+ exp.(CV_dif));\n\n  CCP = hcat(1 .- prob_buy, prob_buy)\n\n  return CCP\n\nend\n\npolicy_operator_finite_dep (generic function with 1 method)\n\n\n\nobjFunc_for_Optim_finite_dep = TwiceDifferentiable(\n    x -> - likelihood_fun(x, CCP_1st, data_gen, beta, trans_mat_hat, states_matrix, policy_operator_finite_dep),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time finite_dep_opt = optimize(\n    objFunc_for_Optim_finite_dep,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     1.337865e+04     1.116086e+06\n * time: 0.0001480579376220703\n\n\n     1     1.333718e+04     6.418191e+03\n * time: 0.14699792861938477\n\n\n     2     1.333718e+04     1.047973e+00\n * time: 0.2868630886077881\n\n\n     3     1.333718e+04     1.616718e-08\n * time: 0.468533992767334\n\n\n     4     1.333718e+04     2.244633e-09\n * time: 0.6000580787658691\n\n\n  1.955567 seconds (14.75 M allocations: 613.699 MiB, 8.66% gc time, 62.44% compilation time)\n\n\n * Status: success (objective increased between iterations)\n\n * Candidate solution\n    Final objective value:     1.333718e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 9.02e-17 ≰ 0.0e+00\n    |x - x'|/|x'|          = 2.16e-14 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.82e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 1.36e-16 ≰ 0.0e+00\n    |g(x)|                 = 2.24e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    4\n    f(x) calls:    11\n    ∇f(x) calls:   11\n    ∇²f(x) calls:  4\n\n\n\ntheta_finite_dep = finite_dep_opt.minimizer;\n\nhessian_finite_dep = ForwardDiff.hessian(\n    x -> - likelihood_fun(x, CCP_1st, data_gen, beta, trans_mat_hat, states_matrix, policy_operator_finite_dep),\n    finite_dep_opt.minimizer\n    );\n\ntheta_se_finite_dep = sqrt.(diag(inv(hessian_finite_dep)));\n\n\nDataFrame(theta_finite_dep = theta_finite_dep, theta_se_finite_dep = theta_se_finite_dep)\n\n\n2×2 DataFrameRowtheta_finite_deptheta_se_finite_depFloat64Float6410.004168910.00080262620.002931792.2015e-5\n\n\n\n\n8.1.2 5.2\n\nfunction contraction(\n    theta,\n    beta::Float64,\n    trans_mat::Array{Float64, 3},\n    states_matrix::Matrix{Int};\n    num_states::Int = num_states,\n    num_choice::Int = num_choice,\n    Euler_const::Float64 = Euler_const\n    )\n\n    U = flow_utility(theta, states_matrix);\n    V_old = zeros(num_states);\n\n    diff = 1000;\n    tol_level = 1e-10;\n\n    while (diff > tol_level)\n        V_new = log.(sum(\n          exp.(U + beta .* hcat(trans_mat[:, :, 1] * V_old, trans_mat[:, :, 2] * V_old)),\n          dims = 2)) .+ Euler_const;\n\n        diff = sum(abs.(V_new - V_old));\n\n        V_old = V_new[:];\n    end\n\n    return V_old\n\nend\n\ncontraction (generic function with 1 method)\n\n\n\nfunction policy_operator_nfxp(\n    theta,\n    beta::Float64,\n    trans_mat::Array{Float64, 3},\n    states_matrix::Matrix{Int};\n    num_states::Int = num_states\n)\n\n    U = flow_utility(theta, states_matrix);\n\n    V = contraction(theta, beta, trans_mat, states_matrix; num_states = num_states);\n    \n    CV = U + beta .* hcat(trans_mat[:, :, 1] * V, trans_mat[:, :, 2] * V);\n\n    CCP = exp.(CV) ./ sum(exp.(CV), dims = 2);\n\n    return CCP\nend\n\npolicy_operator_nfxp (generic function with 1 method)\n\n\n\nfunction likelihood_fun_nfxp(\n    theta,\n    data_gen::DataFrame,\n    beta::Float64,\n    trans_mat::Array{Float64, 3},\n    states_matrix::Matrix{Int}\n)\n  CCP = policy_operator_nfxp(theta, beta, trans_mat, states_matrix);\n\n  return sum(log.([CCP[x.state, x.action + 1] for x in eachrow(data_gen)]))\n\nend\n\nlikelihood_fun_nfxp (generic function with 1 method)\n\n\n\nobjFunc_for_Optim_nfxp = TwiceDifferentiable(\n    x -> - likelihood_fun_nfxp(x, data_gen, beta, trans_mat_hat, states_matrix),\n    theta_true;\n    autodiff = :forward\n    );\n\n@time nfxp_opt = optimize(\n    objFunc_for_Optim_nfxp,\n    theta_true,\n    Optim.Options(show_trace = true)\n)\n\nIter     Function value   Gradient norm \n     0     1.333725e+04     5.946862e+03\n * time: 0.00010085105895996094\n\n\n     1     1.333722e+04     3.170489e+00\n * time: 1.297194004058838\n\n\n     2     1.333722e+04     4.777394e-07\n * time: 2.5601818561553955\n\n\n     3     1.333722e+04     9.062569e-08\n * time: 3.819387912750244\n\n\n     4     1.333722e+04     1.493299e-08\n * time: 4.798436880111694\n\n\n     5     1.333722e+04     1.400440e-08\n * time: 5.785632848739624\n\n\n     6     1.333722e+04     2.461275e-08\n * time: 7.379520893096924\n\n\n     7     1.333722e+04     3.908644e-08\n * time: 8.378872871398926\n\n\n     8     1.333722e+04     3.261812e-08\n * time: 9.381367921829224\n\n\n     9     1.333722e+04     9.928044e-09\n * time: 9.97671103477478\n\n\n 12.718526 seconds (32.00 M allocations: 27.938 GiB, 20.24% gc time, 15.42% compilation time)\n\n\n * Status: success (objective increased between iterations)\n\n * Candidate solution\n    Final objective value:     1.333722e+04\n\n * Found with\n    Algorithm:     Newton's Method\n\n * Convergence measures\n    |x - x'|               = 2.26e-17 ≰ 0.0e+00\n    |x - x'|/|x'|          = 5.61e-15 ≰ 0.0e+00\n    |f(x) - f(x')|         = 3.64e-12 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 2.73e-16 ≰ 0.0e+00\n    |g(x)|                 = 9.93e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   10  (vs limit Inf)\n    Iterations:    9\n    f(x) calls:    24\n    ∇f(x) calls:   24\n    ∇²f(x) calls:  9\n\n\n\ntheta_nfxp = nfxp_opt.minimizer;\n\nhessian_nfxp = ForwardDiff.hessian(\n    x -> - likelihood_fun_nfxp(x, data_gen, beta, trans_mat_hat, states_matrix),\n    nfxp_opt.minimizer\n    );\n\ntheta_se_nfxp = sqrt.(diag(inv(hessian_nfxp)));\n\n\nDataFrame(theta_nfxp = theta_nfxp, theta_se_nfxp = theta_se_nfxp)\n\n\n2×2 DataFrameRowtheta_nfxptheta_se_nfxpFloat64Float6410.004018268.88337e-520.003004553.67953e-5\n\n\n\nDataFrame(\n  Algorithm = [\"Matrix Inversion\", \"Finite Dependency\", \"NFXP\"],\n  theta_c = [theta_mat_inv[1], theta_finite_dep[1], theta_nfxp[1]],\n  theta_se_c = [theta_se_mat_inv[1], theta_se_finite_dep[1], theta_se_nfxp[1]],\n  theta_p = [theta_mat_inv[2], theta_finite_dep[2], theta_nfxp[2]],\n  theta_se_p = [theta_se_mat_inv[2], theta_se_finite_dep[2], theta_se_nfxp[2]],\n)\n\n\n3×5 DataFrameRowAlgorithmtheta_ctheta_se_ctheta_ptheta_se_pStringFloat64Float64Float64Float641Matrix Inversion0.004009058.65791e-50.003002453.63389e-52Finite Dependency0.004168910.0008026260.002931792.2015e-53NFXP0.004018268.88337e-50.003004553.67953e-5"
  },
  {
    "objectID": "single_agent_dynamic_application.html#section-3",
    "href": "single_agent_dynamic_application.html#section-3",
    "title": "8  応用編",
    "section": "8.2 6",
    "text": "8.2 6\n\nCCP_dict = Dict();\n\n\nprob_buy_baseline = policy_operator_nfxp(theta_nfxp, beta, trans_mat_hat, states_matrix);\nCCP_dict[\"Baseline\"] = prob_buy_baseline;\n\n\nresult_df_edlp = combine(\n  groupby(\n    data_gen,\n    [:state, :price]\n  ),\n  nrow => :num_obs\n);\nsort!(result_df_edlp, :state)\nresult_df_edlp[!, :prob_buy_baseline] = prob_buy_baseline[:, 2];\n\nresult_df_edlp = combine(\n  groupby(\n    result_df_edlp,\n    [:price]\n  ),\n  [:prob_buy_baseline, :num_obs] =>\n  (\n    (prob_buy_baseline, num_obs) ->\n    sum(prob_buy_baseline .* num_obs) / sum(num_obs)\n  ) =>\n  :prob_buy\n);\n\n\nG_fixed_price = zeros((num_mileage_states, num_mileage_states, num_choice));\ngen_mileage_trans!(kappa_est, num_mileage_states, G_fixed_price);\n\n\nfor fixed_price in price_states\n  states_matrix_fixed_price = (\n    states_matrix[states_matrix[:, 1] .== fixed_price, :]\n  )\n\n  CCP_dict[\"edlp_\" * string(fixed_price)] = policy_operator_nfxp(\n    theta_nfxp,\n    beta,\n    G_fixed_price,\n    states_matrix_fixed_price;\n    num_states = num_mileage_states\n  )\nend\n\n\nresult_df_edlp2000 = combine(\n  groupby(\n    data_gen,\n    [:mileage]\n  ),\n  nrow => :num_obs\n);\nsort!(result_df_edlp2000, :mileage)\nresult_df_edlp2000[!, :prob_buy_baseline] = CCP_dict[\"edlp_2000\"][:, 2];\n\nprob_buy_edlp2000 = (\n  sum(result_df_edlp2000.prob_buy_baseline .* result_df_edlp2000.num_obs) / \n  sum(result_df_edlp2000.num_obs)\n);\n\n\nbar(\n    price_states,\n    result_df_edlp.prob_buy,\n    bar_width = 50, legend=false\n)\nhline!([prob_buy_edlp2000])"
  },
  {
    "objectID": "single_agent_dynamic_application.html#section-4",
    "href": "single_agent_dynamic_application.html#section-4",
    "title": "8  応用編",
    "section": "8.3 7",
    "text": "8.3 7\n\nstates_matrix_discount = states_matrix[:, :];\nstates_matrix_discount[:, 1] .-= 100;\n\nCCP_dict[\"Permanent\"] = policy_operator_nfxp(theta_nfxp, beta, trans_mat_hat, states_matrix_discount);\n\n\nU_discount = flow_utility(theta_nfxp, states_matrix_discount);\n\nV = contraction(theta_nfxp, beta, trans_mat_hat, states_matrix);\n\nCV_temporary = U_discount + beta .* hcat(trans_mat_hat[:, :, 1] * V, trans_mat_hat[:, :, 2] * V);\n\nCCP_dict[\"Temporary\"] = exp.(CV_temporary) ./ sum(exp.(CV_temporary), dims = 2);\n\n\nplot_cf_df = DataFrame(price = states_matrix[:, 1], mileage = states_matrix[:, 2]);\nplot_cf_df[!, :ProbBaseline] = CCP_dict[\"Baseline\"][:, 2];\nplot_cf_df[!, :ProbPermanent] = CCP_dict[\"Permanent\"][:, 2];\nplot_cf_df[!, :ProbTemporary] = CCP_dict[\"Temporary\"][:, 2];\n\nfilter!(:price => (x -> x == 2200), plot_cf_df);\n\nplot(plot_cf_df.mileage, plot_cf_df.ProbBaseline, label = \"Baseline\")\nplot!(plot_cf_df.mileage, plot_cf_df.ProbPermanent, label = \"Permanent\")\nplot!(plot_cf_df.mileage, plot_cf_df.ProbTemporary, label = \"Temporary\")\nxlabel!(\"Mileage\")\nylabel!(\"Purchase probability\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.3.1 7.2\n\nconsumer_dist_obs = combine(\n  groupby(\n    data_gen,\n    [:state]\n  ),\n  nrow\n)\ntransform!(\n    consumer_dist_obs,\n    :nrow => (x -> x / sum(x)) => :consumer_dist_obs\n);\n\n\ndiscount_scenario_vec = [\"Baseline\", \"Permanent\", \"Temporary\"];\n\nG_CCP_dict = Dict();\n\nfor scenario in discount_scenario_vec\n  G_CCP_dict[scenario] = (\n    CCP_dict[scenario][:, 1] .* trans_mat_hat[:, :, 1] +\n    CCP_dict[scenario][:, 2] .* trans_mat_hat[:, :, 2]\n  );\nend\n\nfor scenario in [\"edlp_\" * string(price) for price in price_states]\n  G_CCP_dict[scenario] = (\n    CCP_dict[scenario][:, 1] .* G_fixed_price[:, :, 1] +\n    CCP_dict[scenario][:, 2] .* G_fixed_price[:, :, 2]\n  );\nend\n\n\nnum_consumer_sim = 1000;\nnum_period_sim = 20;\n\n\ndiscount_sim_dict = Dict();\n\nfor scenario in discount_scenario_vec\n\n  consumer_dist_sim = zeros((num_period_sim, num_states));\n  consumer_dist_sim[1, :] .= consumer_dist_obs.consumer_dist_obs;\n\n  prob_buy_sim_vec = zeros(num_period_sim);\n  demand_vec = zeros(num_period_sim);\n  revenue_vec = zeros(num_period_sim);\n\n  for t in 1:num_period_sim\n\n    if ((t == 1) & (scenario == \"Temporary\"))\n\n      if (t != num_period_sim)\n        consumer_dist_sim[t + 1, :] = consumer_dist_sim[t, :]' * G_CCP_dict[scenario];\n      end\n\n      prob_buy_sim_vec[t] = consumer_dist_sim[t, :]' * CCP_dict[scenario][:, 2];\n      demand_vec[t] = prob_buy_sim_vec[t]' * num_consumer_sim;\n      revenue_vec[t] = sum(\n        (states_matrix[:, 1] .- 100) .* consumer_dist_sim[t, :] .* CCP_dict[scenario][:, 2] .* num_consumer_sim\n      )\n\n    else\n\n      if (scenario == \"Temporary\")\n        scenario_current = \"Baseline\";\n        discount = 0;\n      elseif (scenario == \"Permanent\")\n        scenario_current = scenario;\n        discount = 100;\n      else\n        scenario_current = scenario;\n        discount = 0;\n      end\n\n      if (t != num_period_sim)\n        consumer_dist_sim[t + 1, :] = consumer_dist_sim[t, :]' * G_CCP_dict[scenario_current];\n      end\n\n      prob_buy_sim_vec[t] = consumer_dist_sim[t, :]' * CCP_dict[scenario_current][:, 2];\n      demand_vec[t] = prob_buy_sim_vec[t]' * num_consumer_sim;\n      revenue_vec[t] = sum(\n        (states_matrix[:, 1] .- discount) .* consumer_dist_sim[t, :] .* \n        CCP_dict[scenario_current][:, 2] .* num_consumer_sim\n      )\n\n    end\n\n  end\n\n  discount_sim_dict[scenario] = DataFrame(\n    prob_buy_sim = prob_buy_sim_vec,\n    demand = demand_vec,\n    revenue = revenue_vec,\n  )\n\nend\n\n\nplot(\n  1:num_period_sim,\n  (\n    discount_sim_dict[\"Permanent\"].prob_buy_sim - \n    discount_sim_dict[\"Baseline\"].prob_buy_sim\n  ),\n  label = \"Permanent Change\"\n)\nplot!(\n  1:num_period_sim,\n  (\n    discount_sim_dict[\"Temporary\"].prob_buy_sim - \n    discount_sim_dict[\"Baseline\"].prob_buy_sim\n  ),\n  label = \"Temporary Change\"\n)\n\nxlabel!(\"Period\")\nylabel!(\"Change in purchase probability\")"
  },
  {
    "objectID": "single_agent_dynamic_application.html#section-6",
    "href": "single_agent_dynamic_application.html#section-6",
    "title": "8  応用編",
    "section": "8.4 8",
    "text": "8.4 8\n\nconsumer_dist_obs_edlp = combine(\n  groupby(\n    data_gen,\n    [:mileage]\n  ),\n  nrow\n)\ntransform!(\n    consumer_dist_obs_edlp,\n    :nrow => (x -> x / sum(x)) => :consumer_dist_obs\n);\n\n\nedlp_sim_dict = Dict();\n\nfor fixed_price in price_states\n\n  scenario_edlp = \"edlp_\" * string(fixed_price);\n\n  consumer_dist_sim = zeros((num_period_sim, num_mileage_states));\n  consumer_dist_sim[1, :] .= consumer_dist_obs_edlp.consumer_dist_obs;\n\n  prob_buy_sim_vec = zeros(num_period_sim);\n  demand_vec = zeros(num_period_sim);\n  revenue_vec = zeros(num_period_sim);\n\n  for t in 1:num_period_sim\n\n    if (t != num_period_sim)\n      consumer_dist_sim[t + 1, :] = consumer_dist_sim[t, :]' * G_CCP_dict[scenario_edlp];\n    end\n\n    prob_buy_sim_vec[t] = consumer_dist_sim[t, :]' * CCP_dict[scenario_edlp][:, 2];\n    demand_vec[t] = prob_buy_sim_vec[t]' * num_consumer_sim;\n    revenue_vec[t] = sum(\n      fixed_price .* consumer_dist_sim[t, :] .* \n      CCP_dict[scenario_edlp][:, 2] .* num_consumer_sim\n    )\n\n  end\n\n  edlp_sim_dict[fixed_price] = DataFrame(\n    prob_buy_sim = prob_buy_sim_vec,\n    demand = demand_vec,\n    revenue = revenue_vec,\n  )\n\nend\n\n\nplot()\nfor fixed_price in price_states\n  plot!(1:num_period_sim, edlp_sim_dict[fixed_price].demand, label = \"Price: \" * string(fixed_price))\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor fixed_price in price_states\n  plot!(1:num_period_sim, edlp_sim_dict[fixed_price].revenue, label = \"Price: \" * string(fixed_price))\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    discount_sim_dict[scenario].demand,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    discount_sim_dict[scenario].demand |> cumsum,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand (cumulative sum)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    (discount_sim_dict[scenario].demand |> cumsum) ./ (discount_sim_dict[\"Baseline\"].demand |> cumsum) .* 100,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand (cumulative sum, relative to Baseline)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    discount_sim_dict[scenario].revenue,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noutput_df = DataFrame(\n  scenario = [\n    [\"Baseline\", \"Temporary\", \"Permanent\"];\n    [\"edlp_\" * string(price) for price in price_states]\n  ],\n  demand = [\n    [\n      discount_sim_dict[scenario].demand |> sum\n      for scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n    ]; [\n      edlp_sim_dict[price].demand |> sum\n      for price in price_states\n    ]\n  ],\n  revenue = [\n    [\n      discount_sim_dict[scenario].revenue .* (beta .^((1:num_period_sim) .- 1)) |> sum\n      for scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n    ]; [\n      edlp_sim_dict[price].revenue .* (beta .^((1:num_period_sim) .- 1)) |> sum\n      for price in price_states\n    ]\n  ]\n)\n\noutput_df[!, :per_rev] = output_df[:, :revenue] ./ output_df[:, :demand] ./ 10;\n\noutput_df\n\n\n9×4 DataFrameRowscenariodemandrevenueper_revStringFloat64Float64Float641Baseline583.3251.19795e6205.3652Temporary586.1791.20157e6204.9843Permanent623.7691.22583e6196.524edlp_2000711.8081.30044e6182.6955edlp_2100664.1111.27258e6191.6226edlp_2200620.5181.24426e6200.5197edlp_2300580.3191.21512e6209.3888edlp_2400542.9541.18489e6218.239edlp_2500507.9821.15335e6227.046"
  },
  {
    "objectID": "dynamic_game_data.html",
    "href": "dynamic_game_data.html",
    "title": "9  疑似データの生成",
    "section": "",
    "text": "10 3"
  },
  {
    "objectID": "dynamic_game_data.html#step-1",
    "href": "dynamic_game_data.html#step-1",
    "title": "9  疑似データの生成",
    "section": "10.1 Step 1",
    "text": "10.1 Step 1\n\nCCP1 = repeat([0.5], 8);\nCCP2 = repeat([0.5], 8);\n\n\n\nCCP Transform\nfunction CCP1Transform(x)\n\n    return [\n        0 x[1] 1-x[1];\n        0 x[2] 1-x[2];\n        1-x[3] x[3] 0;\n        1-x[4] x[4] 0;\n        0 x[5] 1-x[5];\n        0 x[6] 1-x[6];\n        1-x[7] x[7] 0;\n        1-x[8] x[8] 0;\n    ]\n\nend;\n\nfunction CCP2Transform(x)\n\n    return [\n        0 x[1] 1-x[1];\n        1-x[2] x[2] 0;\n        0 x[3] 1-x[3];\n        1-x[4] x[4] 0;\n        0 x[5] 1-x[5];\n        1-x[6] x[6] 0;\n        0 x[7] 1-x[7];\n        1-x[8] x[8] 0;\n    ]\n\nend;\n\n\n\nCCP1Mat = CCP1Transform(CCP1);\nCCP2Mat = CCP2Transform(CCP2);\n\n\n\nfP\nfunction fP(Matrix1, Vec1, Vec2)\n\n    TempMat0 = kron(Matrix1, ones(4, 4));\n\n    TempMat1 = [\n        Vec1[1] 1-Vec1[1];\n        Vec1[2] 1-Vec1[2];\n        1-Vec1[3] Vec1[3];\n        1-Vec1[4] Vec1[4];\n        Vec1[5] 1-Vec1[5];\n        Vec1[6] 1-Vec1[6];\n        1-Vec1[7] Vec1[7];\n        1-Vec1[8] Vec1[8];\n    ];\n    TempMat1 = kron(TempMat1, [1 1]);\n    TempMat1 = hcat(TempMat1, TempMat1);\n\n    TempMat2 = [\n        Vec2[1] 1-Vec2[1];\n        1-Vec2[2] Vec2[2];\n        Vec2[3] 1-Vec2[3];\n        1-Vec2[4] Vec2[4];\n        Vec2[5] 1-Vec2[5];\n        1-Vec2[6] Vec2[6];\n        Vec2[7] 1-Vec2[7];\n        1-Vec2[8] Vec2[8];\n    ];\n    TempMat2 = kron(ones(1, 4), TempMat2);\n\n    return TempMat0 .* TempMat1 .* TempMat2;\n\nend;\n\n\n\nfPsigma = fP(TransitionMat, CCP1, CCP2);\n\n\n\npiPsigma Gen\nfunction pi1PsigmaGen(pi1, Mat2)\n\n    pi1_dec = pi1[:, 1];\n    pi1_0 = pi1[:, 2];\n    pi1_inc = pi1[:, 3];\n\n    pi1_dec = (pi1_dec .* Mat2) * ones(3);\n    pi1_0 = (pi1_0 .* Mat2) * ones(3);\n    pi1_inc = (pi1_inc .* Mat2) * ones(3);\n\n    return hcat(\n        pi1_dec, pi1_0, pi1_inc\n    )\n\nend\n\nfunction pi2PsigmaGen(pi2, Mat1)\n\n    pi2_dec = pi2[:, 1];\n    pi2_0 = pi2[:, 2];\n    pi2_inc = pi2[:, 3];\n\n    pi2_dec = (pi2_dec .* Mat1) * ones(3);\n    pi2_0 = (pi2_0 .* Mat1) * ones(3);\n    pi2_inc = (pi2_inc .* Mat1) * ones(3);\n\n    return hcat(\n        pi2_dec, pi2_0, pi2_inc\n    )\n\nend\n\n\npi2PsigmaGen (generic function with 1 method)\n\n\n\npi1Psigma = pi1PsigmaGen(pi1, CCP2Mat);\npi2Psigma = pi2PsigmaGen(pi2, CCP1Mat);\n\n\n\nCCP Log Transform\nfunction CCP1LogTransform(x)\n\n    return [\n        0 log(x[1]) log(1 - x[1]);\n        0 log(x[2]) log(1 - x[2]);\n        log(1 - x[3]) log(x[3]) 0;\n        log(1 - x[4]) log(x[4]) 0;\n        0 log(x[5]) log(1 - x[5]);\n        0 log(x[6]) log(1 - x[6]);\n        log(1 - x[7]) log(x[7]) 0;\n        log(1 - x[8]) log(x[8]) 0;\n    ]\n\nend\n\nfunction CCP2LogTransform(x)\n\n    return [\n        0 log(x[1]) log(1 - x[1]);\n        log(1 - x[2]) log(x[2]) 0;\n        0 log(x[3]) log(1 - x[3]);\n        log(1 - x[4]) log(x[4]) 0;\n        0 log(x[5]) log(1 - x[5]);\n        log(1 - x[6]) log(x[6]) 0;\n        0 log(x[7]) log(1 - x[7]);\n        log(1 - x[8]) log(x[8]) 0;\n    ]\n\nend\n\n\nCCP2LogTransform (generic function with 1 method)\n\n\n\neP1 = eulergamma .- CCP1LogTransform(CCP1);\neP2 = eulergamma .- CCP2LogTransform(CCP2);\n\n\nExanteV1 = (\n    (diagm(ones(8)) - beta .* fPsigma) \\ \n    ((CCP1Mat .* (pi1Psigma + eP1)) * ones(3))\n);\n\nExanteV2 = (\n    (diagm(ones(8)) - beta .* fPsigma) \\ \n    ((CCP2Mat .* (pi2Psigma + eP2)) * ones(3))\n);\n\n\n\nfP a given\nfunction fP_a1given(Matrix1, Vec2)\n\n    TempMat0 = kron(Matrix1, ones(4, 4));\n\n    TempMat2 = [\n        Vec2[1] 1-Vec2[1] Vec2[1] 1-Vec2[1];\n        1-Vec2[2] Vec2[2] 1-Vec2[2] Vec2[2];\n        Vec2[3] 1-Vec2[3] Vec2[3] 1-Vec2[3];\n        1-Vec2[4] Vec2[4] 1-Vec2[4] Vec2[4];\n        Vec2[5] 1-Vec2[5] Vec2[5] 1-Vec2[5];\n        1-Vec2[6] Vec2[6] 1-Vec2[6] Vec2[6];\n        Vec2[7] 1-Vec2[7] Vec2[7] 1-Vec2[7];\n        1-Vec2[8] Vec2[8] 1-Vec2[8] Vec2[8];\n    ];\n    TempMat2 = hcat(TempMat2, TempMat2);\n\n    MatAdjustMinus1 = repeat(vcat(\n        zeros(2, 8), ones(2, 8)\n    ), 2);\n    MatAdjustMinus2 = repeat(vcat(\n        ones(2, 8), zeros(2, 8)\n    ), 2)';\n    output1 = TempMat0 .* TempMat2 .* MatAdjustMinus1 .* MatAdjustMinus2;\n\n\n    ForZero = diagm(ones(2));\n    MatAdjustZero = kron(ForZero, ones(2, 2));\n    MatAdjustZero = hcat(MatAdjustZero, MatAdjustZero);\n    MatAdjustZero = vcat(MatAdjustZero, MatAdjustZero);\n    output2 = TempMat0 .* TempMat2 .* MatAdjustZero;\n\n\n    MatAdjustPlus1 = repeat(vcat(\n        ones(2, 8), zeros(2, 8)\n    ), 2);\n    MatAdjustPlus2 = repeat(vcat(\n        zeros(2, 8), ones(2, 8)\n    ), 2)';\n    output3 = TempMat0 .* TempMat2 .* MatAdjustPlus1 .* MatAdjustPlus2;\n\n    return [output1, output2, output3]\nend\n\nfunction fP_a2given(Matrix1, Vec1)\n\n    TempMat0 = kron(Matrix1, ones(4, 4));\n\n    TempMat1 = [\n        Vec1[1] Vec1[1] 1-Vec1[1] 1-Vec1[1];\n        Vec1[2] Vec1[2] 1-Vec1[2] 1-Vec1[2];\n        1-Vec1[3] 1-Vec1[3] Vec1[3] Vec1[3];\n        1-Vec1[4] 1-Vec1[4] Vec1[4] Vec1[4];\n        Vec1[5] Vec1[5] 1-Vec1[5] 1-Vec1[5];\n        Vec1[6] Vec1[6] 1-Vec1[6] 1-Vec1[6];\n        1-Vec1[7] 1-Vec1[7] Vec1[7] Vec1[7];\n        1-Vec1[8] 1-Vec1[8] Vec1[8] Vec1[8];\n    ];\n    TempMat1 = kron(ones(1, 2), TempMat1);\n\n    MatAdjustMinus1 = repeat(vcat(zeros(1, 8), ones(1, 8)), 4);\n    MatAdjustMinus2 = repeat(vcat(ones(1, 8), zeros(1, 8)), 4)';\n    output1 = TempMat0 .* TempMat1 .* MatAdjustMinus1 .* MatAdjustMinus2;\n\n\n    MatAdjustZero = repeat(vcat(\n        repeat([1, 0], 4)',\n        repeat([0, 1], 4)',\n    ), 4);\n    output2 = TempMat0 .* TempMat1 .* MatAdjustZero;\n\n\n    MatAdjustPlus1 = repeat(vcat(ones(1, 8), zeros(1, 8)), 4);\n    MatAdjustPlus2 = repeat(vcat(zeros(1, 8), ones(1, 8)), 4)';\n    output3 = TempMat0 .* TempMat1 .* MatAdjustPlus1 .* MatAdjustPlus2;\n\n    return [output1, output2, output3]\nend\n\n\nfP_a2given (generic function with 1 method)\n\n\n\nfP_a1 = fP_a1given(TransitionMat, CCP2);\nfP_a2 = fP_a2given(TransitionMat, CCP1);\n\n\nNewSigmaSeed1 = (\n    pi1Psigma + beta .* hcat(fP_a1[1] * ExanteV1, fP_a1[2] * ExanteV1, fP_a1[3] * ExanteV1) .* CCP1Adjuster\n);\nNewSigmaDeno1 = (\n    sum(exp.(NewSigmaSeed1), dims = 2) .- 1\n);\nNewSigma1 = exp.(NewSigmaSeed1) ./ NewSigmaDeno1;\nCCP1UpdatedMat = NewSigma1 .* CCP1Adjuster;\nCCP1Updated = CCP1UpdatedMat[:, 2];\n\nNewSigmaSeed2 = (\n    pi2Psigma + beta .* hcat(fP_a2[1] * ExanteV2, fP_a2[2] * ExanteV2, fP_a2[3] * ExanteV2) .* CCP2Adjuster\n);\nNewSigmaDeno2 = (\n    sum(exp.(NewSigmaSeed2), dims = 2) .- 1\n);\nNewSigma2 = exp.(NewSigmaSeed2) ./ NewSigmaDeno2;\nCCP2UpdatedMat = NewSigma2 .* CCP2Adjuster;\nCCP2Updated = CCP2UpdatedMat[:, 2];"
  },
  {
    "objectID": "dynamic_game_data.html#step-4",
    "href": "dynamic_game_data.html#step-4",
    "title": "9  疑似データの生成",
    "section": "10.2 Step 4",
    "text": "10.2 Step 4\n\nfPsigma = fP(TransitionMat, CCP1Updated, CCP2Updated);\n\npi1Psigma = pi1PsigmaGen(pi1, CCP2UpdatedMat);\npi2Psigma = pi2PsigmaGen(pi2, CCP1UpdatedMat);\n\neP1 = eulergamma .- CCP1LogTransform(CCP1Updated);\neP2 = eulergamma .- CCP2LogTransform(CCP2Updated);\n\nExanteV1Updated = (\n    (diagm(ones(8)) - beta .* fPsigma) \\ \n    ((CCP1UpdatedMat .* (pi1Psigma + eP1)) * ones(3))\n);\n\nExanteV2Updated = (\n    (diagm(ones(8)) - beta .* fPsigma) \\ \n    ((CCP2UpdatedMat .* (pi2Psigma + eP2)) * ones(3))\n);"
  },
  {
    "objectID": "dynamic_game_data.html#step-5",
    "href": "dynamic_game_data.html#step-5",
    "title": "9  疑似データの生成",
    "section": "10.3 Step 5",
    "text": "10.3 Step 5\n\nDiffExanteV = 1;\niter = 0;\n\n@time while (DiffExanteV > 1e-12)\n\n    CCP1 = CCP1Updated[:];\n    CCP2 = CCP2Updated[:];\n\n    ExanteV1 = ExanteV1Updated[:];\n    ExanteV2 = ExanteV2Updated[:];\n\n    fP_a1 = fP_a1given(TransitionMat, CCP2);\n    fP_a2 = fP_a2given(TransitionMat, CCP1);\n\n    NewSigmaSeed1 = (\n        pi1Psigma + beta .* hcat(fP_a1[1] * ExanteV1, fP_a1[2] * ExanteV1, fP_a1[3] * ExanteV1) .* CCP1Adjuster\n    );\n    NewSigmaDeno1 = (\n        sum(exp.(NewSigmaSeed1), dims = 2) .- 1\n    );\n    NewSigma1 = exp.(NewSigmaSeed1) ./ NewSigmaDeno1;\n    CCP1UpdatedMat = NewSigma1 .* CCP1Adjuster;\n    CCP1Updated = CCP1UpdatedMat[:, 2];\n\n    NewSigmaSeed2 = (\n        pi2Psigma + beta .* hcat(fP_a2[1] * ExanteV2, fP_a2[2] * ExanteV2, fP_a2[3] * ExanteV2) .* CCP2Adjuster\n    );\n    NewSigmaDeno2 = (\n        sum(exp.(NewSigmaSeed2), dims = 2) .- 1\n    );\n    NewSigma2 = exp.(NewSigmaSeed2) ./ NewSigmaDeno2;\n    CCP2UpdatedMat = NewSigma2 .* CCP2Adjuster;\n    CCP2Updated = CCP2UpdatedMat[:, 2];\n\n    fPsigma = fP(TransitionMat, CCP1Updated, CCP2Updated);\n\n    pi1Psigma = pi1PsigmaGen(pi1, CCP2UpdatedMat);\n    pi2Psigma = pi2PsigmaGen(pi2, CCP1UpdatedMat);\n\n    eP1 = eulergamma .- CCP1LogTransform(CCP1Updated);\n    eP2 = eulergamma .- CCP2LogTransform(CCP2Updated);\n\n    ExanteV1Updated = (\n        (diagm(ones(8)) - beta .* fPsigma) \\ \n        ((CCP1UpdatedMat .* (pi1Psigma + eP1)) * ones(3))\n    );\n\n    ExanteV2Updated = (\n        (diagm(ones(8)) - beta .* fPsigma) \\ \n        ((CCP2UpdatedMat .* (pi2Psigma + eP2)) * ones(3))\n    );\n\n    DiffExanteV = sum((ExanteV1Updated - ExanteV1).^2 + (ExanteV2Updated - ExanteV2).^2);\n\nend;\n\n  0.074838 seconds (205.19 k allocations: 13.970 MiB, 98.40% compilation time)\n\n\n\nCCP1UpdatedMat\n\n8×3 Matrix{Float64}:\n 0.0       0.683563  0.316437\n 0.0       0.712662  0.287338\n 0.184349  0.815651  0.0\n 0.206181  0.793819  0.0\n 0.0       0.708067  0.291933\n 0.0       0.735965  0.264035\n 0.202453  0.797547  0.0\n 0.225863  0.774137  0.0\n\n\n\nCCP2UpdatedMat\n\n8×3 Matrix{Float64}:\n 0.0       0.714725  0.285275\n 0.207591  0.792409  0.0\n 0.0       0.741697  0.258303\n 0.231269  0.768731  0.0\n 0.0       0.737685  0.262315\n 0.227294  0.772706  0.0\n 0.0       0.76353   0.23647\n 0.2527    0.7473    0.0"
  },
  {
    "objectID": "dynamic_game_data.html#step-6",
    "href": "dynamic_game_data.html#step-6",
    "title": "9  疑似データの生成",
    "section": "10.4 Step 6",
    "text": "10.4 Step 6\n\nNumSimMarkets = 500;\nNumSimPeriods = 50;\nNumSimFirms = 2;\n\n\nInitialState = sample(1:8, NumSimMarkets);\n\nRandomNumbers = reshape(\n    rand(NumSimMarkets * NumSimPeriods * (NumSimFirms + 1)),\n    (NumSimMarkets, NumSimPeriods, NumSimFirms + 1)\n);\n\n\nFakeData = zeros(NumSimMarkets * NumSimPeriods, 8);\n\nfor m in 1:NumSimMarkets, t in 1:NumSimPeriods\n\n    FakeData[(m - 1) * NumSimPeriods + t, 1] = m;\n    FakeData[(m - 1) * NumSimPeriods + t, 2] = t;\n\n    if t == 1\n\n        FakeData[(m - 1) * NumSimPeriods + 1, 3] = InitialState[m];\n\n        FakeData[(m - 1) * NumSimPeriods + 1, 4] = (\n            (InitialState[m] >= 1) & (InitialState[m] <= 4) ? 1 :\n            2\n        );\n\n    else\n\n        sprev = FakeData[(m - 1) * NumSimPeriods + t - 1, 3]\n        a1prev = FakeData[(m - 1) * NumSimPeriods + t - 1, 7]\n        a2prev = FakeData[(m - 1) * NumSimPeriods + t - 1, 8]\n\n        if (sprev >= 1) & (sprev <= 4)\n            FakeData[(m - 1) * NumSimPeriods + t, 4] = (\n                (RandomNumbers[m, t, 3] < TransitionMat[1, 1]) ? 1 :\n                2\n            );\n        else\n            FakeData[(m - 1) * NumSimPeriods + t, 4] = (\n                (RandomNumbers[m, t, 3] < TransitionMat[2, 2]) ? 2 :\n                1\n            );\n        end\n\n        snow = FakeData[(m - 1) * NumSimPeriods + t, 4];\n        n1t = FakeData[(m - 1) * NumSimPeriods + t - 1, 5] + a1prev;\n        n2t = FakeData[(m - 1) * NumSimPeriods + t - 1, 6] + a2prev;\n\n        FakeData[(m - 1) * NumSimPeriods + t, 3] = (\n            (snow == 1) & (n1t == 0) & (n2t == 0) ? 1 :\n            (snow == 1) & (n1t == 0) & (n2t == 1) ? 2 :\n            (snow == 1) & (n1t == 1) & (n2t == 0) ? 3 :\n            (snow == 1) & (n1t == 1) & (n2t == 1) ? 4 :\n            (snow == 2) & (n1t == 0) & (n2t == 0) ? 5 :\n            (snow == 2) & (n1t == 0) & (n2t == 1) ? 6 :\n            (snow == 2) & (n1t == 1) & (n2t == 0) ? 7 :\n            (snow == 2) & (n1t == 1) & (n2t == 1) ? 8 :\n            0\n        );\n\n    end\n\n    s = Int(FakeData[(m - 1) * NumSimPeriods + t, 3]);\n\n    if s == 1\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 0, 0];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 2\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 0, 1];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    elseif s == 3\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 1, 0];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 4\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 1, 1];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    elseif s == 5\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 0, 0];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 6\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 0, 1];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    elseif s == 7\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 1, 0];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 8\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 1, 1];\n        if (RandomNumbers[m, t, 1] > CCP1UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2UpdatedMat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    end\nend\n\n\njldsave(\n    \"tmp/dynamic_game/data_workspace.jld2\" ;\n    FakeData, CCP1UpdatedMat, CCP2UpdatedMat, \n    ExanteV1, ExanteV2, ExanteV1Updated, ExanteV2Updated\n)"
  },
  {
    "objectID": "demand_estimation_2.html#section",
    "href": "demand_estimation_2.html#section",
    "title": "3  基礎編 2",
    "section": "3.2 4.1",
    "text": "3.2 4.1\n\nNIPPYOautoIDvec = [\n    260, 4, 76, 104, 64, 54, 152, 153, 71, 197,\n    42, 45, 114, 208, 209, 77, 236, 58, 127, 187,\n    79, 175, 19, 117, 216, 112, 256, 119, 37, 158\n];\n\ndataNIPPYO = data[\n    in(NIPPYOautoIDvec).(data[:, :NameID]), \n    [:year, :share, :NameID, :Sales, :price, :hppw, :FuelEfficiency, :size, :Name]\n    ];\ndataNIPPYO[!, :log_sales] = log.(dataNIPPYO[:, :Sales]);\ndataNIPPYO[!, :log_price] = log.(dataNIPPYO[:, :price]);\ndataNIPPYO[!, :log10_sales] = log10.(dataNIPPYO[:, :Sales]);\ndataNIPPYO[!, :log10_price] = log10.(dataNIPPYO[:, :price]);"
  },
  {
    "objectID": "demand_estimation_2.html#section-1",
    "href": "demand_estimation_2.html#section-1",
    "title": "3  基礎編 2",
    "section": "3.8 8",
    "text": "3.8 8\n\nmarket2016Index = data.year .== 2016;\n\nelasmat = calculateElasticity(\n    data[market2016Index, :].price,\n    X2[market2016Index, :],\n    beta_hat,\n    resultGMM.minimizer,\n    randomDrawMat,\n    delta[market2016Index, :]\n)\n\nelasmat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -1.39415      0.0580442    0.0538872    0.0287754\n  0.0196789   -1.10079      0.0196789    0.00936074\n  0.0228989    0.0246654   -1.42514      0.0122279\n  0.00400251   0.00384041   0.00400251  -2.40013"
  },
  {
    "objectID": "demand_estimation_2.html#section-2",
    "href": "demand_estimation_2.html#section-2",
    "title": "3  基礎編 2",
    "section": "3.9 9",
    "text": "3.9 9\n\nprice_range = range(1.8, 4.0, step = 0.05);\nownpi_res = calculateRevenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(delta), Ref(beta_hat), Ref(resultGMM.minimizer),\n    \"ownpi\"\n);\n\nplot(price_range, ownpi_res, legend = false)\nxlabel!(\"Price\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprice_range = range(1.8, 4.0, step = 0.05);\ntotalpi_res = calculateRevenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(delta), Ref(beta_hat), Ref(resultGMM.minimizer),\n    \"totalpi\"\n);\n\nplot(price_range, totalpi_res, legend = false)\nxlabel!(\"Price\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nownpi_optim_res = optimize(\n    x -> - calculateRevenue(\n        x[1], data, datalist, delta, \n        beta_hat, resultGMM.minimizer, \"ownpi\"\n        ),\n    [3.0]\n);\n\n@printf(\"Revenue-maximizing price: %.3f \\n\", ownpi_optim_res.minimizer[1])\n@printf(\"Maximized revenue : %.3f\", -ownpi_optim_res.minimum)\n\nRevenue-maximizing price: 3.009 \nMaximized revenue : 56036.151\n\n\n\ntotalpi_optim_res = optimize(\n    x -> - calculateRevenue(\n        x[1], data, datalist, delta, \n        beta_hat, resultGMM.minimizer, \"totalpi\"\n        ),\n    [3.0]\n);\n\n@printf(\"Revenue-maximizing price: %.3f \\n\", totalpi_optim_res.minimizer[1])\n@printf(\"Maximized revenue : %.3f\", -totalpi_optim_res.minimum)\n\nRevenue-maximizing price: 3.224 \nMaximized revenue : 754938.280\n\n\n\ncalculateRevenue(\n    ownpi_optim_res.minimizer[1], \n    data,\n    datalist,\n    delta,\n    beta_hat,\n    resultGMM.minimizer,\n    \"totalpi\"\n    )\n\n754450.1490921066"
  },
  {
    "objectID": "demand_estimation_2.html#section-3",
    "href": "demand_estimation_2.html#section-3",
    "title": "3  基礎編 2",
    "section": "3.4 6.1",
    "text": "3.4 6.1\n\nalpha1 = ols_res.coef[ols_res.coefnames .== \"price\"][1]\nsigma1 = ols_res.coef[ols_res.coefnames .== \"log_inside_share\"][1]\n\nalpha2 = iv_BLP2_res.coef[iv_BLP2_res.coefnames .== \"price\"][1]\nsigma2 = iv_BLP2_res.coef[iv_BLP2_res.coefnames .== \"log_inside_share\"][1]\n\ndata[!, :own_elas_ols] = alpha1 .* data[:, :price] .* (\n    1.0 .- sigma1 .* data[:, :inside_share] .- \n    (1.0 .- sigma1) .* data[:, :share]\n) ./ (1.0 .- sigma1);\ndata[!, :own_elas_ivglp] = alpha2 .* data[:, :price] .* (\n    1.0 .- sigma2 .* data[:, :inside_share] .- \n    (1.0 .- sigma2) .* data[:, :share]\n) ./ (1.0 .- sigma2);\n\ndescribe(data[:, r\"^own_elas\"], :mean, :std, :median, :min, :max)\ndata_NIPPYO = data[\n    in(NIPPYOautoIDvec).(data[:, :NameID]), \n    [:year, :share, :Type, :inside_share, :NameID, :Sales, :price, :hppw, :FuelEfficiency, :size, :Name]\n    ];\ndata_NIPPYO[!, :log_sales] = log.(data_NIPPYO[:, :Sales]);\ndata_NIPPYO[!, :log_price] = log.(data_NIPPYO[:, :price]);\n\ndt_2016 = data_NIPPYO[data_NIPPYO.year .== 2016, [:price, :Type, :share, :inside_share, :NameID, :Name]]\n\nprice = dt_2016.price;\nshare = dt_2016.share;\nNameID = dt_2016.NameID;\ninside_share = dt_2016.inside_share;\ngroup = dt_2016.Type;\nown_elas = alpha2 .* price .* (1.0 .- sigma2 .* inside_share .- (1.0 .- sigma2) .* share) ./ (1.0 .- sigma2);\ncross_elas_othergroup = (-1.0) .* alpha2 .* price .* share;\nJ = length(own_elas);\n\ncross_elas_othergroup = reduce(hcat, [cross_elas_othergroup for j = 1:J]);\nelas_mat[diagind(elas_mat)] = own_elas;\n\nprice_1_mat       = reduce(hcat, [price for j = 1:J]);\nshare_1_mat       = reduce(hcat, [share for j = 1:J]);\ninsideshare_1_mat = reduce(hcat, [inside_share for j = 1:J]);\n\ncross_elas_samegroup = (-1.0) .* alpha2 .* price_1_mat .* (\n    sigma2 .* insideshare_1_mat .+ (1.0 .- sigma2) .* share_1_mat\n) ./ (1.0 .- sigma2);\n\ntemp_mat1 = reduce(hcat, [group for j = 1:J]);\ntemp_mat2 = permutedims(temp_mat1);\nind_same_group  = (temp_mat1 .== temp_mat2);\nind_other_group = (temp_mat1 .!== temp_mat2);\n\nelas_mat_nl = cross_elas_samegroup .* ind_same_group .+ cross_elas_othergroup .* ind_other_group;\nelas_mat_nl[diagind(elas_mat_nl)] = own_elas;\n\nelas_mat_nl[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -5.1197       0.0477573    0.0477573    0.00136172\n  0.050713    -2.34881      0.050713     0.001446\n  0.00615725   0.00615725  -2.80217      0.000175564\n  0.00218614   0.00218614   0.00218614  -1.83296"
  },
  {
    "objectID": "demand_estimation_2.html#section-4",
    "href": "demand_estimation_2.html#section-4",
    "title": "3  基礎編 2",
    "section": "3.5 7",
    "text": "3.5 7\n\n3.5.1 Step 1\n\nsort!(data, [:year, :NameID]);\nN = nrow(data);\nT = length(unique(data.year));\nX1 = hcat(repeat([1], N), Matrix(data[:, [:price, :FuelEfficiency, :hppw, :size]]));\nX2 = hcat(data.price, repeat([1], N), data.size);\nZ = hcat(\n    repeat([1], N),\n    Matrix(data[:, [:FuelEfficiency, :hppw, :size]]),\n    Matrix(data[:, r\"^iv_GH.*(?<!nest)$\"])\n    );\nRandom.seed!(123);\nNsim = 500;\n\ndraw_vec = reduce(hcat, [randn(size(X2, 2)) for j =1:Nsim]);\n\ntheta2 = [0.001, 0.001, 0.001];\n\nmarketindex = data.year;\nuniquemarketindex = sort(unique(data.year));\n\ntemp1 = reduce(hcat, [uniquemarketindex for j = 1:N])';\ntemp2 = reduce(hcat, [data.year for j = 1:T]);\ntempmat = (temp1 .== temp2);\nmutable struct datalist_struct\n    X1::Array{Float64,2};\n    X2::Array{Float64,2};\n    Z::Array{Float64,2};\n    ShareVec::Vector{Float64};\n    marketindex::Vector{Int64};\n    logitshare::Vector{Float64};\n    draw_vec::Array{Float64,2};\n    tempmat::BitMatrix\nend\n\nmutable struct parameter_struct\n    Nsim::Int;\n    T::Int;\n    N::Int;\nend\ndatalist = datalist_struct(X1, X2, Z, data.share, marketindex, data.logit_share, draw_vec, tempmat);\nparameter = parameter_struct(Nsim, T, N);\n\n\n\n3.5.2 Step 2\n\nfunction f_mktshare(\n        theta2,\n        datalist::datalist_struct,\n        parameter::parameter_struct,\n        delta\n    )\n        \n    mu = datalist.X2 * Diagonal(theta2) * datalist.draw_vec;\n    \n    delta_mu = delta .* ones((1, parameter.Nsim)) .+ mu;\n    exp_delta_mu = exp.(delta_mu .- maximum(delta_mu));\n    denom_outside = exp.(-maximum(delta_mu));\n    \n    denom_temp = (exp_delta_mu' * datalist.tempmat)' .+ denom_outside;\n    denom = datalist.tempmat * denom_temp;\n    \n    s_jt_i = exp_delta_mu ./ denom;\n    s_jt = vec(mean(s_jt_i, dims = 2));\n    \n    return s_jt\n    \nend\n@time f_mktshare([0.01, 0.01, 0.01], datalist, parameter, data.logit_share);\n\n  0.749467 seconds (2.42 M allocations: 182.417 MiB, 10.84% gc time, 91.50% compilation time)\n\n\n\n\n3.5.3 Step 3\n\nfunction f_contraction(\n        theta2,\n        datalist::datalist_struct,\n        parameter::parameter_struct,\n        delta_ini\n    )\n    \n    tol = 1e-11;\n    norm = 1e+10\n\n    delta_old = delta_ini;\n    exp_delta_old = exp.(delta_old);\n    \n    iter = 0;\n        \n    while ((norm > tol) & (iter < 1000))\n        \n#         print(iter, \"\\n\")\n        \n        pred_mkt_share = f_mktshare(theta2, datalist, parameter, delta_old);\n        \n        exp_delta = exp_delta_old .* datalist.ShareVec ./ pred_mkt_share;\n        \n        norm = maximum(abs.(exp_delta .- exp_delta_old));\n        \n        exp_delta_old = exp_delta;\n        delta_old = log.(exp_delta);\n        iter += 1;\n        \n    end\n    \n#     print(iter, \"\\n\")\n    \n    return delta_old;\n    \nend\n    \n@time f_contraction([0.1, 0.01, 0.01], datalist, parameter, data.logit_share);\n\n  0.428957 seconds (209.48 k allocations: 293.678 MiB, 12.68% gc time, 27.17% compilation time)\n\n\n\n\n3.5.4 Step 4\n\nfunction f_GMMobj(\n        theta2,\n        parameter::parameter_struct,\n        datalist::datalist_struct,\n        delta_ini::Vector{Float64}\n    )\n    \n#     delta_ini = delta_global;\n#     delta_ini = datalist.logitshare;\n    delta = f_contraction(theta2, datalist, parameter, delta_ini);\n#     global delta_global = delta\n    \n#     if (datalist.weight_mat_option == \"2SLS\") \n        W = inv(datalist.Z' * datalist.Z);\n#     elseif (datalist.weight_mat_option == \"Ident\")\n#         W = I(size(datalist.Z, 2));\n#     end\n    \n    beta_hat = (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ (datalist.X1' * datalist.Z * W * datalist.Z' * delta);\n    \n    Xi = delta - datalist.X1 * beta_hat;\n    \n    output = Xi' * datalist.Z * W * datalist.Z' * Xi\n        \n    return output\n    \nend    \n    \ninitial_x = [0.1, 1.0, 0.1];\ndelta_ini = f_contraction(initial_x, datalist, parameter, datalist.logitshare);\n\n\nobjFunc_for_Optim = TwiceDifferentiable(\n    x -> f_GMMobj(x, parameter, datalist, delta_ini),\n    initial_x;\n    autodiff = :forward\n    );\n@time gmm_res = optimize(\n    objFunc_for_Optim,\n#     x -> f_GMMobj(x, parameter, datalist, delta_ini),\n    [0.0, 0.00, 0.00],\n    [Inf, Inf, Inf],\n    initial_x,\n    Optim.Options(show_trace = true)\n)\n\n\n\n * Status: success\n\n * Candidate solution\n    Final objective value:     1.720392e+02\n\n * Found with\n    Algorithm:     Interior Point Newton\n\n * Convergence measures\n    |x - x'|               = 0.00e+00 ≤ 0.0e+00\n    |x - x'|/|x'|          = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 9.27e+00 ≰ 1.0e-08\n\n * Work counters\n    Seconds run:   376  (vs limit Inf)\n    Iterations:    24\n    f(x) calls:    218\n    ∇f(x) calls:   218\n\n\n\ngmm_res.minimizer\n\n3-element Vector{Float64}:\n  0.28734533108108296\n 15.767041571288186\n  0.07564921477989821\n\n\n\nW = inv(datalist.Z' * datalist.Z);    \ndelta = f_contraction(gmm_res.minimizer, datalist, parameter, delta_ini);\nbeta_hat = (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ (datalist.X1' * datalist.Z * W * datalist.Z' * delta);\n\nbeta_hat\n\n5-element Vector{Float64}:\n -30.94355607145988\n  -0.9028865616490973\n   0.11090678367437005\n   9.193592802875408\n   0.28736901935168374\n\n\n\n\n3.5.5 Step 5\n\nXi = delta - X1 * beta_hat;\nOmega_hat = reduce(+, Z[i,:] * Z[i,:]' .* Xi[i]^2 ./ N for i = 1:N);\nDdelta = ForwardDiff.jacobian(x -> delta_ini = f_contraction(x, datalist, parameter, delta), gmm_res.minimizer);\nG = Z' * hcat(- X1, Ddelta) ./ N;\nAsyVarMat = (G' * W * G) \\ G' * W * Omega_hat * W * G * inv(G' * W * G);\nAse = sqrt.(diag(AsyVarMat) ./ N);\n\nDataFrame(\n    Var = [\"Const\", \"Price\", \"Fuel Efficiency\", \"hppw\", \"size\", \"random_price\", \"random_constant\", \"random_size\"],\n    Est = vcat(beta_hat, gmm_res.minimizer),\n    se = Ase\n)\n\n\n8×3 DataFrameRowVarEstseStringFloat64Float641Const-30.943615.51382Price-0.9028870.4330623Fuel Efficiency0.1109070.01105714hppw9.193593.113645size0.2873690.05171996random_price0.2873450.4324577random_constant15.767101.9688random_size0.07564920.290593"
  },
  {
    "objectID": "demand_estimation_2.html#section-5",
    "href": "demand_estimation_2.html#section-5",
    "title": "3  基礎編 2",
    "section": "3.6 8",
    "text": "3.6 8\n\nmu = X2 * Diagonal(gmm_res.minimizer) * draw_vec;\ndelta_mu = delta .+ mu;\nexp_delta_mu = exp.(delta_mu);\ndenom_outside = exp.(0.0);\ndenom_temp = (exp_delta_mu' * tempmat)' .+ denom_outside;\ndenom = tempmat * denom_temp;\n\ns_jt_i = exp_delta_mu ./ denom;\ndraw_for_price = draw_vec[1,:];\nalpha_i = beta_hat[2] .+ gmm_res.minimizer[1] .* draw_for_price;\nyear = 2016\nJ_t = sum(data.year .== year);\n\nag_model_s_i = s_jt_i[data.year .== year, :]\nag_model_s = mean(ag_model_s_i, dims = 2);\nprice_t = data.price[data.year .== year];\n\nelasmat = zeros((J_t, J_t));\n\nfor k in 1:J_t, j in 1:J_t\n    if (k != j)\n        elasmat[k, j] = (-1.0) .* price_t[k] ./ ag_model_s[j] * mean(alpha_i .* ag_model_s_i[j, :] .* ag_model_s_i[k, :])\n    elseif (k == j)\n        elasmat[k, j] = price_t[j] ./ ag_model_s[j] * mean(alpha_i .* ag_model_s_i[j, :] .* (1.0 .- ag_model_s_i[j, :]))\n    end\nend\n\n\nelasmat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -1.10253      0.0451789    0.0435272    0.0324128\n  0.0153236   -0.832714     0.0153759    0.0109914\n  0.0184981    0.0192656   -1.12275      0.0138002\n  0.00450168   0.00450075   0.00450998  -2.50034"
  },
  {
    "objectID": "demand_estimation_2.html#section-6",
    "href": "demand_estimation_2.html#section-6",
    "title": "3  基礎編 2",
    "section": "3.7 9",
    "text": "3.7 9\n\nfunction f_revenue(\n        price_cand,\n        data,\n        datalist,\n        parameter,\n        delta,\n        beta_hat,\n        theta2,\n        option\n    )\n\n    mc_betado = 3.198 * (1.0 - 1.0 / abs(-2.16720791));\n\n    tempprice = data.price[:];\n    tempprice[(data.NameID .== 197) .& (data.year .== 2016)] .= price_cand;\n    \n    X1_new = datalist.X1[:,:];\n    X2_new = datalist.X2[:,:];\n    X1_new[:, 2] = tempprice;\n    X2_new[:, 1] = tempprice;\n    \n    org_xi = delta .- datalist.X1 * beta_hat;\n    new_delta = X1_new * beta_hat .+ org_xi;\n    \n    datalist_temp = datalist_struct(\n        X1_new, X2_new, datalist.Z, data.share, datalist.marketindex, \n        data.logit_share, datalist.draw_vec, datalist.tempmat\n        );\n    \n    mktshare = f_mktshare(theta2, datalist_temp, parameter, new_delta);\n    \n    quant = mktshare .* data.HH;\n    revenue = tempprice .* quant;\n        \n    revenuevec  = revenue[(data.NameID .== 197) .& (data.year .== 2016)];\n    revenuevec2 = sum(revenue[in(NIPPYOautoIDvec).(data[:, :NameID]) .& (data.year .== 2016)]);\n    \n    pivec  = revenuevec  .- mc_betado .* quant[(data.NameID .== 197) .& (data.year .== 2016)];\n    pivec2 = revenuevec2 .- mc_betado .* quant[(data.NameID .== 197) .& (data.year .== 2016)];\n\n    if option == \"own\"\n        return(revenuevec[1])\n    elseif option == \"total\"\n        return(revenuevec2[1])\n    elseif option == \"ownpi\"\n        return(pivec[1])\n    elseif option == \"totalpi\"\n        return(pivec2[1])\n    end\n    \nend\nprice_range = range(1.8, 4.0, step = 0.05);\nownpi_res = f_revenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(parameter), Ref(delta), Ref(beta_hat), Ref(gmm_res.minimizer),\n    \"ownpi\"\n);\nplot(price_range, ownpi_res, legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprice_range = range(1.8, 4.0, step = 0.05);\ntotalpi_res = f_revenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(parameter), Ref(delta), Ref(beta_hat), Ref(gmm_res.minimizer),\n    \"totalpi\"\n);\nplot(price_range, totalpi_res, legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nownpi_optim_res = optimize(\n    x -> - f_revenue(x[1], data, datalist, parameter, delta, beta_hat, gmm_res.minimizer, \"ownpi\"),\n    [3.0]\n)\n\nownpi_optim_res.minimizer\n\n1-element Vector{Float64}:\n 2.967175245285034\n\n\n\ntotalpi_optim_res = optimize(\n    x -> - f_revenue(x[1], data, datalist, parameter, delta, beta_hat, gmm_res.minimizer, \"totalpi\"),\n    [3.0]\n)\ntotalpi_optim_res.minimizer\n\n1-element Vector{Float64}:\n 3.136022758483887"
  },
  {
    "objectID": "demand_estimation_merger.html#data-cleaning",
    "href": "demand_estimation_merger.html#data-cleaning",
    "title": "4  応用編",
    "section": "4.1 Data cleaning",
    "text": "4.1 Data cleaning\n\ndata[!, :Foreign_d] = data[:, :Type] .== \"Foreign\";\ndata[!, :FuelRegular_d] = data[:, :FuelType] .== \"レギュラー\";\ndata[!, :capacity_d] = data[:, :capacity] .> 4;\ntransform!(\n    data, \n    [\n        :year => ByRow(isequal(v))=> Symbol(\"year_\" * string(v)) \n        for v in unique(data.year)\n        ]\n    );\nselect!(data, Not(:year_2006));"
  },
  {
    "objectID": "demand_estimation_merger.html#section",
    "href": "demand_estimation_merger.html#section",
    "title": "4  応用編",
    "section": "4.2 4.2",
    "text": "4.2 4.2\n\nsort!(data, [:year, :Maker, :price]);\nN = nrow(data);\nT = length(unique(data.year));\nX1 = hcat(\n    ones(N),\n    Matrix(\n        data[:,[\n            :price, :FuelEfficiency, :hppw, :size, \n            :capacity_d, :FuelRegular_d, :Foreign_d\n            ]]\n        ),\n    Matrix(data[:, r\"^year_\"])    \n    );\nX2 = Matrix(data[:, [:price]]);\nZ = hcat(\n    ones(N),\n    Matrix(\n        data[:, [\n            :FuelEfficiency, :hppw, :size, \n            :capacity_d, :FuelRegular_d, :Foreign_d\n            ]]\n        ),\n    Matrix(data[:, r\"^year_\"]),\n    Matrix(data[:, r\"^iv_GH.*(?<!nest)$\"])\n    );\n\nRandom.seed!(42);\nNsim = 1000;\n\nrandomDrawMat = randn(size(X2)[2], Nsim);\n\n\nmarketIndex = data.year;\nuniqueMarketIndex = sort(unique(data.year));\n\nmarketIndexMat = reduce(\n    hcat, \n    [marketIndex .== market for market in uniqueMarketIndex]\n    );\n\ndatalist = datalist_struct(\n    X1, \n    X2, \n    Z, \n    data.share, \n    marketIndex, \n    data.logit_share, \n    randomDrawMat, \n    marketIndexMat\n    );\nparameter = parameter_struct(Nsim, T, N);"
  },
  {
    "objectID": "demand_estimation_merger.html#section-1",
    "href": "demand_estimation_merger.html#section-1",
    "title": "4  応用編",
    "section": "4.3 4.3",
    "text": "4.3 4.3\n\ninitial_x = [0.1];\ndelta_ini = calculateMeanUtil(initial_x, datalist, datalist.logitshare);\n\n\nobjFunc_for_Optim = TwiceDifferentiable(\n    x -> calculateGMMObjective(x, datalist, delta_ini),\n    initial_x;\n    autodiff = :forward\n    );\n@time resultGMM = optimize(\n    objFunc_for_Optim,\n    [0.0],\n    [Inf],\n    initial_x,\n    Optim.Options(show_trace = false)\n)\n\n\nW = inv(datalist.Z' * datalist.Z);    \ndelta = calculateMeanUtil(resultGMM.minimizer, datalist, delta_ini);\nbeta_hat = (\n    (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ \n    (datalist.X1' * datalist.Z * W * datalist.Z' * delta)\n);\n\n\nXi = delta - X1 * beta_hat;\nOmega_hat = reduce(+, Z[i,:] * Z[i,:]' .* Xi[i]^2 ./ N for i = 1:N);\nDdelta = ForwardDiff.jacobian(\n    x -> delta_ini = calculateMeanUtil(x, datalist, delta), \n    resultGMM.minimizer\n    );\nG = Z' * hcat(- X1, Ddelta) ./ N;\nAsyVarMat = (G' * W * G) \\ G' * W * Omega_hat * W * G * inv(G' * W * G);\nAse = sqrt.(diag(AsyVarMat) ./ N);\nDataFrame(\n    Var = [\n        \"Const\", \"Price\", \"Fuel Efficiency\", \"hppw\", \"size\", \n        \"capacity_d\", \"FuelRegular_d\", \"Foreign_d\",\n        \"year_2007\", \"year_2008\", \"year_2009\", \n        \"year_2010\", \"year_2011\", \"year_2012\", \n        \"year_2013\", \"year_2014\", \"year_2015\", \"year_2016\", \n        \"random_price\"\n        ],\n    Est = vcat(beta_hat, resultGMM.minimizer),\n    se = Ase\n)\n\n\n19×3 DataFrameRowVarEstseStringFloat64Float641Const-13.90270.5685532Price-2.27820.6602783Fuel Efficiency0.1966780.0126334hppw14.67053.612495size0.555190.07666446capacity_d-0.3230590.1390027FuelRegular_d-1.139950.2920498Foreign_d1.043150.194869year_2007-0.8361530.17655910year_2008-0.7042570.16922811year_2009-0.8563190.16901212year_2010-0.09763510.15240213year_2011-0.2540890.15260414year_2012-0.4873420.1641115year_2013-0.6251380.16678516year_2014-1.049740.18015717year_2015-1.151210.17902518year_2016-1.25020.18026419random_price0.700290.248176\n\n\n\nmarket2016Index = data.year .== 2016;\ndata_2016 = data[market2016Index, :];\n\n@time elasmat_2016 = calculateElasticity(\n    data_2016.price,\n    X2[market2016Index, :],\n    beta_hat,\n    resultGMM.minimizer,\n    randomDrawMat,\n    delta[market2016Index]\n);\n\n  0.365113 seconds (810.67 k allocations: 62.944 MiB, 5.17% gc time, 89.56% compilation time)"
  },
  {
    "objectID": "demand_estimation_merger.html#section-2",
    "href": "demand_estimation_merger.html#section-2",
    "title": "4  応用編",
    "section": "4.4 5",
    "text": "4.4 5\n\nPricevec_2016 = data_2016.price;\nSharevec_2016 = data_2016.share;\n\nXi_2016 = Xi[data.year .== 2016];\nOwnership_2016 = data_2016.Maker .== permutedims(data_2016.Maker);\nDerivative_2016 = - elasmat_2016 .* Sharevec_2016' ./ Pricevec_2016;\nDelta_2016 = Derivative_2016 .* Ownership_2016;\nMarginal_Cost_2016 = Pricevec_2016 - (Delta_2016 \\ Sharevec_2016);\npred_mc_df = DataFrame(\n    Maker = data_2016.Maker, \n    Name = data_2016.Name, \n    Price = data_2016.price,\n    MC = Marginal_Cost_2016,\n    Margin = (data_2016.price .- Marginal_Cost_2016) ./ data_2016.price\n);\nfirst(pred_mc_df, 10)\n\n\n10×5 DataFrameRowMakerNamePriceMCMarginString15String31Float64Float64Float641AudiA3シリーズ3.282.417260.2630312AudiA4シリーズ5.183.740930.2778123BMWミニ2.41.70010.2916264BMW1シリーズ3.12.271910.2671275BMWX13.672.713450.260646BMW2シリーズ3.812.817960.2603787BMW3シリーズ4.493.299240.2652028Daihatsuミラ0.8850.3790430.5717039Daihatsuムーヴ1.1340.6012330.46981210Daihatsuブーン1.150.6154430.464832\n\n\n\nhistogram(pred_mc_df.Margin, bins = 40, legend = false)"
  },
  {
    "objectID": "demand_estimation_merger.html#section-3",
    "href": "demand_estimation_merger.html#section-3",
    "title": "4  応用編",
    "section": "4.5 6",
    "text": "4.5 6\n\ndata_2016 = leftjoin(data_2016, pred_mc_df, on = [\"Maker\", \"Name\"]);\ndropmissing!(data_2016);\n\ndata_2016[data_2016.Maker .== \"Honda\", :Maker] .= \"Nippyo\";\ndata_2016[data_2016.Maker .== \"Nissan\", :Maker] .= \"BrandA\";\ndata_2016[data_2016.Maker .== \"Subaru\", :Maker] .= \"BrandB\";\ndata_2016[data_2016.Maker .== \"Toyota\", :Maker] .= \"BrandC\";\n\ndata_2016[!, :MakerNippyoA] = data_2016[:, :Maker];\ndata_2016[!, :MakerNippyoB] = data_2016[:, :Maker];\ndata_2016[in([\"Nippyo\", \"BrandA\"]).(data_2016[:, :Maker]), :MakerNippyoA] .= \"NippyoA\";\ndata_2016[in([\"Nippyo\", \"BrandB\"]).(data_2016[:, :Maker]), :MakerNippyoB] .= \"NippyoB\";\n\nOwnership_true = data_2016.Maker .== permutedims(data_2016.Maker);\nOwnership_NippyoA = data_2016.MakerNippyoA .== permutedims(data_2016.MakerNippyoA);\nOwnership_NippyoB = data_2016.MakerNippyoB .== permutedims(data_2016.MakerNippyoB);"
  },
  {
    "objectID": "demand_estimation_merger.html#section-4",
    "href": "demand_estimation_merger.html#section-4",
    "title": "4  応用編",
    "section": "4.6 6.4",
    "text": "4.6 6.4\n\nmc = data_2016.MC;\ndatalist_2016 = datalist_struct(\n    X1[market2016Index, :],\n    X2[market2016Index, :],\n    Z[market2016Index, :],\n    data_2016.share,\n    data_2016.year,\n    data_2016.logit_share,\n    datalist.randomDrawMat,\n    datalist.marketIndexMat[market2016Index, :]\n);"
  },
  {
    "objectID": "demand_estimation_merger.html#section-5",
    "href": "demand_estimation_merger.html#section-5",
    "title": "4  応用編",
    "section": "4.7 6.5",
    "text": "4.7 6.5\n\np_NippyoA = calculateEquilibriumPrice(\n    datalist_2016,\n    data_2016.price,\n    Ownership_NippyoA,\n    beta_hat,\n    resultGMM.minimizer,\n    mc,\n    Xi_2016\n);\n\np_NippyoB = calculateEquilibriumPrice(\n    datalist_2016,\n    data_2016.price,\n    Ownership_NippyoB,\n    beta_hat,\n    resultGMM.minimizer,\n    mc,\n    Xi_2016\n);"
  },
  {
    "objectID": "demand_estimation_merger.html#section-6",
    "href": "demand_estimation_merger.html#section-6",
    "title": "4  応用編",
    "section": "4.8 7",
    "text": "4.8 7"
  },
  {
    "objectID": "demand_estimation_merger.html#section-7",
    "href": "demand_estimation_merger.html#section-7",
    "title": "4  応用編",
    "section": "4.9 7.1",
    "text": "4.9 7.1\n\nmerger_sim_df = DataFrame(\n    Maker = data_2016.Maker, \n    Name = data_2016.Name, \n    Price_A = (p_NippyoA .- data_2016.price) ./ data_2016.price .* 100.0,\n    Share_A = (simulateMarketShare(\n                datalist_2016,\n                p_NippyoA,\n                beta_hat,\n                resultGMM.minimizer,\n                Xi_2016\n            ) .- data_2016.share) ./ data_2016.share .* 100.0,\n    Price_B = (p_NippyoB .- data_2016.price) ./ data_2016.price .* 100.0,\n    Share_B = (simulateMarketShare(\n                datalist_2016,\n                p_NippyoB,\n                beta_hat,\n                resultGMM.minimizer,\n                Xi_2016\n            ) .- data_2016.share) ./ data_2016.share .* 100.0,\n);\n\nmerger_sim_df[in([\"Nippyo\", \"BrandA\", \"BrandB\", \"BrandC\"]).(merger_sim_df.Maker), :]\n\n\n92×6 DataFrame67 rows omittedRowMakerNamePrice_AShare_APrice_BShare_BString15String31Float64Float64Float64Float641NippyoN-WGN0.541509-1.131540.205652-0.430362NippyoN-ONE0.53828-1.140050.204763-0.4343453NippyoN-BOX0.526869-1.174710.201748-0.4506354Nippyoフィット0.523412-1.187010.200885-0.4564445Nippyoバモス0.515992-1.217490.199145-0.47096Nippyoシャトル0.497664-1.351510.196526-0.53547Nippyoグレイス0.49624-1.374680.196691-0.5466948Nippyoフリード0.49438-1.429580.197626-0.5736019Nippyoヴェゼル0.49419-1.446490.198051-0.58193110NippyoS6600.494207-1.471870.198799-0.59446311Nippyoステップワゴン0.499161-1.601880.204403-0.65920112NippyoCR-V0.50524-1.678130.208852-0.69748213Nippyoジェイド0.507676-1.703120.210473-0.710059⋮⋮⋮⋮⋮⋮⋮81BrandCエスクァイア0.005198140.05002990.002336690.020408682BrandCハイエースワゴン0.005181980.05049950.002325830.020635783BrandCハリアー0.005148660.05139390.002302890.021070984BrandCアルファード0.00495420.05519040.002162160.02295885BrandCヴェルファイア0.00495420.05519040.002162160.02295886BrandCカムリ0.004948050.05528340.002157630.023005187BrandCFJクルーザー0.004927890.05558030.002142760.023155888BrandCエスティマ0.004907640.0558670.002127790.023301889BrandCSAI0.004885270.05617130.002111250.023457290BrandCクラウン0.004417960.06074070.001763950.02585891BrandCランドクルーザー0.002765480.06876520.0005327150.030472792BrandCセンチュリー-0.004203060.0562352-0.003420090.0171898"
  },
  {
    "objectID": "demand_estimation_merger.html#section-8",
    "href": "demand_estimation_merger.html#section-8",
    "title": "4  応用編",
    "section": "4.10 7.2",
    "text": "4.10 7.2\n\nOwnership_2016_A = data_2016.MakerNippyoA .== permutedims(data_2016.MakerNippyoA);\nDerivative_2016_A = - elasmat_2016 .* Sharevec_2016' ./ Pricevec_2016;\nDelta_2016_A = Derivative_2016_A .* Ownership_2016_A;\nmc_NippyoA_pfix = Pricevec_2016 - (Delta_2016_A \\ Sharevec_2016);\n\nOwnership_2016_B = data_2016.MakerNippyoB .== permutedims(data_2016.MakerNippyoB);\nDerivative_2016_B = - elasmat_2016 .* Sharevec_2016' ./ Pricevec_2016;\nDelta_2016_B = Derivative_2016_B .* Ownership_2016_B;\nmc_NippyoB_pfix = Pricevec_2016 - (Delta_2016_B \\ Sharevec_2016);\n\nmc_sim_df = DataFrame(\n    Maker = data_2016.Maker, \n    Name = data_2016.Name, \n    Nippyo_and_Brand_A = (mc_NippyoA_pfix .- mc) ./ mc .* 100.0,\n    Nippyo_and_Brand_B = (mc_NippyoB_pfix .- mc) ./ mc .* 100.0,\n);\n\nmc_sim_df[in([\"Nippyo\", \"BrandA\", \"BrandB\", \"BrandC\"]).(mc_sim_df.Maker), :]\n\n\n92×4 DataFrame67 rows omittedRowMakerNameNippyo_and_Brand_ANippyo_and_Brand_BString15String31Float64Float641NippyoN-WGN-0.91733-0.3492872NippyoN-ONE-0.900594-0.3434753NippyoN-BOX-0.842563-0.3234514Nippyoフィット-0.825194-0.3175065Nippyoバモス-0.787848-0.3048226Nippyoシャトル-0.685154-0.2712147Nippyoグレイス-0.673848-0.2677298Nippyoフリード-0.651828-0.2611929Nippyoヴェゼル-0.646177-0.25958610NippyoS660-0.638542-0.25748311Nippyoステップワゴン-0.611683-0.25112212NippyoCR-V-0.60284-0.24986913Nippyoジェイド-0.600761-0.249749⋮⋮⋮⋮⋮81BrandCエスクァイア0.00.082BrandCハイエースワゴン0.00.083BrandCハリアー0.00.084BrandCアルファード0.00.085BrandCヴェルファイア0.00.086BrandCカムリ0.00.087BrandCFJクルーザー0.00.088BrandCエスティマ0.00.089BrandCSAI0.00.090BrandCクラウン0.00.091BrandCランドクルーザー0.00.092BrandCセンチュリー0.00.0"
  },
  {
    "objectID": "demand_estimation_merger.html#section-9",
    "href": "demand_estimation_merger.html#section-9",
    "title": "4  応用編",
    "section": "4.11 7.4",
    "text": "4.11 7.4\n\nCS_2016 = calculateCS(\n    datalist_2016, \n    data_2016.price, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016,\n    data_2016.HH[1]\n);\n\nCS_NippyoA = calculateCS(\n    datalist_2016, \n    p_NippyoA, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016,\n    data_2016.HH[1]\n);\n\nCS_NippyoB = calculateCS(\n    datalist_2016, \n    p_NippyoB, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016,\n    data_2016.HH[1]\n);\n\nCV_NippyoA = CS_NippyoA - CS_2016;\nCV_NippyoB = CS_NippyoB - CS_2016;\n\n\npro_rev_2016 = calculateProfit(\n    data_2016.Maker,\n    data_2016.price,\n    mc,\n    data_2016.share,\n    data_2016.HH\n);\npro_rev_NippyoA = calculateProfit(\n    data_2016.Maker,\n    p_NippyoA,\n    mc,\n    simulateMarketShare(\n                datalist_2016,\n                p_NippyoA,\n                beta_hat,\n                resultGMM.minimizer,\n                Xi_2016,\n            ),\n    data_2016.HH\n);\npro_rev_NippyoB = calculateProfit(\n    data_2016.Maker,\n    p_NippyoB,\n    mc,\n    simulateMarketShare(\n                datalist_2016,\n                p_NippyoB,\n                beta_hat,\n                resultGMM.minimizer,\n                Xi_2016,\n            ),\n    data_2016.HH\n);\n\nTS_change_NippyoA = CV_NippyoA + sum(pro_rev_NippyoA.profit - pro_rev_2016.profit);\nTS_change_NippyoB = CV_NippyoB + sum(pro_rev_NippyoB.profit - pro_rev_2016.profit);\n\n\nDataFrame(\n    Measure = [\"Consumer surplus\", \"Total welfare\"],\n    Nippyo_and_Brand_A = [CV_NippyoA, TS_change_NippyoA],\n    Nippyo_and_Brand_B = [CV_NippyoB, TS_change_NippyoB],\n)\n\n\n2×3 DataFrameRowMeasureNippyo_and_Brand_ANippyo_and_Brand_BStringFloat64Float641Consumer surplus-11740.6-4610.72Total welfare-10457.5-4060.65\n\n\n\nresult_df = DataFrame(\n    Maker = pro_rev_2016.Maker,\n    Profits_NippyoA = pro_rev_NippyoA.profit - pro_rev_2016.profit,\n    Revenue_NippyoA = pro_rev_NippyoA.revenue - pro_rev_2016.revenue,\n    Profits_NippyoB = pro_rev_NippyoB.profit - pro_rev_2016.profit,\n    Revenue_NippyoB = pro_rev_NippyoB.revenue - pro_rev_2016.revenue,\n);\n\ntotal_df = combine(result_df, 2:5 .=> sum .=> names(result_df)[2:5]);\ntotal_df[!, :Maker] .= \"Total\"\nappend!(result_df, total_df)\n\n\n16×5 DataFrameRowMakerProfits_NippyoARevenue_NippyoAProfits_NippyoBRevenue_NippyoBString15Float64Float64Float64Float641Audi11.714243.25624.8104918.59272BMW39.1788134.84516.362656.9963Daihatsu115.249224.04646.395888.99224Fiat1.62324.504650.6712691.834745Lexas65.7821239.71624.648108.3376Matsuda63.1001164.76625.972367.05477Mercedes57.4931211.16621.548195.63448Mitsubishi21.709454.60528.9025922.19919Suzuki120.615231.99548.531192.183610Volkswagen20.605564.27288.6092326.612511Volvo9.6295835.02134.0138714.929912Nippyo83.803-9633.8144.2022-3841.8413BrandA14.4171-10950.459.5345154.20114BrandB58.2012166.716-12.6581-5066.2415BrandC599.971536.03248.507629.79916Total1283.09-17473.3550.051-7530.71"
  },
  {
    "objectID": "demand_estimation_merger.html#section-10",
    "href": "demand_estimation_merger.html#section-10",
    "title": "4  応用編",
    "section": "4.12 8",
    "text": "4.12 8"
  },
  {
    "objectID": "demand_estimation_merger.html#section-11",
    "href": "demand_estimation_merger.html#section-11",
    "title": "4  応用編",
    "section": "4.13 8.2",
    "text": "4.13 8.2\n\ncostReducingFirms = [\"Nippyo\", \"Brand_A\"];\ndistance = 100\nlambda = 1e-6;\nmax_cost_red = 1.0;\nmin_cost_red = 0.0;\n\niter = 1;\n\n\n@time while (distance > lambda) & (iter < 100)\n    \n    mid_cost_red = (max_cost_red + min_cost_red) / 2.0;\n    \n    mid_eval = calculateTSChangeByCostReduction(\n        mid_cost_red,\n        costReducingFirms,\n        Ownership_NippyoA,\n        data_2016,\n        mc,\n        datalist_2016,\n        beta_hat,\n        resultGMM.minimizer,\n        data_2016.HH,\n        p_NippyoA,\n        pro_rev_2016,\n        CS_2016,\n        Xi_2016\n    );\n    \n    if mid_eval > 0\n        min_cost_red = mid_cost_red;\n    else\n        max_cost_red = mid_cost_red;\n    end\n    \n    distance = abs(mid_eval - 0);\n    iter += 1\n    \nend\ncost_red_NippyoA = (min_cost_red + min_cost_red) / 2.0;\n\n\nmc_NippyoA_TSfix = mc[:];\nmc_NippyoA_TSfix[in(costReducingFirms).(data_2016.Maker)] .*= cost_red_NippyoA;\n\n\np_NippyoA_TSfix = calculateEquilibriumPrice(\n    datalist_2016, \n    p_NippyoA, \n    Ownership_NippyoA, \n    beta_hat, \n    resultGMM.minimizer, \n    mc_NippyoA_TSfix, \n    Xi_2016\n    );\nshare_NippyoA_TSfix = simulateMarketShare(\n    datalist_2016, \n    p_NippyoA_TSfix, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016\n    );"
  },
  {
    "objectID": "demand_estimation_merger.html#section-12",
    "href": "demand_estimation_merger.html#section-12",
    "title": "4  応用編",
    "section": "4.14 8.3",
    "text": "4.14 8.3\n\ncostReducingFirms = [\"Nippyo\", \"Brand_B\"];\ndistance = 100\nlambda = 1e-6;\nmax_cost_red = 1.0;\nmin_cost_red = 0.0;\n\niter = 1;\n\n\n@time while (distance > lambda) & (iter < 100)\n    \n    mid_cost_red = (max_cost_red + min_cost_red) / 2.0;\n    \n    mid_eval = calculateTSChangeByCostReduction(\n        mid_cost_red,\n        costReducingFirms,\n        Ownership_NippyoB,\n        data_2016,\n        mc,\n        datalist_2016,\n        beta_hat,\n        resultGMM.minimizer,\n        data_2016.HH,\n        p_NippyoB,\n        pro_rev_2016,\n        CS_2016,\n        Xi_2016\n    );\n    \n    if mid_eval > 0\n        min_cost_red = mid_cost_red;\n    else\n        max_cost_red = mid_cost_red;\n    end\n    \n    distance = abs(mid_eval - 0);\n    iter += 1\n    \nend\ncost_red_NippyoB = (min_cost_red + min_cost_red) / 2.0;\n\n\nmc_NippyoB_TSfix = mc[:];\nmc_NippyoB_TSfix[in(costReducingFirms).(data_2016.Maker)] .*= cost_red_NippyoB;\n\n\np_NippyoB_TSfix = calculateEquilibriumPrice(\n    datalist_2016, \n    p_NippyoB, \n    Ownership_NippyoB,\n    beta_hat, \n    resultGMM.minimizer, \n    mc_NippyoB_TSfix, \n    Xi_2016\n    );\nshare_NippyoB_TSfix = simulateMarketShare(\n    datalist_2016, \n    p_NippyoB_TSfix, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016\n    );\n\n\n[1-cost_red_NippyoA 1-cost_red_NippyoB] .* 100\n\n1×2 Matrix{Float64}:\n 1.46299  0.566009"
  },
  {
    "objectID": "demand_estimation_merger.html#section-13",
    "href": "demand_estimation_merger.html#section-13",
    "title": "4  応用編",
    "section": "4.15 8.5",
    "text": "4.15 8.5\n\npro_rev_NippyoA_rc = calculateProfit(\n    data_2016.Maker,\n    p_NippyoA_TSfix,\n    mc_NippyoA_TSfix,\n    share_NippyoA_TSfix,\n    data_2016.HH\n);\npro_rev_NippyoB_rc = calculateProfit(\n    data_2016.Maker,\n    p_NippyoB_TSfix,\n    mc_NippyoB_TSfix,\n    share_NippyoB_TSfix,\n    data_2016.HH\n);\n\nresult2_df = DataFrame(\n    Maker = pro_rev_2016.Maker,\n    Profits_NippyoA = pro_rev_NippyoA_rc.profit - pro_rev_2016.profit,\n    Revenue_NippyoA = pro_rev_NippyoA_rc.revenue - pro_rev_2016.revenue,\n    Profits_NippyoB = pro_rev_NippyoB_rc.profit - pro_rev_2016.profit,\n    Revenue_NippyoB = pro_rev_NippyoB_rc.revenue - pro_rev_2016.revenue,\n);\n\ntotal2_df = combine(result2_df, 2:5 .=> sum .=> names(result2_df)[2:5]);\ntotal2_df[!, :Maker] .= \"Total\";\nappend!(result2_df, total2_df)\n\n\n16×5 DataFrameRowMakerProfits_NippyoARevenue_NippyoAProfits_NippyoBRevenue_NippyoBString15Float64Float64Float64Float641Audi0.7932760.201650.5825071.910382BMW1.30459-0.2818391.692044.626263Daihatsu-2.32452-5.485680.798079-0.04274044Fiat-0.0129623-0.08230410.03699680.05606085Lexas10.4042-3.421773.2377514.16496Matsuda-0.530161-2.95171.304332.018097Mercedes8.89097-3.778762.7546512.348Mitsubishi-0.20892-0.9823510.4048850.6434389Suzuki-2.43626-5.654620.8083640.00019545710Volkswagen0.103826-0.7637810.6639971.3992611Volvo0.4624640.0981060.4639181.3970512Nippyo10318.311771.13965.294405.3413BrandA-134.893-11555.43.094545.4867814BrandB-0.0324771-2.34426-35.6801-5169.2515BrandC1.32756-25.899216.480124.157616Total10201.1164.3833961.93-695.752"
  },
  {
    "objectID": "demand_estimation_merger.html#section-14",
    "href": "demand_estimation_merger.html#section-14",
    "title": "4  応用編",
    "section": "4.16 8.6",
    "text": "4.16 8.6\n\n@printf(\n    \"Percent change in profit by Brand A merger: %.3f \\n\", \n    (sum(pro_rev_NippyoA_rc.profit) - sum(pro_rev_2016.profit)) / sum(pro_rev_2016.profit) * 100.0\n    )\n@printf(\n    \"Percent change in revenue by brand A merger: %.3f \\n\", \n    (sum(pro_rev_NippyoA_rc.revenue) - sum(pro_rev_2016.revenue)) / sum(pro_rev_2016.revenue) * 100.0\n    )\n@printf(\n    \"Percent change in profit by Brand B merger: %.3f \\n\", \n    (sum(pro_rev_NippyoB_rc.profit) - sum(pro_rev_2016.profit)) / sum(pro_rev_2016.profit) * 100.0\n    )\n@printf(\n    \"Percent change in revenue by Brand B merger: %.3f \\n\", \n    (sum(pro_rev_NippyoB_rc.revenue) - sum(pro_rev_2016.revenue)) / sum(pro_rev_2016.revenue) * 100.0\n    )\n\nPercent change in profit by Brand A merger: 0.384 \nPercent change in revenue by brand A merger: 0.002 \nPercent change in profit by Brand B merger: 0.149 \nPercent change in revenue by Brand B merger: -0.009"
  },
  {
    "objectID": "entry_exit_basic.html#section",
    "href": "entry_exit_basic.html#section",
    "title": "5  基礎編",
    "section": "5.1 4",
    "text": "5.1 4\n\nN_max = 6;\ndataset[dataset.NumMRI .> N_max, :NumMRI] .= N_max;\n\n\nfunction obj(\n        params,\n        dataset,\n        N_max\n    )\n\n    alpha1 = params[1];\n    alpha2 = -params[2:N_max];\n    alpha = vcat(alpha1, alpha2);\n    gamma = params[N_max + 1];\n    \n    NumMRI = dataset.NumMRI;\n    M = nrow(dataset);\n    pop = dataset.Pop .* ones((1, N_max));\n    \n    V = LowerTriangular(ones(N_max) .* alpha');\n        \n    VV = (V * ones(N_max, M))';\n    \n    F = gamma .* ones((M, N_max));\n    \n    profit = pop .* VV .- F;\n    \n    phi = cdf.(Normal(0, 1), profit);\n    \n    mat = hcat(ones(M) .- phi[:, 1], phi[:, 1:(N_max - 1)] .- phi[:, 2:N_max], phi[:, N_max]);\n    \n    ml = log.(reduce(.+, [(dataset.NumMRI .== i) .* mat[:, (i + 1)] for i = 0:N_max]));\n    \n    return - sum(ml) / M\n    \nend\n\nobj (generic function with 1 method)\n\n\n\nobj_for_Optim = TwiceDifferentiable(\n    x -> obj(x, dataset, N_max),\n    ones(N_max + 1);\n    autodiff = :forward\n);\n@time optim_res = optimize(\n    obj_for_Optim,\n    zeros(N_max + 1),\n    repeat([Inf], N_max + 1),\n    ones(N_max + 1),\n#     Optim.Options(show_trace = true)\n);\n\n  6.414355 seconds (15.38 M allocations: 2.027 GiB, 6.45% gc time, 95.10% compilation time)\n\n\n\nse = sqrt.(diag(inv(obj_for_Optim.H) ./ M));\nDataFrame(\n    estimates = optim_res.minimizer,\n    se = se\n)\n\n\n7×2 DataFrameRowestimatesseFloat64Float64154.62361.52851233.54331.361838.083460.48228444.236550.32650952.512150.26024161.632970.21518671.390410.046226"
  },
  {
    "objectID": "entry_exit_basic.html#section-1",
    "href": "entry_exit_basic.html#section-1",
    "title": "5  基礎編",
    "section": "5.2 5",
    "text": "5.2 5\n\nalpha_est = optim_res.minimizer[1:N_max];\ngamma_est = optim_res.minimizer[N_max + 1];\n\nEntryThreshold = zeros(Int64, (N_max, 2));\n\ndeno = alpha_est[1];\nEntryThreshold[1,:] .= round(gamma_est / deno .* 1e+6);\nfor i = 2:N_max\n    deno = deno - alpha_est[i];\n    EntryThreshold[i, :] = round.([gamma_est / deno .* 1e+6, gamma_est / deno .* 1e+6 / i]);\nend\n\nEntryThreshold    \n\n6×2 Matrix{Int64}:\n  25454  25454\n  65958  32979\n 106981  35660\n 158717  39679\n 222532  44506\n 301269  50212"
  },
  {
    "objectID": "entry_exit_application.html#section",
    "href": "entry_exit_application.html#section",
    "title": "6  応用編",
    "section": "6.4 6.2",
    "text": "6.4 6.2\n\nberry_est = minx;\nalpha_est = berry_est[1:8];\nbeta_est = berry_est[9:12];\ndelta_est = berry_est[13];\nrho_est = berry_est[14];\n\nprofitExcludeCompetition = calculateProfitExcludeCompetition(\n    berry_est,\n    data_processed,\n    u_m0,\n    u_mIm\n);\n\neach_entry_mat = calculateEquilibriumNumEntry(\n    data_processed,\n    delta_est,\n    profitExcludeCompetition\n);\n\nentryProb = mean(simulateEntryByOrder(\n    delta_est,\n    cityIndex,\n    profitExcludeCompetition,\n    each_entry_mat\n), dims = 2)[:, 1];\n\n\nentryPred = entryProb .> 0.5;\n\ndata_predicted = copy(data_processed);\ndata_predicted[!, :entryProb] = entryProb;\ndata_predicted[!, :entryPred] = entryPred;\ndata_predicted_agg = combine(\n    groupby(data_predicted, :CityCode),\n    :MRIOwnDum => sum => :Actual,\n    :entryPred => sum => :Predict\n);\n\ndata_predicted_agg = stack(data_predicted_agg, [:Actual, :Predict]);\ndata_predicted_sum = combine(groupby(data_predicted_agg, [:variable, :value]), nrow);\nsort!(data_predicted_sum, [:variable, :value]);\ngroupedbar(\n    data_predicted_sum.nrow, \n    group = data_predicted_sum.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_predicted[!, :Top25pct_NumBeds] = (\n    data_processed.LogNumBeds .>= log(1.2)\n);\ndata_predicted[!, :NotNeuro] = (\n    (data_processed.DepNeurology .!= 1) .&\n    (data_processed.DepNeurosurgery .!= 1)\n);\nlistVarsShort = [\n    \"Kyukyu\", \"Sien\", \"Hyoka\", \"DepNeurology\",\n    \"DepNeurosurgery\", \"Top25pct_NumBeds\", \n    \"ZeroBedDum\", \"DaigakuDum\", \"NotNeuro\"\n]\n\ntableActPred = vcat([\n        sum.(\n            eachcol(data_predicted[\n                data_predicted[:, variable] .== 1, \n                [:MRIOwnDum, :entryPred]\n                ])\n        )'\n        for variable in listVarsShort\n    ]...);\n\ndfActPred = vcat(\n    DataFrame(\n        Actual = sum(data_predicted.MRIOwnDum),\n        Predict = sum(data_predicted.entryPred)\n    ),\n    DataFrame(\n        Actual = tableActPred[:, 1],\n        Predict = tableActPred[:, 2]\n    )\n);\n\ndfActPredStack = stack(dfActPred, [:Actual, :Predict]);\ndfActPredStack[:, :category] = repeat([\"All\"; listVarsShort], 2);\ngroupedbar(\n    dfActPredStack.category, \n    dfActPredStack.value,\n    group = dfActPredStack.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    lw = 0,\n    xrotation = 30\n)"
  },
  {
    "objectID": "entry_exit_application.html#section-1",
    "href": "entry_exit_application.html#section-1",
    "title": "6  応用編",
    "section": "6.2 5",
    "text": "6.2 5\n\ndata_processed_pre = dropmissing(data_cleaned[:, [\n            :CityCode, :Kyukyu, :Kinou, :Sien, :Hyoka,\n            :DepNeurology, :DepNeurosurgery, :LogNumBeds,\n            :ZeroBedDum, :DaigakuDum,\n            :Menseki, :LogPop, :LogIncome, :MRIOwnDum\n            ]]);\nfirst(data_processed_pre, 5)\n\n\n5×14 DataFrameRowCityCodeKyukyuKinouSienHyokaDepNeurologyDepNeurosurgeryLogNumBedsZeroBedDumDaigakuDumMensekiLogPopLogIncomeMRIOwnDumInt64Int64Int64Int64Int64Int64Int64Float64BoolBoolFloat64Float64Float64Int64111011000000.891998falsefalse0.4642-1.513271.104261211010000000.593327falsefalse0.4642-1.513271.104261311011000000.10436falsefalse0.4642-1.513271.104261411011000110.300105falsefalse0.4642-1.513271.104261511010000000.920283falsefalse0.4642-1.513271.104261\n\n\n\nRandom.seed!(123)\ndata_processed = processDataForBerryEst(data_processed_pre);\nfirst(data_processed, 5)\n\n\n5×18 DataFrameRowCityCodeKyukyuKinouSienHyokaDepNeurologyDepNeurosurgeryLogNumBedsZeroBedDumDaigakuDumMensekiLogPopLogIncomeMRIOwnDumTieEntryOrdernumPotenHosnumEntryObsEntryOrderIdInt64Int64Int64Int64Int64Int64Int64Float64BoolBoolFloat64Float64Float64Int64Float64Int64Int64Int64111011000112.19165falsetrue0.4642-1.513271.1042610.69220941171211011000112.0931falsefalse0.4642-1.513271.1042610.032096741172311010000101.61939falsefalse0.4642-1.513271.1042610.13655141173411010000101.59939falsefalse0.4642-1.513271.1042610.33415241174511010000001.14103falsefalse0.4642-1.513271.1042610.42732841175\n\n\n\nnumPotenHos_max = 4;\ndata_processed = data_processed[\n    data_processed.EntryOrderId .<= numPotenHos_max, \n    :];\ntransform!(\n    groupby(data_processed, :CityCode),\n    :MRIOwnDum => sum => :numEntryObs,\n    nrow => :numPotenHos\n);\ndata_processed[!, :Const] .= 1;\nvcat(\n    calculateShareOwnMRI(data_processed),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :Kyukyu)[\n            dropmissing(data_processed, :Kyukyu).Kyukyu .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :Sien)[\n            dropmissing(data_processed, :Sien).Sien .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :Hyoka)[\n            dropmissing(data_processed, :Hyoka).Hyoka .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :DepNeurology)[\n            dropmissing(data_processed, :DepNeurology).DepNeurology .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :DepNeurosurgery)[\n            dropmissing(data_processed, :DepNeurosurgery).DepNeurosurgery .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :LogNumBeds)[\n            dropmissing(data_processed, :LogNumBeds).LogNumBeds .>= log(1.2), \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :DaigakuDum)[\n            dropmissing(data_processed, :DaigakuDum).DaigakuDum .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :ZeroBedDum)[\n            dropmissing(data_processed, :ZeroBedDum).ZeroBedDum .== 1, \n            :]\n            ),\n)\n\n9×3 Matrix{Float64}:\n 4112.0  2246.0  54.62\n 2476.0  1745.0  70.48\n  151.0   141.0  93.38\n 1422.0  1097.0  77.14\n 1276.0  1014.0  79.47\n 1697.0  1472.0  86.74\n 1857.0  1628.0  87.67\n  125.0   115.0  92.0\n  646.0    41.0   6.35\n\n\n\nnumSim = 100;\n\nuniqueCityCode = unique(data_processed.CityCode);\nnumCity = length(uniqueCityCode);\nnumHos = nrow(data_processed);\nnumEntryObs = combine(\n    groupby(data_processed, :CityCode),\n    :MRIOwnDum => sum => :numEntryObs\n).numEntryObs;\n\ncityIndex = data_processed.CityCode .== uniqueCityCode';\n\n\nu_m0 = cityIndex * randn(numCity, numSim);\nu_mIm = randn(numHos, numSim);\n\n\nparam_init = [\n    -0.612340533,   -5.525423772,   -0.505275676,   \n    -0.32531026,    -1.04162392,    -0.991878025,   \n    -3.87040966,    -1.272714254,   2.684741676,    \n    0.040555764,    0.426448612,    -1.399627382,   \n    0.990975782,    0.958075433\n];\n\n\nfunction obj_for_Optim(x::Vector, grad::Vector)\n    if length(grad) != 0\n        ForwardDiff.gradient!(\n            grad, \n            x -> calculateBerryObjectiveAtCityLevel(\n                x, \n                data_processed, \n                u_m0, \n                u_mIm, \n                numEntryObs\n                ), \n            x\n            )\n    end\n    return calculateBerryObjectiveAtCityLevel(\n        x, \n        data_processed, \n        u_m0, \n        u_mIm, \n        numEntryObs\n    )\nend\n\nopt = NLopt.Opt(:LN_NELDERMEAD, length(param_init))\nopt.lower_bounds = [repeat([-Inf], 13); -1.0]\nopt.upper_bounds = [repeat([Inf], 13); 1.0]\n\nopt.min_objective = obj_for_Optim;\n@time (minf, minx, ret) = NLopt.optimize(opt, param_init)\n\n@printf(\n    \"Minimized objective value: %.3f \\n\", \n    minf\n    )\n[param_init minx]\n\n 19.876148 seconds (36.69 M allocations: 29.563 GiB, 10.75% gc time, 8.82% compilation time)\nMinimized objective value: 0.374 \n\n\n14×2 Matrix{Float64}:\n -0.612341   -0.655829\n -5.52542    -8.41047\n -0.505276   -0.491684\n -0.32531    -0.44966\n -1.04162    -1.25152\n -0.991878   -1.0654\n -3.87041    -3.52228\n -1.27271    -1.11907\n  2.68474     2.58767\n  0.0405558   0.033967\n  0.426449    0.394342\n -1.39963    -1.44356\n  0.990976    1.08858\n  0.958075    0.963786\n\n\n\nnumBootstrap = 100;\nbootEstMat = zeros(length(minx), numBootstrap)\n\n@time for bootIndex in 1:numBootstrap\n\n    bootCitySample = sample(uniqueCityCode, numCity, replace = true);\n    df_boot = reduce(\n        vcat,\n        [\n            transform(\n                data_processed[\n                    data_processed.CityCode .== bootCitySample[city], \n                    :],\n                :CityCode => (x -> city) => :CityCode\n            )\n            for city in 1:numCity\n        ]\n    );\n\n    numHos_boot = nrow(df_boot);\n\n    numEntryObs_boot = combine(\n        groupby(df_boot, :CityCode),\n        :MRIOwnDum => sum => :numEntryObs\n    ).numEntryObs;\n\n    uniqueCityCode_boot = unique(df_boot.CityCode);\n    cityIndex_boot = df_boot.CityCode .== uniqueCityCode_boot';\n\n    u_m0_boot = cityIndex_boot * randn(numCity, numSim);\n    u_mIm_boot = randn(numHos_boot, numSim);\n\n    function obj_for_Optim(x::Vector, grad::Vector)\n        if length(grad) != 0\n            ForwardDiff.gradient!(\n                grad, \n                x -> calculateBerryObjectiveAtCityLevel(\n                    x, \n                    df_boot, \n                    u_m0_boot, \n                    u_mIm_boot, \n                    numEntryObs_boot\n                    ), \n                x\n                )\n        end\n        return calculateBerryObjectiveAtCityLevel(\n            x, \n            df_boot, \n            u_m0_boot, \n            u_mIm_boot, \n            numEntryObs_boot\n            )\n    end\n\n    opt_boot = NLopt.Opt(:LN_NELDERMEAD, length(param_init))\n    opt_boot.lower_bounds = [repeat([-Inf], 13); -1.0]\n    opt_boot.upper_bounds = [repeat([Inf], 13); 1.0]\n\n    opt_boot.min_objective = obj_for_Optim;\n    (minf_boot, minx_boot, ret_boot) = NLopt.optimize(opt_boot, param_init)\n    bootEstMat[:, bootIndex] .= minx_boot;\n\nend\n\n5255.877341 seconds (3.36 G allocations: 2.938 TiB, 3.56% gc time, 0.05% compilation time: 9% of which was recompilation)\n\n\n\n[minx std(bootEstMat, dims = 2)]\n\n14×2 Matrix{Float64}:\n -0.655829  NaN\n -8.41047   NaN\n -0.491684  NaN\n -0.44966   NaN\n -1.25152   NaN\n -1.0654    NaN\n -3.52228   NaN\n -1.11907   NaN\n  2.58767   NaN\n  0.033967  NaN\n  0.394342  NaN\n -1.44356   NaN\n  1.08858   NaN\n  0.963786  NaN"
  },
  {
    "objectID": "entry_exit_application.html#section-2",
    "href": "entry_exit_application.html#section-2",
    "title": "6  応用編",
    "section": "6.3 6.2",
    "text": "6.3 6.2\n\nberry_est = minx;\nalpha_est = berry_est[1:8];\nbeta_est = berry_est[9:12];\ndelta_est = berry_est[13];\nrho_est = berry_est[14];\n\nprofitExcludeCompetition = calculateProfitExcludeCompetition(\n    berry_est,\n    data_processed,\n    u_m0,\n    u_mIm\n);\n\neach_entry_mat = calculateEquilibriumNumEntry(\n    data_processed,\n    delta_est,\n    profitExcludeCompetition\n);\n\nentryProb = mean(simulateEntryByOrder(\n    delta_est,\n    cityIndex,\n    profitExcludeCompetition,\n    each_entry_mat\n), dims = 2)[:, 1];\n\n\nentryPred = entryProb .> 0.5;\n\ndata_predicted = copy(data_processed);\ndata_predicted[!, :entryProb] = entryProb;\ndata_predicted[!, :entryPred] = entryPred;\ndata_predicted_agg = combine(\n    groupby(data_predicted, :CityCode),\n    :MRIOwnDum => sum => :Actual,\n    :entryPred => sum => :Predict\n);\n\ndata_predicted_agg = stack(data_predicted_agg, [:Actual, :Predict]);\ndata_predicted_sum = combine(groupby(data_predicted_agg, [:variable, :value]), nrow);\nsort!(data_predicted_sum, [:variable, :value]);\ngroupedbar(\n    data_predicted_sum.nrow, \n    group = data_predicted_sum.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_predicted[!, :Top25pct_NumBeds] = (\n    data_processed.LogNumBeds .>= log(1.2)\n);\ndata_predicted[!, :NotNeuro] = (\n    (data_processed.DepNeurology .!= 1) .&\n    (data_processed.DepNeurosurgery .!= 1)\n);\nlistVarsShort = [\n    \"Kyukyu\", \"Sien\", \"Hyoka\", \"DepNeurology\",\n    \"DepNeurosurgery\", \"Top25pct_NumBeds\", \n    \"ZeroBedDum\", \"DaigakuDum\", \"NotNeuro\"\n]\n\ntableActPred = vcat([\n        sum.(\n            eachcol(data_predicted[\n                data_predicted[:, variable] .== 1, \n                [:MRIOwnDum, :entryPred]\n                ])\n        )'\n        for variable in listVarsShort\n    ]...);\n\ndfActPred = vcat(\n    DataFrame(\n        Actual = sum(data_predicted.MRIOwnDum),\n        Predict = sum(data_predicted.entryPred)\n    ),\n    DataFrame(\n        Actual = tableActPred[:, 1],\n        Predict = tableActPred[:, 2]\n    )\n);\n\ndfActPredStack = stack(dfActPred, [:Actual, :Predict]);\ndfActPredStack[:, :category] = repeat([\"All\"; listVarsShort], 2);\ngroupedbar(\n    dfActPredStack.category, \n    dfActPredStack.value,\n    group = dfActPredStack.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    lw = 0,\n    xrotation = 30\n)"
  },
  {
    "objectID": "entry_exit_application.html#section-3",
    "href": "entry_exit_application.html#section-3",
    "title": "6  応用編",
    "section": "6.4 7",
    "text": "6.4 7\n\ndata_cf = copy(data_processed);\nsort!(\n    data_cf, [\n        :CityCode, :DepNeurology, :DepNeurosurgery, \n        :LogNumBeds, :TieEntryOrder\n    ], \n    rev = [false, true, true, true, true]\n    );\ntransform!(\n    groupby(data_cf, :CityCode), \n    :numPotenHos => (x -> 1:length(x)) => :EntryOrderId\n    );\n\nprofitExcludeCompetition_cf = calculateProfitExcludeCompetition(\n    berry_est,\n    data_cf,\n    u_m0,\n    u_mIm\n);\n\nprofitExcludeCompetition_cf[\n    (data_cf.DepNeurology .== 1) .| (data_cf.DepNeurosurgery .== 1), \n    :] .= 1e+5;\n\n\neach_entry_mat_cf = calculateEquilibriumNumEntry(\n    data_cf,\n    delta_est,\n    profitExcludeCompetition_cf\n);\n\nentryProb_cf = mean(simulateEntryByOrder(\n    delta_est,\n    cityIndex,\n    profitExcludeCompetition_cf,\n    each_entry_mat_cf\n), dims = 2)[:, 1];\n\n\nentryPred_cf = entryProb_cf .> 0.5;\n\ndata_predicted_cf = copy(data_cf);\ndata_predicted_cf[!, :entryProb] = entryProb_cf;\ndata_predicted_cf[!, :entryPred] = entryPred_cf;\ndata_predicted_cf_agg = combine(\n    groupby(data_predicted_cf, :CityCode),\n    :MRIOwnDum => sum => :Actual,\n    :entryPred => sum => :CounterFactual\n);\n\ndata_predicted_cf_agg = stack(data_predicted_cf_agg, [:Actual, :CounterFactual]);\ndata_predicted_cf_sum = combine(groupby(\n    vcat(\n        data_predicted_agg, \n        data_predicted_cf_agg[\n            data_predicted_cf_agg.variable .== \"CounterFactual\", \n            :]\n            ),\n    [:variable, :value]\n    ), nrow);\n\ntransform!(\n    data_predicted_cf_sum, \n    :variable => \n    (\n        x -> categorical(\n            x; ordered = true, \n            levels = [\"Actual\", \"Predict\", \"CounterFactual\"]\n            )\n            ) => \n    :variable\n    )\nsort!(data_predicted_cf_sum, [:variable, :value]);\ngroupedbar(\n    data_predicted_cf_sum.nrow, \n    group = data_predicted_cf_sum.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvcat(\n    combine(groupby(\n        data_predicted_agg, :variable\n        ), :value => sum),\n    combine(groupby(\n        data_predicted_cf_agg, :variable\n        ), :value => sum) |> \n        filter(:variable => (x -> x .== \"CounterFactual\"))\n)\n\n\n3×2 DataFrameRowvariablevalue_sumStringInt641Actual22462Predict22343CounterFactual2484\n\n\n\ndata_predicted_agg_wo_neuro = combine(\n    groupby(\n        filter(\n            [:DepNeurology, :DepNeurosurgery] => \n            ((d1, d2) -> (d1 .!= 1) .& (d2 .!= 1)), \n            data_predicted\n            ),\n        :CityCode\n        ),\n    :MRIOwnDum => sum => :Actual,\n    :entryPred => sum => :Predict\n);\n\ndata_predicted_agg_wo_neuro = stack(\n    data_predicted_agg_wo_neuro, [:Actual, :Predict]\n    );\ndata_predicted_sum_wo_neuro = combine(\n    groupby(data_predicted_agg_wo_neuro, [:variable, :value]), \n    nrow\n    );\n\ndata_predicted_cf_agg_wo_neuro = combine(\n    groupby(\n        filter(\n            [:DepNeurology, :DepNeurosurgery] => \n            ((d1, d2) -> (d1 .!= 1) .& (d2 .!= 1)), \n            data_predicted_cf\n            ),\n        :CityCode\n        ),\n    :MRIOwnDum => sum => :Actual,\n    :entryPred => sum => :CounterFactual\n);\n\ndata_predicted_cf_agg_wo_neuro = stack(\n    data_predicted_cf_agg_wo_neuro, \n    [:Actual, :CounterFactual]\n    );\n\ndata_predicted_cf_sum_wo_neuro = combine(groupby(\n    vcat(\n        data_predicted_agg_wo_neuro, \n        data_predicted_cf_agg_wo_neuro[data_predicted_cf_agg_wo_neuro.variable .== \"CounterFactual\", :]\n        ),\n    [:variable, :value]\n    ), nrow)\n\ntransform!(\n    data_predicted_cf_sum_wo_neuro, \n    :variable => \n    (x -> categorical(x; ordered = true, levels = [\"Actual\", \"Predict\", \"CounterFactual\"])) => \n    :variable\n    )\nsort!(data_predicted_cf_sum_wo_neuro, [:variable, :value]);\ngroupedbar(\n    data_predicted_cf_sum_wo_neuro.nrow, \n    group = data_predicted_cf_sum_wo_neuro.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvcat(\n    combine(groupby(\n        data_predicted_agg_wo_neuro, :variable\n        ), :value => sum),\n    combine(groupby(\n        data_predicted_cf_agg_wo_neuro, :variable\n        ), :value => sum) |> \n        filter(:variable => (x -> x .== \"CounterFactual\"))\n)\n\n\n3×2 DataFrameRowvariablevalue_sumStringInt641Actual5212Predict3673CounterFactual340\n\n\n\ndata_predicted_cf[!, :Top25pct_NumBeds] = (\n    data_predicted_cf.LogNumBeds .>= log(1.2)\n);\ndata_predicted_cf[!, :NotNeuro] = (\n    (data_predicted_cf.DepNeurology .!= 1) .&\n    (data_predicted_cf.DepNeurosurgery .!= 1)\n);\n\ntableActCounterFactual = vcat([\n        sum.(\n            eachcol(data_predicted_cf[\n                data_predicted_cf[:, variable] .== 1, \n                [:MRIOwnDum, :entryPred]\n                ])\n        )'\n        for variable in listVarsShort\n    ]...);\n\ndfActCounterFactual = vcat(\n    DataFrame(\n        Actual = sum(data_predicted_cf.MRIOwnDum),\n        CounterFactual = sum(data_predicted_cf.entryPred)\n    ),\n    DataFrame(\n        Actual = tableActCounterFactual[:, 1],\n        CounterFactual = tableActCounterFactual[:, 2]\n    )\n);\n\ndfActCounterFactual[:, :Predict] = dfActPred.Predict;\n\ndfActCounterFactualStack = stack(\n    dfActCounterFactual, \n    [:Actual, :Predict, :CounterFactual]\n    );\ndfActCounterFactualStack[:, :category] = repeat([\"All\"; listVarsShort], 3);\n\ntransform!(\n    dfActCounterFactualStack, \n    :variable => \n    (\n        x -> categorical(\n            x; \n            ordered = true, \n            levels = [\"Actual\", \"Predict\", \"CounterFactual\"]\n            )\n        ) => \n    :variable\n    );\ngroupedbar(\n    dfActCounterFactualStack.category, \n    dfActCounterFactualStack.value,\n    group = dfActCounterFactualStack.variable,\n    xlabel = \"value\", \n    ylabel = \"count\",\n    bar_width = 0.67,\n    lw = 0,\n    xrotation = 30\n)"
  },
  {
    "objectID": "dynamic_game_estimation_1.html#step-2",
    "href": "dynamic_game_estimation_1.html#step-2",
    "title": "10  推定 1",
    "section": "10.1 Step 2",
    "text": "10.1 Step 2\n\n\nCCP to Value to Prediction\nfunction CCP_to_Value_to_prediction(\n    theta,\n    CCP1,\n    CCP2,\n    TransitionMat,\n    beta\n)\n\n    CCP1Adjuster = [\n        0 1 1;\n        0 1 1;\n        1 1 0;\n        1 1 0\n    ];\n    CCP1Adjuster = repeat(CCP1Adjuster, 2);\n\n    CCP2Adjuster = [\n        0 1 1;\n        1 1 0;\n        0 1 1;\n        1 1 0\n    ];\n    CCP2Adjuster = repeat(CCP2Adjuster, 2);\n\n    pi1 = pi1gen(theta) .* CCP1Adjuster;\n    pi2 = pi2gen(theta) .* CCP2Adjuster;\n\n    CCP1Mat = CCP1Transform(CCP1);\n    CCP2Mat = CCP2Transform(CCP2);\n\n    fPsigma = fP(TransitionMat, CCP1, CCP2);\n\n    pi1Psigma = pi1PsigmaGen(pi1, CCP2Mat);\n    pi2Psigma = pi2PsigmaGen(pi2, CCP1Mat);\n\n    eP1 = eulergamma .- CCP1LogTransform(CCP1);\n    eP2 = eulergamma .- CCP2LogTransform(CCP2);\n\n    ExanteV1 = (\n        (diagm(ones(8)) - beta .* fPsigma) \\ \n        ((CCP1Mat .* (pi1Psigma + eP1)) * ones(3))\n    );\n\n    ExanteV2 = (\n        (diagm(ones(8)) - beta .* fPsigma) \\ \n        ((CCP2Mat .* (pi2Psigma + eP2)) * ones(3))\n    );\n\n    fP_a1 = fP_a1given(TransitionMat, CCP2);\n    fP_a2 = fP_a2given(TransitionMat, CCP1);\n\n    NewSigmaSeed1 = (\n        pi1Psigma + beta .* hcat(fP_a1[1] * ExanteV1, fP_a1[2] * ExanteV1, fP_a1[3] * ExanteV1) .* CCP1Adjuster\n    );\n    NewSigmaDeno1 = (\n        sum(exp.(NewSigmaSeed1), dims = 2) .- 1\n    );\n    NewSigma1 = exp.(NewSigmaSeed1) ./ NewSigmaDeno1;\n    CCP1UpdatedMat = NewSigma1 .* CCP1Adjuster;\n    CCP1Updated = CCP1UpdatedMat[:, 2];\n\n    NewSigmaSeed2 = (\n        pi2Psigma + beta .* hcat(fP_a2[1] * ExanteV2, fP_a2[2] * ExanteV2, fP_a2[3] * ExanteV2) .* CCP2Adjuster\n    );\n    NewSigmaDeno2 = (\n        sum(exp.(NewSigmaSeed2), dims = 2) .- 1\n    );\n    NewSigma2 = exp.(NewSigmaSeed2) ./ NewSigmaDeno2;\n    CCP2UpdatedMat = NewSigma2 .* CCP2Adjuster;\n    CCP2Updated = CCP2UpdatedMat[:, 2];\n\n    return hcat(CCP1Updated, CCP2Updated)\n\nend\n\n\nCCP_to_Value_to_prediction (generic function with 1 method)\n\n\n\noutput = CCP_to_Value_to_prediction(\n    TrueParameterValues,\n    CCP1UpdatedMat[:, 2],\n    CCP2UpdatedMat[:, 2],\n    TransitionMat,\n    beta\n);\n\nprintln(\"Difference between CCP in GDP and predicted CCP\")\noutput - hcat(CCP1UpdatedMat[:, 2], CCP2UpdatedMat[:, 2])\n\nDifference between CCP in GDP and predicted CCP\n\n\n8×2 Matrix{Float64}:\n  1.95367e-9   6.91787e-9\n  2.42611e-9  -5.08387e-9\n -1.33685e-9   5.43541e-9\n -1.75907e-9  -5.30343e-9\n  1.94553e-9   6.37121e-9\n  2.46917e-9  -5.46061e-9\n -1.3948e-9    5.44987e-9\n -2.09866e-9  -6.33131e-9\n\n\n\nNormalized_TrueParam = [\n    Parameters[1] - ((1 - beta) / beta) * Parameters[5],\n    Parameters[3],\n    Parameters[4],\n    0,\n    Parameters[6] + Parameters[5],\n    Parameters[2] - ((1 - beta) / beta) * Parameters[5],\n    Parameters[3],\n    Parameters[4],\n    0,\n    Parameters[6] + Parameters[5],\n]\n\noutput_noramlized = CCP_to_Value_to_prediction(\n    Normalized_TrueParam,\n    CCP1UpdatedMat[:, 2],\n    CCP2UpdatedMat[:, 2],\n    TransitionMat,\n    beta\n)\n\nprintln(\"Difference: predicted CCP in true parameter and normalized parameter\")\noutput_noramlized - output\n\nDifference: predicted CCP in true parameter and normalized parameter\n\n\n8×2 Matrix{Float64}:\n -1.11022e-16   1.11022e-16\n -1.11022e-16  -1.11022e-16\n  1.11022e-16  -1.11022e-16\n  2.22045e-16  -1.11022e-16\n  1.11022e-16   1.11022e-16\n -1.11022e-16  -1.11022e-16\n -1.11022e-16  -1.11022e-16\n  1.11022e-16   2.22045e-16\n\n\n\n\nObjective function\nfunction obj_fun(\n    param,\n    EstimatedCCP1,\n    EstimatedCCP2,\n    TransitionProb,\n    beta\n)\n\n    output = CCP_to_Value_to_prediction(\n        param, EstimatedCCP1, EstimatedCCP2, TransitionProb, beta\n    );\n\n    return sum((output[:, 1] - EstimatedCCP1).^2) + sum((output[:, 2] - EstimatedCCP2).^2)\n\nend;\n\n\n\ninitial = [Parameters[1:4]; Parameters[6]];\nmat_initial2 = initial .* reshape(rand(Uniform(0.6, 1.2), 50), (5, :));\nresult = zeros(6, 10);\n\nfor i in 1:10\n    sol = optimize(\n        x -> obj_fun(\n            [x[1]; x[3:4]; [0]; x[5]; x[2]; x[3:4]; [0]; x[5]], \n            EstimatedCCP1, EstimatedCCP2, EstimatedTransition, beta\n            ),\n        mat_initial2[:, i],\n        Optim.Options(show_trace = false)\n    );\n    result[:, i] = [sol.minimizer; sol.minimum];\nend\n\nresult_pick = result[1:5, argmin(result[6, :])];\n\n\nnormalized_trueparam = [\n    Normalized_TrueParam[1],\n    Normalized_TrueParam[6],\n    Normalized_TrueParam[2],\n    Normalized_TrueParam[3],\n    Normalized_TrueParam[5],\n];\n\nDataFrame(\n    param_est = result_pick,\n    normalized_trueparam = normalized_trueparam\n)\n\n\n5×2 DataFrameRowparam_estnormalized_trueparamFloat64Float6410.3487870.337520.2238680.23753-0.291698-0.2740.4926550.455-2.22346-2.25\n\n\n\nnumBootSample = 100;\n\nbootindex = reshape(\n    sample(1:NumSimMarkets, NumSimMarkets * numBootSample),\n    (NumSimMarkets, numBootSample)\n);\n\n\nbootresult_transition = zeros(2, numBootSample);\nbootresult_CCP1 = zeros(8, numBootSample);\nbootresult_CCP2 = zeros(8, numBootSample);\nbootresult_payoff = zeros(5, numBootSample);\n\n\n\nBootstrap\nfunction Estimation_PS_bootstrap(\n    FakeData,\n    beta\n)\n\n    EstimatedCCP1 = zeros(8, 1);\n    EstimatedCCP2 = zeros(8, 1);\n\n    for s in 1:8\n        SubData = FakeData[FakeData[:, 3] .== s, :];\n        EstimatedCCP1[s] = mean(SubData[:, 7] .== 0);\n        EstimatedCCP2[s] = mean(SubData[:, 8] .== 0);\n    end\n\n    EstimatedTransition = zeros(2, 2);\n\n    SubData = hcat(FakeData, [[0]; FakeData[1:(end - 1), 4]]);\n    SubData = SubData[SubData[:, 2] .!= 1, :];\n\n    for z in 1:2\n        SubDataZ = SubData[SubData[:, 4] .== z, :];\n        EstimatedTransition[z, z] = mean(SubDataZ[:, 9] .== z);\n        EstimatedTransition[z, 3 - z] = 1 - EstimatedTransition[z, z];\n    end\n\n    SubData = hcat(FakeData, [[0]; FakeData[1:(end - 1), 4]]);\n    SubData = SubData[SubData[:, 2] .!= 1, :];\n\n    for z in 1:2\n        SubDataZ = SubData[SubData[:, 4] .== z, :];\n        EstimatedTransition[z, z] = mean(SubDataZ[:, 9] .== z);\n        EstimatedTransition[z, 3 - z] = 1 - EstimatedTransition[z, z];\n    end\n\n    result = optimize(\n        x -> obj_fun(\n            [x[1]; x[3:4]; [0]; x[5]; x[2]; x[3:4]; [0]; x[5]], \n            EstimatedCCP1, EstimatedCCP2, EstimatedTransition, beta\n            ),\n        [0.3, 0.2, -0.27, 0.45, -2.1],\n        Optim.Options(show_trace = false)\n    );\n\n    return [\n        hcat(EstimatedCCP1, EstimatedCCP2),\n        EstimatedTransition,\n        result.minimizer,\n        result.minimum\n    ]\n\nend\n\n\nEstimation_PS_bootstrap (generic function with 1 method)\n\n\n\n@time for b in 1:numBootSample\n    bootsample = zeros(NumSimPeriods * NumSimMarkets, 8);\n    for m in 1:NumSimMarkets\n        temp = FakeData[FakeData[:, 1] .== bootindex[m, b], :];\n        bootsample[(1 + NumSimPeriods * (m - 1)):(NumSimPeriods * m), :] = temp;\n    end\n\n    output = Estimation_PS_bootstrap(bootsample, beta);\n\n    bootresult_CCP1[:, b] = output[1][:, 1];\n    bootresult_CCP2[:, b] = output[1][:, 2];\n    bootresult_transition[:, b] = diag(output[2]);\n    bootresult_payoff[:, b] = output[3];\nend\n\n  4.176209 seconds (17.09 M allocations: 13.241 GiB, 14.93% gc time, 7.18% compilation time)\n\n\n\nprintln(\"CCP for firm 1\")\nDataFrame(\n    \"True values\" => CCP1UpdatedMat[:, 2],\n    \"Estimated\" => vec(EstimatedCCP1),\n    \"SE\" => vec(std(bootresult_CCP1, dims=2))\n)\n\nCCP for firm 1\n\n\n\n8×3 DataFrameRowTrue valuesEstimatedSEFloat64Float64Float6410.6835630.6712760.0091672420.7126620.700410.0076721230.8156510.8272990.0062089240.7938190.7976590.0057718650.7080670.7056170.0095922560.7359650.7253340.0089972670.7975470.7897780.0086046680.7741370.7873420.00711149\n\n\n\nprintln(\"CCP for firm 2\")\nDataFrame(\n    \"True values\" => CCP2UpdatedMat[:, 2],\n    \"Estimated\" => vec(EstimatedCCP2),\n    \"SE\" => vec(std(bootresult_CCP2, dims=2))\n)\n\nCCP for firm 2\n\n\n\n8×3 DataFrameRowTrue valuesEstimatedSEFloat64Float64Float6410.7147250.7182930.0096869420.7924090.8003780.0073107830.7416970.7463080.0057263840.7687310.7677250.0064062850.7376850.7141420.010424760.7727060.7612880.0083257770.763530.765670.0072145480.74730.7363920.00769535\n\n\n\nprintln(\"Transition Probability (GG and BB)\")\nDataFrame(\n    \"True values\" => diag(TransitionMat),\n    \"Estimated\" => diag(EstimatedTransition),\n    \"SE\" => vec(std(bootresult_transition, dims=2))\n)\n\nTransition Probability (GG and BB)\n\n\n\n2×3 DataFrameRowTrue valuesEstimatedSEFloat64Float64Float6410.70.7000710.0033715420.60.5997110.0045105\n\n\n\nDataFrame(\n    \"True values\" => initial,\n    \"Normalized true values\" => Normalized_TrueParam[[1, 6, 2, 3, 5]],\n    \"Estimated\" => result_pick,\n    \"SE\" => vec(std(bootresult_payoff, dims=2))\n    )\n\n\n5×4 DataFrameRowTrue valuesNormalized true valuesEstimatedSEFloat64Float64Float64Float6410.30.33750.3487870.054496120.20.23750.2238680.05570813-0.27-0.27-0.2916980.038532140.450.450.4926550.0894355-2.1-2.25-2.223460.0196745\n\n\n\n@save \"tmp/dynamic_game/estimates_1.jld2\" EstimatedCCP1 EstimatedCCP2 EstimatedTransition;"
  },
  {
    "objectID": "demand_estimation_1.html#データの読み込み",
    "href": "demand_estimation_1.html#データの読み込み",
    "title": "2  基礎編 1",
    "section": "2.1 データの読み込み",
    "text": "2.1 データの読み込み\n\ndataCar = CSV.File(\n    open(read, \"data/demand_estimation/CleanData_20180222.csv\", enc\"shift-jis\"),\n    missingstring = [\"NA\", \"\"],\n    ) |> DataFrame\nfirst(select(dataCar, Not([:base_color, :option_color])), 5)\n\n\n5×34 DataFrameRowMakerTypeNameYearSalescommentModelYear_trueMonthpricekudoukataTransMissionWheelBaseMinRideHeightweightcapacitySeatRawNumofDoor種類engine過給器displacementFuelTypeTankCapacityHorsePowerMaxTorqueFuelEfficiencyoverall_lengthoverall_widthoverall_heightinterior_lengthinterior_widthinterior_heightString15String7String31Int64Int64String?StringInt64Int64Float64String3String15String3Int64Int64?Int64Int64Int64Int64String31String15StringInt64String15Int64?Int64?Float64?Float64?Int64Int64Int64Int64?Int64?Int64?1AudiForeignA1シリーズ20114206missing1.4 TFSI20111289.0FFDBA-8XCAX7AT24651151190423直列4気筒DOHCCAXターボ1389ハイオク4512220.419.4397017401440missingmissingmissing2AudiForeignA1シリーズ20124502missing1.4 TFSI20121273.0FFDBA-8XCAX7AT24651151190423直列4気筒DOHCCAXターボ1389ハイオク4512220.419.4397017401440missingmissingmissing3AudiForeignA1シリーズ20135071missing1.4 TFSI20121273.0FFDBA-8XCAX7AT24651151190423直列4気筒DOHCCAXターボ1389ハイオク4512220.419.4397017401440missingmissingmissing4AudiForeignA3シリーズ20064830missingアトラクション20061284.0FFGH-8PBSE6AT25751401360525直列4気筒SOHCBSEなし1595ハイオク5510215.112.2428517651430missingmissingmissing5AudiForeignA3シリーズ20073874missingアトラクション20071286.0FFGH-8PBSE6AT25751401360525直列4気筒SOHCBSEなし1595ハイオク5510215.112.2428517651430missingmissingmissing\n\n\n\ndataHH = CSV.read(\"data/demand_estimation/HHsize.csv\", DataFrame)\ndataHH[!, :HH] = parse.(Int, replace.(dataHH.HH, \",\" => \"\"))\nfirst(dataHH, 5)\n\n\n5×2 DataFrameRowyearHHInt64Int6411975333100062197633911052319773438031441978348586965197935350173\n\n\n\ndataCPI = CSV.File(\n    open(read, \"data/demand_estimation/zni2015s.csv\", enc\"shift-jis\"), \n    select = 1:2,\n    skipto = 7\n    ) |> DataFrame\nrename!(dataCPI, \"類・品目\" => \"year\", \"総合\" => \"CPI\")\nfirst(dataCPI, 5)\n\n\n5×2 DataFrameRowyearCPIInt64Float641197031.52197133.53197235.24197339.35197448.4"
  },
  {
    "objectID": "demand_estimation_1.html#データクリーニング",
    "href": "demand_estimation_1.html#データクリーニング",
    "title": "2  基礎編 1",
    "section": "2.2 データクリーニング",
    "text": "2.2 データクリーニング\n\ndataCar = dataCar[!, [\n        :Maker, :Type, :Name, :Year, :Sales, \n        :Model, :price, :kata, :weight, :FuelEfficiency, \n        :HorsePower, :overall_length, :overall_width, :overall_height\n        ]]\nrename!(dataCar, \"Year\" => \"year\")\ndata = leftjoin(dataCar, dataHH, on = :year)\ndata = leftjoin(data, dataCPI, on = :year)\nfirst(data, 5)\n\n\n5×16 DataFrameRowMakerTypeNameyearSalesModelpricekataweightFuelEfficiencyHorsePoweroverall_lengthoverall_widthoverall_heightHHCPIString15String7String31Int64Int64StringFloat64String15Int64Float64?Int64?Int64Int64Int64Int64?Float64?1AudiForeignA1シリーズ201142061.4 TFSI289.0DBA-8XCAX119019.41223970174014405378343596.32AudiForeignA1シリーズ201245021.4 TFSI273.0DBA-8XCAX119019.41223970174014405417147596.23AudiForeignA1シリーズ201350711.4 TFSI273.0DBA-8XCAX119019.41223970174014405459474496.64AudiForeignA3シリーズ20064830アトラクション284.0GH-8PBSE136012.21024285176514305110200597.25AudiForeignA3シリーズ20073874アトラクション286.0GH-8PBSE136012.21024285176514305171304897.2\n\n\n\ndropmissing!(data, :FuelEfficiency);\n\n\ncpi2016 = dataCPI[dataCPI.year .== 2016, \"CPI\"][1];\ndata[!, :price] = data.price ./ (data.CPI / cpi2016) / 100;\n\n\ndata[!, :size] = (\n    (data[:, :overall_length] / 1000) .* \n    (data[:, :overall_width] / 1000) .* \n    (data[:, :overall_height] / 1000)\n);\ndata[!, :hppw] = data[:, :HorsePower] ./ data[:, :weight];\n\ndata[:, :NameID] = groupby(data, :Name).groups;\n\ntransform!(\n    groupby(data, :year),\n    :Sales => sum => :inside_total\n);\ndata[!, :outside_total] = data.HH .- data.inside_total;\ndata[!, :share] = data.Sales ./ data.HH;\ndata[!, :share0] = data.outside_total ./ data.HH;"
  },
  {
    "objectID": "demand_estimation_1.html#操作変数の構築",
    "href": "demand_estimation_1.html#操作変数の構築",
    "title": "2  基礎編 1",
    "section": "2.3 操作変数の構築",
    "text": "2.3 操作変数の構築\n\ntransform!(\n    groupby(data, [:year, :Maker]),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        sum .=> \n        [:hppw_sum_own, :FuelEfficiency_sum_own, :size_sum_own]\n    ),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        (x -> sum(x.^2)) .=> \n        [:hppw_sqr_sum_own, :FuelEfficiency_sqr_sum_own, :size_sqr_sum_own]\n    ),\n    nrow => :group_n\n);\ntransform!(\n    groupby(data, [:year]),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        sum .=> \n        [:hppw_sum_mkt, :FuelEfficiency_sum_mkt, :size_sum_mkt]\n    ),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        (x -> sum(x.^2)) .=> \n        [:hppw_sqr_sum_mkt, :FuelEfficiency_sqr_sum_mkt, :size_sqr_sum_mkt]\n    ),\n    nrow => :mkt_n\n);\n\n\nfor variable in [\"hppw\", \"FuelEfficiency\", \"size\"]\n    addIVColumns!(data, variable)\nend\n\n\nCSV.write(\"tmp/demand_estimation_1/data.csv\", data);"
  },
  {
    "objectID": "demand_estimation_1.html#記述統計と基礎的な分析",
    "href": "demand_estimation_1.html#記述統計と基礎的な分析",
    "title": "2  基礎編 1",
    "section": "2.3 記述統計と基礎的な分析",
    "text": "2.3 記述統計と基礎的な分析\n\n2.3.1 イントロダクションの日評自動車\n\nNIPPYOautoIDvec = [\n    260, 4, 76, 104, 64, 54, 152, 153, 71, 197,\n    42, 45, 114, 208, 209, 77, 236, 58, 127, 187,\n    79, 175, 19, 117, 216, 112, 256, 119, 37, 158\n];\n\n\ndataNIPPYO = data[in(NIPPYOautoIDvec).(data.NameID), [:Sales, :price, :hppw, :FuelEfficiency, :size]];\ndataNIPPYO[!, :log_sales] = log.(dataNIPPYO[:, :Sales]);\ndataNIPPYO[!, :log_price] = log.(dataNIPPYO[:, :price]);\ndataNIPPYO[!, :log10_sales] = log10.(dataNIPPYO[:, :Sales]);\ndataNIPPYO[!, :log10_price] = log10.(dataNIPPYO[:, :price]);\n\n\nreg(\n    dataNIPPYO, \n    @formula(log_sales ~ log_price + hppw + FuelEfficiency + size),\n    Vcov.robust()\n)\n\n                                 FixedEffectModel                                 \n==================================================================================\nNumber of obs:                       196  Converged:                          true\ndof (model):                           4  dof (residuals):                     190\nR²:                                0.217  R² adjusted:                       0.201\nF-statistic:                     19.1148  P-value:                           0.000\n==================================================================================\n                  Estimate  Std. Error    t-stat  Pr(>|t|)    Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────────────────\nlog_price       -1.24828     0.309545   -4.03262    <1e-04   -1.85886    -0.63769\nhppw            -4.19685     3.97622    -1.05549    0.2925  -12.0401      3.64635\nFuelEfficiency   0.0886034   0.0283887   3.12108    0.0021    0.0326059   0.144601\nsize             0.306896    0.0588927   5.2111     <1e-06    0.190728    0.423063\n(Intercept)      5.76211     1.06127     5.42946    <1e-06    3.66873     7.85549\n==================================================================================\n\n\n\nOLSFitLine = predict(\n    lm(@formula(log10_sales ~ log10_price), dataNIPPYO),\n    dataNIPPYO,\n    interval = :confidence,\n    level = 0.90\n    );\nplot(\n    dataNIPPYO.price, \n    dataNIPPYO.Sales, \n    seriestype = :scatter, \n    legend = false,\n    xscale = :log10,\n    yscale = :log10,\n    xlabel = \"Price\",\n    ylabel = \"Sales\",\n    xticks = ([1, 3, 10], [1, 3, 10]),\n)\nsortedPrediction = OLSFitLine[sortperm(dataNIPPYO[!, :price]), :]\nsortedPrice = sort(dataNIPPYO[!, :price])\nplot!(\n    sortedPrice,\n    10 .^ sortedPrediction.prediction,\n    ribbon = (\n        10 .^ sortedPrediction.prediction - 10 .^ sortedPrediction.lower,\n        10 .^ sortedPrediction.upper - 10 .^ sortedPrediction.prediction,\n        )\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.2 記述統計\n\ndescribe(data[:, [:Sales, :price, :FuelEfficiency, :size, :hppw]])\n\n\n5×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64RealFloat64RealInt64DataType1Sales24586.4108544.03176750Int642price2.530470.7051762.0504212.62650Float643FuelEfficiency16.15975.515.440.80Float644size11.50535.90911.472519.15480Float645hppw0.09913120.0450.09268290.3238640Float64"
  },
  {
    "objectID": "demand_estimation_1.html#ロジットモデルの推定とその応用",
    "href": "demand_estimation_1.html#ロジットモデルの推定とその応用",
    "title": "2  基礎編 1",
    "section": "2.4 ロジットモデルの推定とその応用",
    "text": "2.4 ロジットモデルの推定とその応用\n\ndata[!, :logit_share] = log.(data[:, :share]) .- log.(data[:, :share0]);\n\n\nresultOLS = reg(\n    data, \n    @formula(logit_share ~ price + hppw + FuelEfficiency + size), \n    Vcov.robust()\n    );\nresultBLP = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust()\n);\nresultGH = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust(),\n    save = true\n);\n\n\nregtable(resultOLS, resultBLP, resultGH)\n\n\n--------------------------------------------------------------\n                                       logit_share            \n                          ------------------------------------\n                                 (1)          (2)          (3)\n--------------------------------------------------------------\n(Intercept)               -12.255***   -12.323***   -12.973***\n                             (0.365)      (0.382)      (0.393)\nprice                      -0.255***    -0.283***    -0.552***\n                             (0.026)      (0.067)      (0.080)\nhppw                          -0.654        0.213      8.426**\n                             (1.284)      (2.298)      (2.638)\nFuelEfficiency              0.130***     0.130***     0.127***\n                             (0.010)      (0.010)      (0.010)\nsize                        0.182***     0.187***     0.236***\n                             (0.019)      (0.021)      (0.022)\n--------------------------------------------------------------\nEstimator                        OLS           IV           IV\n--------------------------------------------------------------\nN                              1,823        1,823        1,823\nR2                             0.222        0.222        0.180\nWithin-R2                                                     \nFirst-stage F statistic                    33.926       51.583\n--------------------------------------------------------------\n\n\n\n\n2.4.1 1st stage\n\nresultBLP1st = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_BLP_own_hppw + iv_BLP_own_FuelEfficiency + iv_BLP_own_size + \n            iv_BLP_other_hppw + iv_BLP_other_FuelEfficiency + iv_BLP_other_size\n        ),\n    Vcov.robust()\n);\nresultGH1st = reg(\n    data, \n    @formula(price ~ hppw + FuelEfficiency + size +\n            iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n        ),\n    Vcov.robust()\n);\n\n\nregtable(resultBLP1st, resultGH1st)\n\n\n---------------------------------------------------\n                                      price        \n                              ---------------------\n                                    (1)         (2)\n---------------------------------------------------\n(Intercept)                      -3.159    -1.325**\n                                (1.685)     (0.423)\nhppw                          28.749***   23.508***\n                                (0.993)     (1.547)\nFuelEfficiency                   -0.011   -0.072***\n                                (0.008)     (0.014)\nsize                           0.202***    0.189***\n                                (0.015)     (0.020)\niv_BLP_own_hppw                 -0.728*            \n                                (0.336)            \niv_BLP_own_FuelEfficiency     -0.007***            \n                                (0.001)            \niv_BLP_own_size                0.013***            \n                                (0.004)            \niv_BLP_other_hppw                 0.165            \n                                (0.255)            \niv_BLP_other_FuelEfficiency     0.001**            \n                                (0.000)            \niv_BLP_other_size                -0.002            \n                                (0.003)            \niv_GH_own_hppw                            -1.889***\n                                            (0.439)\niv_GH_own_FuelEfficiency                      0.000\n                                            (0.000)\niv_GH_own_size                            -0.001***\n                                            (0.000)\niv_GH_other_hppw                           0.423***\n                                            (0.096)\niv_GH_other_FuelEfficiency                 0.000***\n                                            (0.000)\niv_GH_other_size                           0.000***\n                                            (0.000)\n---------------------------------------------------\nN                                 1,823       1,823\nR2                                0.616       0.623\n---------------------------------------------------\n\n\n\n\n\n2.4.2 自己価格弾力性の計算\n\ndata[!, :own_elas_ols] = (\n    resultOLS.coef[resultOLS.coefnames .== \"price\"] .* \n    data[:, :price] .* \n    (1 .- data[:, :share])\n);\ndata[!, :own_elas_ivblp] = (\n    resultBLP.coef[resultBLP.coefnames .== \"price\"] .* \n    data[:, :price] .* \n    (1 .- data[:, :share])\n);\ndata[!, :own_elas_ivgh] = (\n    resultGH.coef[resultGH.coefnames .== \"price\"] .* \n    data[:, :price] .* \n    (1 .- data[:, :share])\n);\n\n\ndescribe(data[:, r\"^own_elas\"])\n\n\n3×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64Float64Float64Float64Int64DataType1own_elas_ols-0.645328-3.22104-0.522324-0.1798920Float642own_elas_ivblp-0.717085-3.5792-0.580404-0.1998950Float643own_elas_ivgh-1.3967-6.9714-1.13048-0.3893460Float64"
  },
  {
    "objectID": "demand_estimation_1.html#自己価格弾力性の計算",
    "href": "demand_estimation_1.html#自己価格弾力性の計算",
    "title": "2  基礎編 1",
    "section": "2.6 自己価格弾力性の計算",
    "text": "2.6 自己価格弾力性の計算\n\ndata[!, :own_elas_ols] = (\n    resultOLS.coef[resultOLS.coefnames .== \"price\"] .* \n    data[:, :price] .* \n    (1 .- data[:, :share])\n);\ndata[!, :own_elas_ivblp] = (\n    resultBLP.coef[resultBLP.coefnames .== \"price\"] .* \n    data[:, :price] .* \n    (1 .- data[:, :share])\n);\ndata[!, :own_elas_ivgh] = (\n    resultGH.coef[resultGH.coefnames .== \"price\"] .* \n    data[:, :price] .* \n    (1 .- data[:, :share])\n);\n\n\ndescribe(data[:, r\"^own_elas\"])\n\n\n3×7 DataFrameRowvariablemeanminmedianmaxnmissingeltypeSymbolFloat64Float64Float64Float64Int64DataType1own_elas_ols-0.645328-3.22104-0.522324-0.1798920Float642own_elas_ivblp-0.717085-3.5792-0.580404-0.1998950Float643own_elas_ivgh-1.3967-6.9714-1.13048-0.3893460Float64"
  },
  {
    "objectID": "demand_estimation_1.html#推定結果の応用",
    "href": "demand_estimation_1.html#推定結果の応用",
    "title": "2  基礎編 1",
    "section": "2.5 推定結果の応用",
    "text": "2.5 推定結果の応用\n\n2.5.1 需要曲線と収入曲線を書く\n\ndata[!, :xi_fit] = resultGH.residuals;\n\n\ntargetNameID = 197\ndata[\n    (data.year .== 2016) .& \n    (data.NameID .== targetNameID), \n    :]\n\n\n1×54 DataFrameRowMakerTypeNameyearSalesModelpricekataweightFuelEfficiencyHorsePoweroverall_lengthoverall_widthoverall_heightHHCPIsizehppwNameIDinside_totaloutside_totalshareshare0hppw_sum_ownFuelEfficiency_sum_ownsize_sum_ownhppw_sqr_sum_ownFuelEfficiency_sqr_sum_ownsize_sqr_sum_owngroup_nhppw_sum_mktFuelEfficiency_sum_mktsize_sum_mkthppw_sqr_sum_mktFuelEfficiency_sqr_sum_mktsize_sqr_sum_mktmkt_niv_BLP_own_hppwiv_BLP_other_hppwiv_GH_own_hppwiv_GH_other_hppwiv_BLP_own_FuelEfficiencyiv_BLP_other_FuelEfficiencyiv_GH_own_FuelEfficiencyiv_GH_other_FuelEfficiencyiv_BLP_own_sizeiv_BLP_other_sizeiv_GH_own_sizeiv_GH_other_sizelogit_shareown_elas_olsown_elas_ivblpown_elas_ivghxi_fitString15String7String31Int64Int64StringFloat64String15Int64Float64Int64?Int64Int64Int64Int64?Float64?Float64Float64Int64Int64Int64Float64Float64Float64Float64Float64Float64Float64Float64Int64Float64Float64Float64Float64Float64Float64Int64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64?1ToyotaRegularアルファード2016370692.5 X3.198DBA-AGH30W192011.61824915185018805695075799.917.09440.09479171973983817529669400.0006508960.9300483.84238721.0499.7640.38820615287.46520.214016.71283176.11974.41.9052667586.024147.51693.7475912.87040.01917230.236157709.42455.13942.5812698.6482.671474.641122.64907.45-7.26464-0.815288-0.905944-1.764551.16401\n\n\n\npriceVec = range(0.3, 5, step = 0.05);\nsalesVec = calculateSales.(\n    priceVec, 2016, targetNameID, Ref(data), Ref(resultGH)\n    );\n\n\nplot(salesVec, priceVec, xticks = [50000, 100000, 150000], legend = false)\nxlabel!(\"Sales\")\nylabel!(\"Price (million JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot(priceVec, priceVec .* salesVec / 1000, legend = false)\nxlabel!(\"Price (million JPY)\")\nylabel!(\"Revenue (billion JPY)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.5.2 収入を最大化する価格\n\n@time resultMaxSales = optimize(\n    x -> - calculateSales(\n        x[1], \n        2016, \n        targetNameID, \n        data, \n        resultGH\n        ) * x[1],\n    [1.0]\n);\n\n@printf(\"Revenue-maximizing price: %.3f \\n\", resultMaxSales.minimizer[1])\n@printf(\"Maximized revenue : %.3f\", -resultMaxSales.minimum)\n\n  0.386725 seconds (1.42 M allocations: 97.367 MiB, 4.09% gc time, 98.43% compilation time)\nRevenue-maximizing price: 1.814 \nMaximized revenue : 144273.836"
  },
  {
    "objectID": "demand_estimation_2.html#加工済みデータの読み込み",
    "href": "demand_estimation_2.html#加工済みデータの読み込み",
    "title": "3  基礎編 2",
    "section": "3.1 加工済みデータの読み込み",
    "text": "3.1 加工済みデータの読み込み\n\ndata = CSV.read(\"tmp/demand_estimation_1/data.csv\", DataFrame);"
  },
  {
    "objectID": "demand_estimation_2.html#価格弾力性行列の作成",
    "href": "demand_estimation_2.html#価格弾力性行列の作成",
    "title": "3  基礎編 2",
    "section": "3.3 価格弾力性行列の作成",
    "text": "3.3 価格弾力性行列の作成\n\ndata[!, :logit_share] = log.(data[:, :share]) .- log.(data[:, :share0]);\n\nresultGH = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust(),\n    save = true\n);\n\ndata2016 = dataNIPPYO[\n    dataNIPPYO.year .== 2016, \n    [:price, :share, :NameID, :Name]\n    ];\nnumCars2016 = nrow(data2016);\n\nownElasticity = (\n    resultGH.coef[resultGH.coefnames .== \"price\"][1] .* \n    data2016.price .* \n    (1.0 .- data2016.share)\n);\ncrossElasticity = (\n    - resultGH.coef[resultGH.coefnames .== \"price\"][1] .* \n    data2016.price .* \n    data2016.share\n);\n\nelasticityMat = reduce(\n    hcat, \n    [crossElasticity for car = 1:numCars2016]\n    );\nelasticityMat[diagind(elasticityMat)] = ownElasticity;\n\nelasticityMat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -1.76455       0.00114929    0.00114929   0.00114929\n  0.00122042   -0.818689      0.00122042   0.00122042\n  0.000148175   0.000148175  -0.959449     0.000148175\n  0.00184509    0.00184509    0.00184509  -0.67175"
  },
  {
    "objectID": "demand_estimation_2.html#入れ子型ロジット推定のためのblp操作変数の作成",
    "href": "demand_estimation_2.html#入れ子型ロジット推定のためのblp操作変数の作成",
    "title": "3  基礎編 2",
    "section": "3.5 入れ子型ロジット推定のためのBLP操作変数の作成",
    "text": "3.5 入れ子型ロジット推定のためのBLP操作変数の作成\n\ntransform!(\n    groupby(data, [:year, :Maker, :Type]),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        sum .=> \n        [:hppw_sum_own, :FuelEfficiency_sum_own, :size_sum_own]\n    ),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        (x -> sum(x.^2)) .=> \n        [:hppw_sqr_sum_own, :FuelEfficiency_sqr_sum_own, :size_sqr_sum_own]\n    ),\n    nrow => :group_n\n);\ntransform!(\n    groupby(data, [:year, :Type]),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        sum .=> \n        [:hppw_sum_mkt, :FuelEfficiency_sum_mkt, :size_sum_mkt]\n    ),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        (x -> sum(x.^2)) .=> \n        [:hppw_sqr_sum_mkt, :FuelEfficiency_sqr_sum_mkt, :size_sqr_sum_mkt]\n    ),\n    nrow => :mkt_n\n);\n\nfor variable in [\"hppw\", \"FuelEfficiency\", \"size\"]\n    addIVColumnsForNestedLogit!(data, variable)\nend\n\ndata[!, :iv_BLP_own_num_nest] = data[:, :group_n] .- 1;\ndata[!, :iv_BLP_other_num_nest] = data[:, :mkt_n] .- data[:, :group_n];"
  },
  {
    "objectID": "demand_estimation_2.html#入れ子型ロジットモデルの推定とその応用",
    "href": "demand_estimation_2.html#入れ子型ロジットモデルの推定とその応用",
    "title": "3  基礎編 2",
    "section": "3.5 入れ子型ロジットモデルの推定とその応用",
    "text": "3.5 入れ子型ロジットモデルの推定とその応用\n\ndata = transform(\n    groupby(data, [:year, :Type]),\n    :Sales => sum => :sum_year_body\n);\ndata[!, :inside_share] = data.Sales ./ data.sum_year_body;\ndata[!, :log_inside_share] = log.(data.Sales ./ data.sum_year_body);\nresultOLS = reg(\n    data, \n    @formula(\n        logit_share ~ \n        price + log_inside_share + hppw + FuelEfficiency + size\n        )\n    );\n\nresultBLPNested = reg(\n    data, \n    @formula(logit_share ~ (\n        price + log_inside_share ~ iv_BLP_own_hppw_nest + iv_BLP_own_FuelEfficiency_nest + iv_BLP_own_size_nest + \n            iv_BLP_other_hppw_nest + iv_BLP_other_FuelEfficiency_nest + iv_BLP_other_size_nest +\n            iv_BLP_own_num_nest + iv_BLP_other_num_nest\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust()\n);\n\nregtable(resultOLS, resultBLPNested)\n\n\n-----------------------------------------------\n                               logit_share     \n                          ---------------------\n                                (1)         (2)\n-----------------------------------------------\n(Intercept)               -7.557***   -9.548***\n                            (0.166)     (0.239)\nprice                     -0.307***   -0.654***\n                            (0.013)     (0.053)\nlog_inside_share           0.782***    0.595***\n                            (0.009)     (0.035)\nhppw                      10.636***   18.925***\n                            (0.657)     (1.965)\nFuelEfficiency             0.055***    0.069***\n                            (0.004)     (0.006)\nsize                       0.156***    0.227***\n                            (0.008)     (0.012)\n-----------------------------------------------\nEstimator                       OLS          IV\n-----------------------------------------------\nN                             1,823       1,823\nR2                            0.862       0.765\nWithin-R2                                      \nFirst-stage F statistic                   1.667\n-----------------------------------------------"
  },
  {
    "objectID": "demand_estimation_2.html#入れ子型ロジットモデルにおける自己価格弾力性の計算",
    "href": "demand_estimation_2.html#入れ子型ロジットモデルにおける自己価格弾力性の計算",
    "title": "3  基礎編 2",
    "section": "3.6 入れ子型ロジットモデルにおける自己価格弾力性の計算",
    "text": "3.6 入れ子型ロジットモデルにおける自己価格弾力性の計算\n\nalpha1 = resultOLS.coef[resultOLS.coefnames .== \"price\"][1]\nsigma1 = resultOLS.coef[resultOLS.coefnames .== \"log_inside_share\"][1]\n\nalpha2 = resultBLPNested.coef[resultBLPNested.coefnames .== \"price\"][1]\nsigma2 = resultBLPNested.coef[resultBLPNested.coefnames .== \"log_inside_share\"][1]\n\ndata[!, :own_elas_ols] = alpha1 .* data[:, :price] .* (\n    1.0 .- sigma1 .* data[:, :inside_share] .- \n    (1.0 .- sigma1) .* data[:, :share]\n) ./ (1.0 .- sigma1);\ndata[!, :own_elas_ivblp_nested] = alpha2 .* data[:, :price] .* (\n    1.0 .- sigma2 .* data[:, :inside_share] .- \n    (1.0 .- sigma2) .* data[:, :share]\n) ./ (1.0 .- sigma2);\n\ndescribe(data[:, r\"^own_elas\"], :mean, :std, :median, :min, :max)\n\n\n2×6 DataFrameRowvariablemeanstdmedianminmaxSymbolFloat64Float64Float64Float64Float641own_elas_ols-3.521312.55849-2.84383-17.7936-0.962572own_elas_ivblp_nested-4.049352.93775-3.2664-20.4015-1.11262\n\n\n\ndataNIPPYO = data[\n    in(NIPPYOautoIDvec).(data[:, :NameID]), \n    [\n        :year, :share, :Type, :inside_share, \n        :NameID, :Sales, :price, :hppw, :FuelEfficiency, :size, :Name\n        ]\n    ];\ndataNIPPYO[!, :log_sales] = log.(dataNIPPYO[:, :Sales]);\ndataNIPPYO[!, :log_price] = log.(dataNIPPYO[:, :price]);\n\ndata2016 = dataNIPPYO[\n    dataNIPPYO.year .== 2016, \n    [:price, :Type, :share, :inside_share, :NameID, :Name]\n    ];\nnumCars2016 = nrow(data2016);\n\nownElasticityNestedLogit = (\n    alpha2 .* \n    data2016.price .* \n    (\n        1.0 .- sigma2 .* \n        data2016.inside_share .- \n        (1.0 .- sigma2) .* \n        data2016.share\n        ) ./ \n    (1.0 .- sigma2)\n);\ncrossElasticityOtherGroup = (\n    - alpha2 .* \n    data2016.price .* \n    data2016.share\n);\n\ncrossElasticityOtherGroup = reduce(\n    hcat, \n    [crossElasticityOtherGroup for car = 1:numCars2016]\n    );\ncrossElasticityOtherGroup[\n    diagind(crossElasticityOtherGroup)\n    ] = ownElasticityNestedLogit;\n\n\ncrossElasticitySameGroup = reduce(\n    hcat,\n    [\n        - alpha2 .* data2016.price .* (\n            sigma2 .* data2016.inside_share .+ (1.0 .- sigma2) .* data2016.share\n        ) ./ (1.0 .- sigma2)\n    for car in 1:numCars2016]\n);\n\nsameGroupIndicatorMat = (\n    reduce(hcat, [data2016.Type for car = 1:numCars2016]) .==\n    permutedims(reduce(hcat, [data2016.Type for car = 1:numCars2016]))\n);\notherGroupIndicatorMat = (sameGroupIndicatorMat .== 0);\n\nelasticityNestedLogitMat = (\n    crossElasticitySameGroup .* \n    sameGroupIndicatorMat .+ \n    crossElasticityOtherGroup .* \n    otherGroupIndicatorMat\n);\nelasticityNestedLogitMat[\n    diagind(elasticityNestedLogitMat)\n    ] = ownElasticityNestedLogit;\n\nelasticityNestedLogitMat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -5.1197       0.0477573    0.0477573    0.00136172\n  0.050713    -2.34881      0.050713     0.001446\n  0.00615725   0.00615725  -2.80217      0.000175564\n  0.00218614   0.00218614   0.00218614  -1.83296"
  },
  {
    "objectID": "demand_estimation_2.html#ランダム係数ロジットモデルの推定",
    "href": "demand_estimation_2.html#ランダム係数ロジットモデルの推定",
    "title": "3  基礎編 2",
    "section": "3.7 ランダム係数ロジットモデルの推定",
    "text": "3.7 ランダム係数ロジットモデルの推定\n\n3.7.1 下準備\n\nsort!(data, [:year, :NameID]);\n\nN = nrow(data);\nT = length(unique(data.year));\n\nX1 = hcat(ones(N), Matrix(data[:, [:price, :FuelEfficiency, :hppw, :size]]));\nX2 = hcat(data.price, ones(N), data.size);\nZ = hcat(\n    ones(N),\n    Matrix(data[:, [:FuelEfficiency, :hppw, :size]]),\n    Matrix(data[:, r\"^iv_GH.*(?<!nest)$\"])\n    );\n\nRandom.seed!(123);\nNsim = 500;\n\n\nrandomDrawMat = randn(size(X2)[2], Nsim);\n\nmarketIndex = data.year;\n\nuniqueMarketIndex = sort(unique(data.year));\nmarketIndexMat = reduce(\n    hcat, \n    [marketIndex .== market for market in uniqueMarketIndex]\n    );\n\ndatalist = datalist_struct(\n    X1, \n    X2, \n    Z, \n    data.share, \n    marketIndex, \n    data.logit_share, \n    randomDrawMat, \n    marketIndexMat\n    );\n\n\n\n3.7.2 推定\nここでの推定結果が元のサポートサイトのものとかなり異なることに注意されたい。 元の推定では、ランダム係数の推計値が初期値からほとんど変わっていないように見える。 もしかすると、本のコードでは市場シェアの更新（永続代入演算子が用いられている）が正しくされていないのかもしれない。\n\ninitial_x = [0.3, 18, 0.01];\ndelta_ini = calculateMeanUtil(initial_x, datalist, datalist.logitshare);\n\n\nobjFunc_for_Optim = OnceDifferentiable(\n    x -> calculateGMMObjective(x, datalist, delta_ini),\n    initial_x;\n    autodiff = :forward\n    );\n@time resultGMM = optimize(\n    objFunc_for_Optim,\n    [0.0, 0.0, 0.0],\n    [Inf, Inf, Inf],\n    initial_x,\n    Fminbox(LBFGS()),\n    Optim.Options(show_trace = false)\n);\n\n\nresultGMM.minimizer\n\n3-element Vector{Float64}:\n  0.6407730207977352\n 14.72488892325358\n  1.689052459807443e-11\n\n\n\nW = inv(datalist.Z' * datalist.Z);    \ndelta = calculateMeanUtil(resultGMM.minimizer, datalist, delta_ini);\nbeta_hat = (\n    (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ \n    (datalist.X1' * datalist.Z * W * datalist.Z' * delta)\n);\n\nbeta_hat\n\n5-element Vector{Float64}:\n -31.984921285756943\n  -1.0841982623293536\n   0.1076677873797389\n   8.581036411670775\n   0.28298440012892323\n\n\n\n\n3.7.3 標準誤差の計算\n\nXi = delta - X1 * beta_hat;\nOmega_hat = reduce(+, Z[i,:] * Z[i,:]' .* Xi[i]^2 ./ N for i = 1:N);\nDdelta = ForwardDiff.jacobian(\n    x -> calculateMeanUtil(x, datalist, delta), \n    resultGMM.minimizer\n    );\nG = Z' * hcat(- X1, Ddelta) ./ N;\nAsyVarMat = (G' * W * G) \\ G' * W * Omega_hat * W * G * inv(G' * W * G);\nAse = sqrt.(diag(AsyVarMat) ./ N);\n\nDataFrame(\n    Var = [\n        \"Const\", \"Price\", \"Fuel Efficiency\", \"hppw\", \n        \"size\", \"random_price\", \"random_constant\", \"random_size\"\n        ],\n    Est = vcat(beta_hat, resultGMM.minimizer),\n    se = Ase\n)\n\n\n8×3 DataFrameRowVarEstseStringFloat64Float641Const-31.98496.918142Price-1.08421.347433Fuel Efficiency0.1076680.01158014hppw8.581043.135875size0.2829840.1278246random_price0.6407730.8455737random_constant14.724921.19748random_size1.68905e-111.79294"
  },
  {
    "objectID": "dynamic_game_estimation_2.html#パラメタの設定",
    "href": "dynamic_game_estimation_2.html#パラメタの設定",
    "title": "11  推定 2",
    "section": "11.1 パラメタの設定",
    "text": "11.1 パラメタの設定\n\nTransitionMat = [0.7 0.3; 0.4 0.6]\n\nRandom.seed!(123);\n\n\nParameters = [\n    0.3,\n    0.2,\n    -0.27,\n    0.45,\n    -0.15,\n    -2.10\n];\n\nparameterMat = hcat([\n    [Parameters[i]; Parameters[3:6]]\n    for i in 1:2\n]...);\n\n\nNumSimPeriods = 100;\nNumSimFirms = 2;\nNumSimulations = 1000;\nNumSimMarkets = 8;\n\nNumSimMarketsInData = 500;\n\nnumBootSample = 100;"
  },
  {
    "objectID": "dynamic_game_estimation_2.html#前章で生成したデータと推定したパラメタの読み込み",
    "href": "dynamic_game_estimation_2.html#前章で生成したデータと推定したパラメタの読み込み",
    "title": "11  推定 2",
    "section": "11.2 前章で生成したデータと推定したパラメタの読み込み",
    "text": "11.2 前章で生成したデータと推定したパラメタの読み込み\n\n@load \"tmp/dynamic_game/data_workspace.jld2\";\n@load \"tmp/dynamic_game/estimates_1.jld2\";\n\n\nInitialState = hcat(1:8, 1:8);;\n\n\nEVrandom = reshape(\n    -log.(-log.(rand(NumSimMarkets * NumSimPeriods * NumSimFirms * NumSimulations * 8 * 3))),\n    (NumSimMarkets, NumSimPeriods, NumSimFirms, NumSimulations, 8, 3)\n);\n\nUNIrandom = reshape(\n    rand(NumSimMarkets * NumSimPeriods * NumSimulations),\n    (NumSimMarkets, NumSimPeriods, NumSimulations)\n);\n\n\n@time Wstar = VSigmaGeneration(\n    CCP1Mat[:, 2],\n    CCP2Mat[:, 2],\n    TransitionMat,\n    EVrandom,\n    UNIrandom,\n    InitialState,\n    NumSimMarkets,\n    NumSimulations,\n    NumSimPeriods,\n    global_param\n);\n\nW1star = Wstar[1];\nW2star = Wstar[2];\n\n  1.297144 seconds (6.04 M allocations: 569.625 MiB, 9.94% gc time, 59.58% compilation time)\n\n\n\nparam1 = [parameterMat[:, 1]; 1];\nparam2 = [parameterMat[:, 2]; 1];\n\n\nDataFrame(\n    \"True value\" => exanteV1,\n    \"Simulated value\" => W1star' * param1,\n    \"Difference\" => exanteV1 - W1star' * param1\n)\n\n\n8×3 DataFrameRowTrue valueSimulated valueDifferenceFloat64Float64Float6414.65684.537180.11962224.587324.63857-0.051247136.568766.521980.046779746.158876.18534-0.026471654.612384.608420.0039614764.546174.58591-0.039740776.015815.874330.14148185.60885.69862-0.0898211\n\n\n\nDataFrame(\n    \"True value\" => exanteV2,\n    \"Simulated value\" => W2star' * param2,\n    \"Difference\" => exanteV2 - W2star' * param2\n)\n\n\n8×3 DataFrameRowTrue valueSimulated valueDifferenceFloat64Float64Float6414.441194.48669-0.045496926.178926.146460.032462334.380044.47488-0.094840545.776455.80853-0.0320854.401394.47127-0.069889865.629995.540350.089634174.342854.40536-0.062509585.229725.208720.0209918\n\n\n\nNormalized_TrueParam = [\n    Parameters[1] - ((1 - global_param.beta) / global_param.beta) * Parameters[5],\n    Parameters[3],\n    Parameters[4],\n    0,\n    Parameters[6] + Parameters[5],\n    Parameters[2] - ((1 - global_param.beta) / global_param.beta) * Parameters[5],\n    Parameters[3],\n    Parameters[4],\n    0,\n    Parameters[6] + Parameters[5],\n];\n\nnormparam1 = [Normalized_TrueParam[1:5]; 1];\nnormparam2 = [Normalized_TrueParam[6:10]; 1];\n\n\nDataFrame(\n    \"True value\" => exanteV1,\n    \"Simulated value (original param)\" => W1star' * param1,\n    \"Simulated value (normalized param)\" => W1star' * normparam1\n)\n\n\n8×3 DataFrameRowTrue valueSimulated value (original param)Simulated value (normalized param)Float64Float64Float6414.65684.537184.5371824.587324.638574.6385736.568766.521986.7094846.158876.185346.3728454.612384.608424.6084264.546174.585914.5859176.015815.874336.0618385.60885.698625.88612\n\n\n\nDataFrame(\n    \"True value\" => exanteV2,\n    \"Simulated value (original param)\" => W2star' * param2,\n    \"Simulated value (normalized param)\" => W2star' * normparam2\n)\n\n\n8×3 DataFrameRowTrue valueSimulated value (original param)Simulated value (normalized param)Float64Float64Float6414.441194.486694.4866926.178926.146466.3339634.380044.474884.4748845.776455.808535.9960354.401394.471274.4712765.629995.540355.7278574.342854.405364.4053685.229725.208725.39622\n\n\n\nprintln(\"Difference b/w two simulated values (with and without normalization)\")\nDataFrame(\n    \"Firm 1\" => W1star' * param1 - W1star' * normparam1,\n    \"Firm 2\" => W2star' * param2 - W2star' * normparam2,\n)\n\nDifference b/w two simulated values (with and without normalization)\n\n\n\n8×2 DataFrameRowFirm 1Firm 2Float64Float6412.15419e-111.96705e-1122.2764e-11-0.18753-0.18752.10454e-114-0.1875-0.187552.31068e-111.90594e-1162.28786e-11-0.18757-0.18752.11973e-118-0.1875-0.1875"
  },
  {
    "objectID": "dynamic_game_estimation_2.html#forward-simulationを用いたpesendorfer-and-schmidt-denglerによるパラメタの推定",
    "href": "dynamic_game_estimation_2.html#forward-simulationを用いたpesendorfer-and-schmidt-denglerによるパラメタの推定",
    "title": "11  推定 2",
    "section": "11.3 Forward simulationを用いたPesendorfer and Schmidt-Denglerによるパラメタの推定",
    "text": "11.3 Forward simulationを用いたPesendorfer and Schmidt-Denglerによるパラメタの推定\n\n@time Wstar = VSigmaGeneration(\n    EstimatedCCP1Mat[:, 2],\n    EstimatedCCP2Mat[:, 2],\n    EstimatedTransition,\n    EVrandom,\n    UNIrandom,\n    InitialState,\n    NumSimMarkets,\n    NumSimulations,\n    NumSimPeriods,\n    global_param\n);\n\nW1star = Wstar[1];\nW2star = Wstar[2];\n\n  0.278932 seconds (4.80 M allocations: 489.018 MiB, 19.05% gc time)\n\n\n\ninitial = [0.3375, 0.2375, -0.27, 0.45, -2.25];\n\n@time resultForwardPSD = optimize(\n    x -> Estimation_forward_PSD(\n        x,\n        W1star,\n        W2star,\n        EstimatedTransition,\n        EstimatedCCP1Mat,\n        EstimatedCCP2Mat,\n        global_param\n    ),\n    initial,\n    Optim.Options(show_trace = false)\n)\n\n\nbootindex = reshape(\n    sample(1:NumSimMarketsInData, NumSimMarketsInData * numBootSample),\n    (NumSimMarketsInData, numBootSample)\n);\n\nbootresult_transition = zeros(2, numBootSample);\nbootresult_CCP1 = zeros(8, numBootSample);\nbootresult_CCP2 = zeros(8, numBootSample);\nbootresult_payoff = zeros(5, numBootSample);\n\n\n@time for b in 1:numBootSample\n\n    bootsample = vcat(\n        [FakeData[FakeData[:, 1] .== bootindex[m, b], :] for m in 1:NumSimMarketsInData]...\n        );\n\n    output = Bootstrap_PS_forward(\n        bootsample, \n        global_param,\n        EVrandom,\n        UNIrandom,\n        InitialState,\n        NumSimMarkets,\n        NumSimulations,\n        NumSimPeriods\n        );\n\n    bootresult_payoff[:, b] = output[1].minimizer;\n    bootresult_CCP1[:, b] = output[2][:, 2]\n    bootresult_CCP2[:, b] = output[3][:, 2]\n    bootresult_transition[:, b] = diag(output[4]);\n\nend\n\n\nDataFrame(\n    \"True param\" => [Parameters[1:4]; Parameters[6]],\n    \"True param (normalized)\" => Normalized_TrueParam[[1, 6, 2, 3, 5]],\n    \"Estimates\" => resultForwardPSD.minimizer,\n    \"SE\" => vec(std(bootresult_payoff, dims = 2))\n)\n\n\n5×4 DataFrameRowTrue paramTrue param (normalized)EstimatesSEFloat64Float64Float64Float6410.30.33750.3948520.054466720.20.23750.3191430.05610273-0.27-0.27-0.3195760.037348840.450.450.4405780.09262895-2.1-2.25-2.223640.0186967"
  },
  {
    "objectID": "dynamic_game_estimation_2.html#bblの不等式推定量を用いたパラメタの推定",
    "href": "dynamic_game_estimation_2.html#bblの不等式推定量を用いたパラメタの推定",
    "title": "11  推定 2",
    "section": "11.4 BBLの不等式推定量を用いたパラメタの推定",
    "text": "11.4 BBLの不等式推定量を用いたパラメタの推定\n\nNumPerturbations = 200;\n\nPerturbedCCP1 = reshape(\n    clamp.(\n        repeat(EstimatedCCP1Mat[:, 2], NumPerturbations) + \n        rand(Normal(0, .1), 8 * NumPerturbations),\n        0.001, 0.999\n    ),\n    (8, NumPerturbations)\n);\n\nPerturbedCCP2 = reshape(\n    clamp.(\n        repeat(EstimatedCCP2Mat[:, 2], NumPerturbations) + \n        rand(Normal(0, .1), 8 * NumPerturbations),\n        0.001, 0.999\n    ),\n    (8, NumPerturbations)\n);\n\n\nW1_all = zeros(6, NumSimMarkets, NumPerturbations);\nW2_all = zeros(6, NumSimMarkets, NumPerturbations);\n\n\n@time for per in 1:NumPerturbations\n\n    W1_p = VSigmaGeneration(\n        PerturbedCCP1[:, per],\n        EstimatedCCP2Mat[:, 2],\n        EstimatedTransition,\n        EVrandom,\n        UNIrandom,\n        InitialState,\n        NumSimMarkets,\n        NumSimulations,\n        NumSimPeriods,\n        global_param\n    );\n    W1_all[:, :, per] = W1_p[1];\n\n    W2_p = VSigmaGeneration(\n        EstimatedCCP1Mat[:, 2],\n        PerturbedCCP2[:, per],\n        EstimatedTransition,\n        EVrandom,\n        UNIrandom,\n        InitialState,\n        NumSimMarkets,\n        NumSimulations,\n        NumSimPeriods,\n        global_param\n    );\n    W2_all[:, :, per] = W2_p[2];\n\nend\n\n\n@time BBLobjective(\n        initial,\n        NumPerturbations,\n        W1star,\n        W2star,\n        W1_all,\n        W2_all\n    )\n\n\ninitial = [0.3, 0.2, -0.27, 0.45, -2.1];\n\n@time resultBBL = optimize(\n    x -> BBLobjective(\n        x,\n        NumPerturbations,\n        W1star,\n        W2star,\n        W1_all,\n        W2_all\n    ),\n    initial,\n    Optim.Options(show_trace = false)\n)\n\n\nbootindex = reshape(\n    sample(1:NumSimMarketsInData, NumSimMarketsInData * numBootSample),\n    (NumSimMarketsInData, numBootSample)\n);\n\nbootresult_transition_BBL = zeros(2, numBootSample);\nbootresult_CCP1_BBL = zeros(8, numBootSample);\nbootresult_CCP2_BBL = zeros(8, numBootSample);\nbootresult_payoff_BBL = zeros(5, numBootSample);\n\n\n@time for b in 1:numBootSample\n\n    bootsample = vcat(\n        [FakeData[FakeData[:, 1] .== bootindex[m, b], :] for m in 1:NumSimMarketsInData]...\n        );\n\n    output = Bootstrap_BBL(\n        bootsample, \n        global_param,\n        EVrandom,\n        UNIrandom,\n        InitialState,\n        NumSimMarkets,\n        NumSimulations,\n        NumSimPeriods,\n        NumPerturbations\n        );\n\n    bootresult_payoff_BBL[:, b] = output[1].minimizer;\n    bootresult_CCP1_BBL[:, b] = output[2][:, 2]\n    bootresult_CCP2_BBL[:, b] = output[3][:, 2]\n    bootresult_transition_BBL[:, b] = diag(output[4]);\n\nend\n\n\nDataFrame(\n    \"True param\" => [Parameters[1:4]; Parameters[6]],\n    \"True param (normalized)\" => Normalized_TrueParam[[1, 6, 2, 3, 5]],\n    \"Estimates\" => resultBBL.minimizer,\n    \"SE\" => vec(std(bootresult_payoff_BBL, dims = 2))\n)\n\n\n5×4 DataFrameRowTrue paramTrue param (normalized)EstimatesSEFloat64Float64Float64Float6410.30.33750.3613640.15631520.20.23750.1701430.1675673-0.27-0.27-0.2928710.15185440.450.450.5253810.2626095-2.1-2.25-2.100090.0884199\n\n\n\nDataFrame(\n    \"True param\" => [Parameters[1:4]; Parameters[6]],\n    \"True param (normalized)\" => Normalized_TrueParam[[1, 6, 2, 3, 5]],\n    \"Estimates (Forward P-SD)\" => resultForwardPSD.minimizer,\n    \"SE (Forward P-SD)\" => vec(std(bootresult_payoff, dims = 2)),\n    \"Estimates (BBL)\" => resultBBL.minimizer,\n    \"SE (BBL)\" => vec(std(bootresult_payoff_BBL, dims = 2))\n)\n\n\n5×6 DataFrameRowTrue paramTrue param (normalized)Estimates (Forward P-SD)SE (Forward P-SD)Estimates (BBL)SE (BBL)Float64Float64Float64Float64Float64Float6410.30.33750.3948520.05446670.3613640.15631520.20.23750.3191430.05610270.1701430.1675673-0.27-0.27-0.3195760.0373488-0.2928710.15185440.450.450.4405780.09262890.5253810.2626095-2.1-2.25-2.223640.0186967-2.100090.0884199"
  },
  {
    "objectID": "dynamic_game_counterfactual.html#ベースラインの均衡",
    "href": "dynamic_game_counterfactual.html#ベースラインの均衡",
    "title": "12  反実仮想シミュレーション",
    "section": "12.1 ベースラインの均衡",
    "text": "12.1 ベースラインの均衡\n\nBaselineParameterValues = [\n    0.3,\n    -0.27,\n    0.45,\n    -0.15,\n    -2.10,\n    0.2,\n    -0.27,\n    0.45,\n    -0.15,\n    -2.10\n];\n\nBaselineParameterMat = reshape(BaselineParameterValues, (5, 2));\n\n\nprofitFirm1 = calculateFirmProfit(\n    BaselineParameterMat,\n    global_param.entryMat,\n    global_param.numFirmsVec,\n    global_param.economyVec,\n    global_param.possibleActionArray,\n    1\n);\nprofitFirm2 = calculateFirmProfit(\n    BaselineParameterMat,\n    global_param.entryMat,\n    global_param.numFirmsVec,\n    global_param.economyVec,\n    global_param.possibleActionArray,\n    2\n);\n\n\ndata_base_struct = createInitialDataStruct(\n    profitFirm1,\n    profitFirm2,\n    TransitionMat,\n    global_param\n);\n\n\n@time calculateMPE!(\n    data_base_struct,\n    TransitionMat, \n    profitFirm1, \n    profitFirm2, \n    global_param\n    );\n\nCCP1Matbase = data_base_struct.CCP1Mat;\nCCP2Matbase = data_base_struct.CCP2Mat;\nexanteV1base = data_base_struct.exanteV1;\nexanteV2base = data_base_struct.exanteV2;\n\n  1.587827 seconds (5.63 M allocations: 364.474 MiB, 6.94% gc time, 99.75% compilation time)\n\n\n\nn1, n2 = simulateEntryFirms(\n    TransitionMat,\n    CCP1Matbase,\n    CCP2Matbase,\n    global_param,\n    NumSimPeriods\n);"
  },
  {
    "objectID": "dynamic_game_counterfactual.html#反実仮想シミュレーション-差別化戦略",
    "href": "dynamic_game_counterfactual.html#反実仮想シミュレーション-差別化戦略",
    "title": "12  反実仮想シミュレーション",
    "section": "12.2 反実仮想シミュレーション: 差別化戦略",
    "text": "12.2 反実仮想シミュレーション: 差別化戦略\n\nCounterfactualParameterValues = [\n    0.6,\n    -0.27,\n    0.45,\n    -0.15,\n    -2.10,\n    0.2,\n    -0.27,\n    0.45,\n    -0.15,\n    -2.10\n];\n\nCounterfactualParameterMat = reshape(\n    CounterfactualParameterValues, \n    (5, 2)\n    );\n\nprofitFirm1_cf = calculateFirmProfit(\n    CounterfactualParameterMat,\n    global_param.entryMat,\n    global_param.numFirmsVec,\n    global_param.economyVec,\n    global_param.possibleActionArray,\n    1\n);\nprofitFirm2_cf = calculateFirmProfit(\n    CounterfactualParameterMat,\n    global_param.entryMat,\n    global_param.numFirmsVec,\n    global_param.economyVec,\n    global_param.possibleActionArray,\n    2\n);\n\n\ndata_cf_struct = createInitialDataStruct(\n    profitFirm1_cf,\n    profitFirm2_cf,\n    TransitionMat,\n    global_param\n);\n\n@time output = calculateMPE!(\n    data_cf_struct,\n    TransitionMat,\n    profitFirm1_cf,\n    profitFirm2_cf,\n    global_param\n    );\n\nCCP1Matcf = data_cf_struct.CCP1Mat;\nCCP2Matcf = data_cf_struct.CCP2Mat;\nexanteV1cf = data_cf_struct.exanteV1;\nexanteV2cf = data_cf_struct.exanteV2;\n\n  0.000297 seconds (3.65 k allocations: 392.828 KiB)\n\n\n\nn1_cf, n2_cf = simulateEntryFirms(\n    TransitionMat,\n    CCP1Matcf,\n    CCP2Matcf,\n    global_param,\n    NumSimPeriods\n);\n\n\nplot1 = plot(\n    1:NumSimPeriods,\n    n1,\n    linestyle = :dash,\n    title = \"企業1の店舗存在確率\",\n    label = \"現状維持\"\n);\nplot!(\n    1:NumSimPeriods,\n    n1_cf,\n    label = \"新ブランド展開           \"\n);\nxlabel!(\"期間\")\nylabel!(\"店舗存在確率\")\n\n\nplot2 = plot(\n    1:NumSimPeriods,\n    n2,\n    linestyle = :dash,\n    title = \"企業2の店舗存在確率\",\n    label = \"現状維持\"\n);\nplot!(\n    1:NumSimPeriods,\n    n2_cf,\n    label = \"新ブランド展開           \"\n);\nxlabel!(\"期間\")\nylabel!(\"店舗存在確率\")\n\nplot(plot1, plot2, layout = (1, 2))\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n4\n\n\n6\n\n\n8\n\n\n10\n\n\n12\n\n\n14\n\n\n期間\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.2\n\n\n0.4\n\n\n0.6\n\n\n店舗存在確率\n\n\n企業1の店舗存在確率\n\n\n\n\n\n\n\n現状維持\n\n\n\n新ブランド展開           \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2\n\n\n4\n\n\n6\n\n\n8\n\n\n10\n\n\n12\n\n\n14\n\n\n期間\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0.0\n\n\n0.1\n\n\n0.2\n\n\n0.3\n\n\n0.4\n\n\n0.5\n\n\n店舗存在確率\n\n\n企業2の店舗存在確率\n\n\n\n\n\n\n\n現状維持\n\n\n\n新ブランド展開           \n\n\n\n\n\ndiff_value_1 = exanteV1cf - exanteV1base;\n\nDataFrame(\n    exanteV1base = exanteV1base,\n    exanteV1cf = exanteV1cf,\n    diff_value_1 = diff_value_1\n)\n\n\n8×3 DataFrameRowexanteV1baseexanteV1cfdiff_value_1Float64Float64Float6414.65685.339430.68263324.587325.250260.66294336.568767.742261.1734946.158877.318751.1598854.612385.282170.66978564.546175.196670.65050576.015817.181051.1652485.60886.75991.1511"
  },
  {
    "objectID": "entry_exit_application.html#データの読み込み",
    "href": "entry_exit_application.html#データの読み込み",
    "title": "6  応用編",
    "section": "6.1 データの読み込み",
    "text": "6.1 データの読み込み\n\ndata_raw = data = CSV.File(\n    open(\n        read, \n        \"data/entry_exit_application/data_hospital_chapter6.csv\",\n        enc\"UTF-8\"\n        ),\n    missingstring = [\"NA\", \"\"],\n    ) |> DataFrame\nfirst(data, 5)\n\n\n5×20 DataFrameRowHospitalIDPrefectureCityCodeSecondaryAreaNameSecondaryAreaCodeManagementKyukyuKinouSienHyokaDepNeurologyDepNeurosurgeryNumBedsMRINumOwnTeslaPopulationMensekiPopDensityTaxableIncomeMRIOwnDumInt64String15Int64String31Int64?String?Int64?Int64?Int64?Int64?Int64?Int64?Int64?Int64Int64?Int64?Float64?Float64?Int64?Int6411北海道1101札幌104共済1000002431222018946.424743.43017122北海道1101札幌104財団0000001801022018946.424743.43017133北海道1101札幌104医療法人1000001101122018946.424743.43017144北海道1101札幌104医療法人1000111343222018946.424743.43017155北海道1101札幌104医療法人0000002501222018946.424743.430171\n\n\n\ndata_cleaned = data_raw[:, :];\nreplace!(data_cleaned.Management, missing => \"\");\ndata_cleaned[!, :DaigakuDum] = in([\"公立大学法人\", \"国（国立大学法人）\", \"私立学校法人\"]).(data_cleaned.Management);\ndata_cleaned[!, :ZeroBedDum] = (data_cleaned[:, :NumBeds] .== 0);\n\ndata_cleaned[!, :NumBeds] = data_cleaned[:, :NumBeds] ./ 100.0;\ndata_cleaned[!, :LogNumBeds] = log.(data_cleaned[:, :NumBeds] .+ 0.01);\ndata_cleaned[!, :Population] = data_cleaned[:, :Population] ./ 1e+6;\ndata_cleaned[!, :Menseki] = data_cleaned[:, :Menseki] ./ 100.0;\ndata_cleaned[!, :TaxableIncome] = data_cleaned[:, :TaxableIncome] ./ 1000.0;\ndata_cleaned[!, :LogPop] = log.(data_cleaned[:, :Population]);\ndata_cleaned[!, :LogIncome] = log.(data_cleaned[:, :TaxableIncome]);"
  },
  {
    "objectID": "entry_exit_application.html#企業レベル変数の記述統計",
    "href": "entry_exit_application.html#企業レベル変数の記述統計",
    "title": "6  応用編",
    "section": "6.2 企業レベル変数の記述統計",
    "text": "6.2 企業レベル変数の記述統計\n\nlistVars = [\n    \"Kyukyu\", \"Kinou\", \"Sien\", \"Hyoka\", \"DepNeurology\",\n    \"DepNeurosurgery\", \"NumBeds\", \"ZeroBedDum\", \"DaigakuDum\"\n]\ntable_mean = combine(\n    groupby(data_cleaned, :MRIOwnDum),\n    [Symbol(variable) for variable in listVars] .=> \n    x -> mean(skipmissing(x))\n);\ntable_sd = combine(\n    groupby(data_cleaned, :MRIOwnDum),\n    [Symbol(variable) for variable in listVars] .=> \n    x -> std(skipmissing(x))\n);\n\nDataFrame(\n    variable = listVars,\n    meanOwnMRI = Matrix(table_mean)[2, 2:end],\n    sdOwnMRI = Matrix(table_sd)[2, 2:end],\n    meanNotOwnMRI_ = Matrix(table_mean)[1, 2:end],\n    sdNotOwnMRI = Matrix(table_sd)[1, 2:end]\n)\n\n\n9×5 DataFrameRowvariablemeanOwnMRIsdOwnMRImeanNotOwnMRI_sdNotOwnMRIStringFloat64Float64Float64Float641Kyukyu0.7116930.4530420.3021310.4592232Kinou0.01994640.1398370.002549630.0504343Sien0.04763320.2130210.004006560.06317624Hyoka0.4334620.4956270.1693680.3751115DepNeurology0.3930810.4885070.1219910.3273066DepNeurosurgery0.5696430.49520.08211940.2745727NumBeds2.077281.94150.3918610.7105018ZeroBedDum0.0583160.2343750.4529340.4978259DaigakuDum0.04160480.1997140.004547940.067291\n\n\n\nvcat(\n    calculateShareOwnMRI(data_cleaned),\n    calculateShareOwnMRI(\n        dropmissing(data_cleaned, :Kyukyu)[\n            dropmissing(data_cleaned, :Kyukyu).Kyukyu .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_cleaned, :Sien)[\n            dropmissing(data_cleaned, :Sien).Sien .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_cleaned, :Hyoka)[\n            dropmissing(data_cleaned, :Hyoka).Hyoka .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_cleaned, :DepNeurology)[\n            dropmissing(data_cleaned, :DepNeurology).DepNeurology .== 1,\n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_cleaned, :DepNeurosurgery)[\n            dropmissing(data_cleaned, :DepNeurosurgery).DepNeurosurgery .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_cleaned, :LogNumBeds)[\n            dropmissing(data_cleaned, :LogNumBeds).LogNumBeds .>= log(1.2), \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_cleaned, :DaigakuDum)[\n            dropmissing(data_cleaned, :DaigakuDum).DaigakuDum .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_cleaned, :ZeroBedDum)[\n            dropmissing(data_cleaned, :ZeroBedDum).ZeroBedDum .== 1, \n            :]\n            ),\n)\n\n9×3 Matrix{Float64}:\n 8862.0  3365.0  37.97\n 4051.0  2392.0  59.05\n  182.0   160.0  87.91\n 2386.0  1456.0  61.02\n 1987.0  1318.0  66.33\n 2365.0  1914.0  80.93\n 2264.0  1932.0  85.34\n  165.0   140.0  84.85\n 2674.0   196.0   7.33"
  },
  {
    "objectID": "entry_exit_application.html#berry-1992-による推定",
    "href": "entry_exit_application.html#berry-1992-による推定",
    "title": "6  応用編",
    "section": "6.3 Berry (1992) による推定",
    "text": "6.3 Berry (1992) による推定\nサポートサイトの推定方法と異なり、ここでは「各市での参入病院数」のみを用い、「どの病院が参入したか」の情報は用いない。 Berry (1992)で述べられているように、パラメタの推定そのものにはどの病院が参入したかの情報は必要ないためである。 ただし、後の推定結果の評価や反実仮想分析では、「病床数が多い病院から参入するかどうかを決定する」という仮定のもと、どの病院が参入するかを予測する。\n\ndata_processed_pre = dropmissing(data_cleaned[:, [\n            :CityCode, :Kyukyu, :Kinou, :Sien, :Hyoka,\n            :DepNeurology, :DepNeurosurgery, :LogNumBeds,\n            :ZeroBedDum, :DaigakuDum,\n            :Menseki, :LogPop, :LogIncome, :MRIOwnDum\n            ]]);\nfirst(data_processed_pre, 5)\n\n\n5×14 DataFrameRowCityCodeKyukyuKinouSienHyokaDepNeurologyDepNeurosurgeryLogNumBedsZeroBedDumDaigakuDumMensekiLogPopLogIncomeMRIOwnDumInt64Int64Int64Int64Int64Int64Int64Float64BoolBoolFloat64Float64Float64Int64111011000000.891998falsefalse0.4642-1.513271.104261211010000000.593327falsefalse0.4642-1.513271.104261311011000000.10436falsefalse0.4642-1.513271.104261411011000110.300105falsefalse0.4642-1.513271.104261511010000000.920283falsefalse0.4642-1.513271.104261\n\n\n\nRandom.seed!(123)\ndata_processed = processDataForBerryEst(data_processed_pre);\nfirst(data_processed, 5)\n\n\n5×18 DataFrameRowCityCodeKyukyuKinouSienHyokaDepNeurologyDepNeurosurgeryLogNumBedsZeroBedDumDaigakuDumMensekiLogPopLogIncomeMRIOwnDumTieEntryOrdernumPotenHosnumEntryObsEntryOrderIdInt64Int64Int64Int64Int64Int64Int64Float64BoolBoolFloat64Float64Float64Int64Float64Int64Int64Int64111011000112.19165falsetrue0.4642-1.513271.1042610.69220941171211011000112.0931falsefalse0.4642-1.513271.1042610.032096741172311010000101.61939falsefalse0.4642-1.513271.1042610.13655141173411010000101.59939falsefalse0.4642-1.513271.1042610.33415241174511010000001.14103falsefalse0.4642-1.513271.1042610.42732841175\n\n\n\nnumPotenHos_max = 4;\ndata_processed = data_processed[\n    data_processed.EntryOrderId .<= numPotenHos_max, \n    :];\ntransform!(\n    groupby(data_processed, :CityCode),\n    :MRIOwnDum => sum => :numEntryObs,\n    nrow => :numPotenHos\n);\ndata_processed[!, :Const] .= 1;\nvcat(\n    calculateShareOwnMRI(data_processed),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :Kyukyu)[\n            dropmissing(data_processed, :Kyukyu).Kyukyu .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :Sien)[\n            dropmissing(data_processed, :Sien).Sien .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :Hyoka)[\n            dropmissing(data_processed, :Hyoka).Hyoka .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :DepNeurology)[\n            dropmissing(data_processed, :DepNeurology).DepNeurology .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :DepNeurosurgery)[\n            dropmissing(data_processed, :DepNeurosurgery).DepNeurosurgery .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :LogNumBeds)[\n            dropmissing(data_processed, :LogNumBeds).LogNumBeds .>= log(1.2), \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :DaigakuDum)[\n            dropmissing(data_processed, :DaigakuDum).DaigakuDum .== 1, \n            :]\n            ),\n    calculateShareOwnMRI(\n        dropmissing(data_processed, :ZeroBedDum)[\n            dropmissing(data_processed, :ZeroBedDum).ZeroBedDum .== 1, \n            :]\n            ),\n)\n\n9×3 Matrix{Float64}:\n 4112.0  2246.0  54.62\n 2476.0  1745.0  70.48\n  151.0   141.0  93.38\n 1422.0  1097.0  77.14\n 1276.0  1014.0  79.47\n 1697.0  1472.0  86.74\n 1857.0  1628.0  87.67\n  125.0   115.0  92.0\n  646.0    41.0   6.35\n\n\n\nnumSim = 100;\n\nuniqueCityCode = unique(data_processed.CityCode);\nnumCity = length(uniqueCityCode);\nnumHos = nrow(data_processed);\nnumEntryObs = combine(\n    groupby(data_processed, :CityCode),\n    :MRIOwnDum => sum => :numEntryObs\n).numEntryObs;\n\ncityIndex = data_processed.CityCode .== uniqueCityCode';\n\n\nu_m0 = cityIndex * randn(numCity, numSim);\nu_mIm = randn(numHos, numSim);\n\n\nparam_init = [\n    -0.612340533,   -5.525423772,   -0.505275676,   \n    -0.32531026,    -1.04162392,    -0.991878025,   \n    -3.87040966,    -1.272714254,   2.684741676,    \n    0.040555764,    0.426448612,    -1.399627382,   \n    0.990975782,    0.958075433\n];\n\n\nfunction obj_for_Optim(x::Vector, grad::Vector)\n    if length(grad) != 0\n        ForwardDiff.gradient!(\n            grad, \n            x -> calculateBerryObjectiveAtCityLevel(\n                x, \n                data_processed, \n                u_m0, \n                u_mIm, \n                numEntryObs\n                ), \n            x\n            )\n    end\n    return calculateBerryObjectiveAtCityLevel(\n        x, \n        data_processed, \n        u_m0, \n        u_mIm, \n        numEntryObs\n    )\nend\n\nopt = NLopt.Opt(:LN_NELDERMEAD, length(param_init))\nopt.lower_bounds = [repeat([-Inf], 13); -1.0]\nopt.upper_bounds = [repeat([Inf], 13); 1.0]\n\nopt.min_objective = obj_for_Optim;\n@time (minf, minx, ret) = NLopt.optimize(opt, param_init)\n\n@printf(\n    \"Minimized objective value: %.3f \\n\", \n    minf\n    )\n[param_init minx]\n\n 15.410078 seconds (36.69 M allocations: 29.563 GiB, 11.35% gc time, 9.89% compilation time)\n\n\nMinimized objective value: 0.374 \n\n\n14×2 Matrix{Float64}:\n -0.612341   -0.655829\n -5.52542    -8.41047\n -0.505276   -0.491684\n -0.32531    -0.44966\n -1.04162    -1.25152\n -0.991878   -1.0654\n -3.87041    -3.52228\n -1.27271    -1.11907\n  2.68474     2.58767\n  0.0405558   0.033967\n  0.426449    0.394342\n -1.39963    -1.44356\n  0.990976    1.08858\n  0.958075    0.963786\n\n\n\nnumBootstrap = 100;\nbootEstMat = zeros(length(minx), numBootstrap)\n\n@time for bootIndex in 1:numBootstrap\n\n    bootCitySample = sample(uniqueCityCode, numCity, replace = true);\n    df_boot = reduce(\n        vcat,\n        [\n            transform(\n                data_processed[\n                    data_processed.CityCode .== bootCitySample[city], \n                    :],\n                :CityCode => (x -> city) => :CityCode\n            )\n            for city in 1:numCity\n        ]\n    );\n\n    numHos_boot = nrow(df_boot);\n\n    numEntryObs_boot = combine(\n        groupby(df_boot, :CityCode),\n        :MRIOwnDum => sum => :numEntryObs\n    ).numEntryObs;\n\n    uniqueCityCode_boot = unique(df_boot.CityCode);\n    cityIndex_boot = df_boot.CityCode .== uniqueCityCode_boot';\n\n    u_m0_boot = cityIndex_boot * randn(numCity, numSim);\n    u_mIm_boot = randn(numHos_boot, numSim);\n\n    function obj_for_Optim(x::Vector, grad::Vector)\n        if length(grad) != 0\n            ForwardDiff.gradient!(\n                grad, \n                x -> calculateBerryObjectiveAtCityLevel(\n                    x, \n                    df_boot, \n                    u_m0_boot, \n                    u_mIm_boot, \n                    numEntryObs_boot\n                    ), \n                x\n                )\n        end\n        return calculateBerryObjectiveAtCityLevel(\n            x, \n            df_boot, \n            u_m0_boot, \n            u_mIm_boot, \n            numEntryObs_boot\n            )\n    end\n\n    opt_boot = NLopt.Opt(:LN_NELDERMEAD, length(param_init))\n    opt_boot.lower_bounds = [repeat([-Inf], 13); -1.0]\n    opt_boot.upper_bounds = [repeat([Inf], 13); 1.0]\n\n    opt_boot.min_objective = obj_for_Optim;\n    (minf_boot, minx_boot, ret_boot) = NLopt.optimize(opt_boot, param_init)\n    bootEstMat[:, bootIndex] .= minx_boot;\n\nend"
  },
  {
    "objectID": "entry_exit_application.html#反実仮想分析",
    "href": "entry_exit_application.html#反実仮想分析",
    "title": "6  応用編",
    "section": "6.5 反実仮想分析",
    "text": "6.5 反実仮想分析\n\ndata_cf = copy(data_processed);\nsort!(\n    data_cf, [\n        :CityCode, :DepNeurology, :DepNeurosurgery, \n        :LogNumBeds, :TieEntryOrder\n    ], \n    rev = [false, true, true, true, true]\n    );\ntransform!(\n    groupby(data_cf, :CityCode), \n    :numPotenHos => (x -> 1:length(x)) => :EntryOrderId\n    );\n\nprofitExcludeCompetition_cf = calculateProfitExcludeCompetition(\n    berry_est,\n    data_cf,\n    u_m0,\n    u_mIm\n);\n\nprofitExcludeCompetition_cf[\n    (data_cf.DepNeurology .== 1) .| (data_cf.DepNeurosurgery .== 1), \n    :] .= 1e+5;\n\n\neach_entry_mat_cf = calculateEquilibriumNumEntry(\n    data_cf,\n    delta_est,\n    profitExcludeCompetition_cf\n);\n\nentryProb_cf = mean(simulateEntryByOrder(\n    delta_est,\n    cityIndex,\n    profitExcludeCompetition_cf,\n    each_entry_mat_cf\n), dims = 2)[:, 1];\n\n\n6.5.1 すべての病院\nここでは、各市でいくつの病院がMRIを導入するかのシミュレーション結果を示す。 神経内科・外科を持つ病院がMRIの所有を義務付けられているという反実仮想のもとでは、多くの市でMRIを所有する病院の数が増えている。\n\nentryPred_cf = entryProb_cf .> 0.5;\n\ndata_predicted_cf = copy(data_cf);\ndata_predicted_cf[!, :entryProb] = entryProb_cf;\ndata_predicted_cf[!, :entryPred] = entryPred_cf;\ndata_predicted_cf_agg = combine(\n    groupby(data_predicted_cf, :CityCode),\n    :MRIOwnDum => sum => :Actual,\n    :entryPred => sum => :CounterFactual\n);\n\ndata_predicted_cf_agg = stack(data_predicted_cf_agg, [:Actual, :CounterFactual]);\ndata_predicted_cf_sum = combine(groupby(\n    vcat(\n        data_predicted_agg, \n        data_predicted_cf_agg[\n            data_predicted_cf_agg.variable .== \"CounterFactual\", \n            :]\n            ),\n    [:variable, :value]\n    ), nrow);\n\ntransform!(\n    data_predicted_cf_sum, \n    :variable => \n    (\n        x -> categorical(\n            x; ordered = true, \n            levels = [\"Actual\", \"Predict\", \"CounterFactual\"]\n            )\n            ) => \n    :variable\n    )\nsort!(data_predicted_cf_sum, [:variable, :value]);\ngroupedbar(\n    data_predicted_cf_sum.nrow, \n    group = data_predicted_cf_sum.variable,\n    xlabel = \"Number of hospitals in a city\", \n    ylabel = \"Number of cities\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvcat(\n    combine(groupby(\n        data_predicted_agg, :variable\n        ), :value => sum),\n    combine(groupby(\n        data_predicted_cf_agg, :variable\n        ), :value => sum) |> \n        filter(:variable => (x -> x .== \"CounterFactual\"))\n)\n\n\n3×2 DataFrameRowvariablevalue_sumStringInt641Actual22462Predict22343CounterFactual2484\n\n\n\n\n6.5.2 神経内科・外科を持たない病院のみ\nここでは、神経内科・外科を持たない病院のみを考え、MRIを所有する病院数の変化を見る。 神経内科・外科を持つ病院がMRIを所有するため、そうでない病院はMRIを所有することが少なくなっている。\n\ndata_predicted_agg_wo_neuro = combine(\n    groupby(\n        filter(\n            [:DepNeurology, :DepNeurosurgery] => \n            ((d1, d2) -> (d1 .!= 1) .& (d2 .!= 1)), \n            data_predicted\n            ),\n        :CityCode\n        ),\n    :MRIOwnDum => sum => :Actual,\n    :entryPred => sum => :Predict\n);\n\ndata_predicted_agg_wo_neuro = stack(\n    data_predicted_agg_wo_neuro, [:Actual, :Predict]\n    );\ndata_predicted_sum_wo_neuro = combine(\n    groupby(data_predicted_agg_wo_neuro, [:variable, :value]), \n    nrow\n    );\n\ndata_predicted_cf_agg_wo_neuro = combine(\n    groupby(\n        filter(\n            [:DepNeurology, :DepNeurosurgery] => \n            ((d1, d2) -> (d1 .!= 1) .& (d2 .!= 1)), \n            data_predicted_cf\n            ),\n        :CityCode\n        ),\n    :MRIOwnDum => sum => :Actual,\n    :entryPred => sum => :CounterFactual\n);\n\ndata_predicted_cf_agg_wo_neuro = stack(\n    data_predicted_cf_agg_wo_neuro, \n    [:Actual, :CounterFactual]\n    );\n\ndata_predicted_cf_sum_wo_neuro = combine(groupby(\n    vcat(\n        data_predicted_agg_wo_neuro, \n        data_predicted_cf_agg_wo_neuro[data_predicted_cf_agg_wo_neuro.variable .== \"CounterFactual\", :]\n        ),\n    [:variable, :value]\n    ), nrow)\n\ntransform!(\n    data_predicted_cf_sum_wo_neuro, \n    :variable => \n    (x -> categorical(x; ordered = true, levels = [\"Actual\", \"Predict\", \"CounterFactual\"])) => \n    :variable\n    )\nsort!(data_predicted_cf_sum_wo_neuro, [:variable, :value]);\ngroupedbar(\n    data_predicted_cf_sum_wo_neuro.nrow, \n    group = data_predicted_cf_sum_wo_neuro.variable,\n    xlabel = \"Number of hospitals in a city\", \n    ylabel = \"Number of cities\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvcat(\n    combine(groupby(\n        data_predicted_agg_wo_neuro, :variable\n        ), :value => sum),\n    combine(groupby(\n        data_predicted_cf_agg_wo_neuro, :variable\n        ), :value => sum) |> \n        filter(:variable => (x -> x .== \"CounterFactual\"))\n)\n\n\n3×2 DataFrameRowvariablevalue_sumStringInt641Actual5212Predict3673CounterFactual340\n\n\n\ndata_predicted_cf[!, :Top25pct_NumBeds] = (\n    data_predicted_cf.LogNumBeds .>= log(1.2)\n);\ndata_predicted_cf[!, :NotNeuro] = (\n    (data_predicted_cf.DepNeurology .!= 1) .&\n    (data_predicted_cf.DepNeurosurgery .!= 1)\n);\n\ntableActCounterFactual = vcat([\n        sum.(\n            eachcol(data_predicted_cf[\n                data_predicted_cf[:, variable] .== 1, \n                [:MRIOwnDum, :entryPred]\n                ])\n        )'\n        for variable in listVarsShort\n    ]...);\n\ndfActCounterFactual = vcat(\n    DataFrame(\n        Actual = sum(data_predicted_cf.MRIOwnDum),\n        CounterFactual = sum(data_predicted_cf.entryPred)\n    ),\n    DataFrame(\n        Actual = tableActCounterFactual[:, 1],\n        CounterFactual = tableActCounterFactual[:, 2]\n    )\n);\n\ndfActCounterFactual[:, :Predict] = dfActPred.Predict;\n\ndfActCounterFactualStack = stack(\n    dfActCounterFactual, \n    [:Actual, :Predict, :CounterFactual]\n    );\ndfActCounterFactualStack[:, :category] = repeat([\"All\"; listVarsShort], 3);\n\ntransform!(\n    dfActCounterFactualStack, \n    :variable => \n    (\n        x -> categorical(\n            x; \n            ordered = true, \n            levels = [\"Actual\", \"Predict\", \"CounterFactual\"]\n            )\n        ) => \n    :variable\n    );\ngroupedbar(\n    dfActCounterFactualStack.category, \n    dfActCounterFactualStack.value,\n    group = dfActCounterFactualStack.variable,\n    xlabel = \"Number of hospitals in a city\", \n    ylabel = \"Number of cities\",\n    bar_width = 0.67,\n    lw = 0,\n    xrotation = 30\n)"
  },
  {
    "objectID": "single_agent_dynamic_application.html#前章で生成したデータの読み込み",
    "href": "single_agent_dynamic_application.html#前章で生成したデータの読み込み",
    "title": "8  応用編",
    "section": "8.1 前章で生成したデータの読み込み",
    "text": "8.1 前章で生成したデータの読み込み\n\ndata_gen = CSV.read(\"tmp/single_agent_dynamic_basic/data_gen.csv\", DataFrame);\nfirst(data_gen, 3)\n\n\n3×9 DataFrameRowstateactionperiodconsumer_idpricemileageprice_lagmileage_lagaction_lagInt64Int64Int64Int64Int64Int64Int64?Int64?Int64?160481125000missingmissingmissing212048212500525000031804831250010250050"
  },
  {
    "objectID": "single_agent_dynamic_application.html#前章で推定したパラメタの読み込み",
    "href": "single_agent_dynamic_application.html#前章で推定したパラメタの読み込み",
    "title": "8  応用編",
    "section": "8.2 前章で推定したパラメタの読み込み",
    "text": "8.2 前章で推定したパラメタの読み込み\n\nkappa_est = deserialize(\"tmp/single_agent_dynamic_basic/kappa_est.ser\");\nlambda_est = deserialize(\"tmp/single_agent_dynamic_basic/lambda_est.ser\");\ntheta_est = deserialize(\"tmp/single_agent_dynamic_basic/theta_est.ser\");\n\n\ntheta_true = [0.004, 0.003];\nbeta = 0.99;\nEuler_const = Float64(MathConstants.eulergamma);\nnum_choice = 2;\n\n\nprice_states = 2000:100:2500;\nmileage_states = 0:5:100;\nnum_price_states = length(price_states);\nnum_mileage_states = length(mileage_states);\nnum_states = num_price_states * num_mileage_states;\n\nstates_matrix = Matrix(\n  reshape(\n    reinterpret(\n      Int, \n      collect(Iterators.product(price_states, mileage_states))\n      ), \n    (2, :))'\n    );\n\n\ndescribe(\n  data_gen[:, [:price, :mileage, :action]], \n  :all\n  )[:, [:variable, :mean, :std, :min, :max]]\n\n\n3×5 DataFrameRowvariablemeanstdminmaxSymbolFloat64Float64Int64Int641price2322.63151.826200025002mileage33.019823.692401003action0.029150.16822801"
  },
  {
    "objectID": "single_agent_dynamic_application.html#二段階推定法",
    "href": "single_agent_dynamic_application.html#二段階推定法",
    "title": "8  応用編",
    "section": "8.3 二段階推定法",
    "text": "8.3 二段階推定法\n\n8.3.1 推定されたパラメタに基づくState transition matrixの生成\n\nmileage_trans_mat_hat = generateMileageTransition(\n  kappa_est, \n  num_mileage_states\n  );\n\nprice_trans_mat_hat = generatePriceTransition(\n  lambda_est, \n  num_price_states\n);\n\ntrans_mat_hat = Array{Float64}(undef, num_states, num_states, num_choice);\nfor i in 1:num_choice\n    trans_mat_hat[:, :, i] = kron(mileage_trans_mat_hat[:, :, i], price_trans_mat_hat);\nend\n\n\n\n8.3.2 CCPの推定\n\nlogit_model = glm(\n  @formula(action ~ price + price^2 + mileage + mileage^2), data_gen, Binomial(), LogitLink()\n  );\n\n\nCCP_1st = hcat(\n  1 .- predict(logit_model, DataFrame(price = states_matrix[:, 1], mileage = states_matrix[:, 2])), \n  predict(logit_model, DataFrame(price = states_matrix[:, 1], mileage = states_matrix[:, 2]))\n  );\nCCP_1st = convert(Matrix{Float64}, CCP_1st);\n\n\n\n8.3.3 行列形式によるインバージョンを用いたパラメタの推定\n\n@time mat_inv_opt_mat_inv = optimize(\n    x -> - calculateLikelihoodFromCCP(\n      x, \n      CCP_1st, \n      data_gen, \n      beta, \n      trans_mat_hat, \n      states_matrix, \n      calculateCCPByMatrixInversion\n      ),\n    theta_true,\n    Optim.Options(show_trace = false)\n);\n\n  2.836205 seconds (72.91 M allocations: 1.533 GiB, 6.88% gc time, 38.60% compilation time)\n\n\n\ntheta_mat_inv = mat_inv_opt_mat_inv.minimizer;\n\nhessian_mat_inv = ForwardDiff.hessian(\n    x -> - calculateLikelihoodFromCCP(\n      x, \n      CCP_1st, \n      data_gen, \n      beta, \n      trans_mat_hat, \n      states_matrix, \n      calculateCCPByMatrixInversion\n      ),\n    theta_mat_inv\n    );\n\ntheta_se_mat_inv = sqrt.(diag(inv(hessian_mat_inv)));\n\n\nDataFrame(theta_mat_inv = theta_mat_inv, theta_se_mat_inv = theta_se_mat_inv)\n\n\n2×2 DataFrameRowtheta_mat_invtheta_se_mat_invFloat64Float6410.004009058.65792e-520.003002453.63389e-5\n\n\n\n\n8.3.4 有限依存性を用いたパラメタの推定\n\n@time finite_dep_opt = optimize(\n    x -> - calculateLikelihoodFromCCP(\n      x, \n      CCP_1st, \n      data_gen, \n      beta, \n      trans_mat_hat, \n      states_matrix, \n      calculateCCPByFiniteDependency\n      ),\n    theta_true,\n    Optim.Options(show_trace = false)\n);\n\n  1.788700 seconds (66.94 M allocations: 1.205 GiB, 7.84% gc time, 8.41% compilation time)\n\n\n\ntheta_finite_dep = finite_dep_opt.minimizer;\n\nhessian_finite_dep = ForwardDiff.hessian(\n    x -> - calculateLikelihoodFromCCP(\n      x,\n      CCP_1st, \n      data_gen, \n      beta, \n      trans_mat_hat, \n      states_matrix, \n      calculateCCPByFiniteDependency\n      ),\n    theta_finite_dep\n    );\n\ntheta_se_finite_dep = sqrt.(diag(inv(hessian_finite_dep)));\n\n\nDataFrame(theta_finite_dep = theta_finite_dep, theta_se_finite_dep = theta_se_finite_dep)\n\n\n2×2 DataFrameRowtheta_finite_deptheta_se_finite_depFloat64Float6410.004168910.00080262620.002931792.2015e-5\n\n\n\n\n8.3.5 推定方法の比較\n\n@time nfxp_opt = optimize(\n    x -> - calculateLikelihoodNFXP(x, data_gen, beta, trans_mat_hat, states_matrix),\n    theta_true,\n    Optim.Options(show_trace = false)\n)\n\n  4.879810 seconds (71.33 M allocations: 4.697 GiB, 10.64% gc time, 2.92% compilation time)\n\n\n * Status: success\n\n * Candidate solution\n    Final objective value:     1.333722e+04\n\n * Found with\n    Algorithm:     Nelder-Mead\n\n * Convergence measures\n    √(Σ(yᵢ-ȳ)²)/n ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   5  (vs limit Inf)\n    Iterations:    48\n    f(x) calls:    94\n\n\n\ntheta_nfxp = nfxp_opt.minimizer;\n\nhessian_nfxp = ForwardDiff.hessian(\n    x -> - calculateLikelihoodNFXP(x, data_gen, beta, trans_mat_hat, states_matrix),\n    theta_nfxp\n    );\n\ntheta_se_nfxp = sqrt.(diag(inv(hessian_nfxp)));\n\n\nDataFrame(theta_nfxp = theta_nfxp, theta_se_nfxp = theta_se_nfxp)\n\n\n2×2 DataFrameRowtheta_nfxptheta_se_nfxpFloat64Float6410.004018268.88336e-520.003004553.67953e-5\n\n\n\nDataFrame(\n  Algorithm = [\"Matrix Inversion\", \"Finite Dependency\", \"NFXP\"],\n  theta_c = [theta_mat_inv[1], theta_finite_dep[1], theta_nfxp[1]],\n  theta_se_c = [theta_se_mat_inv[1], theta_se_finite_dep[1], theta_se_nfxp[1]],\n  theta_p = [theta_mat_inv[2], theta_finite_dep[2], theta_nfxp[2]],\n  theta_se_p = [theta_se_mat_inv[2], theta_se_finite_dep[2], theta_se_nfxp[2]],\n)\n\n\n3×5 DataFrameRowAlgorithmtheta_ctheta_se_ctheta_ptheta_se_pStringFloat64Float64Float64Float641Matrix Inversion0.004009058.65792e-50.003002453.63389e-52Finite Dependency0.004168910.0008026260.002931792.2015e-53NFXP0.004018268.88336e-50.003004553.67953e-5"
  },
  {
    "objectID": "single_agent_dynamic_application.html#反実仮想分析-1-every-day-low-price",
    "href": "single_agent_dynamic_application.html#反実仮想分析-1-every-day-low-price",
    "title": "8  応用編",
    "section": "8.4 反実仮想分析 1: Every Day Low Price",
    "text": "8.4 反実仮想分析 1: Every Day Low Price\n\nCCP_dict = Dict();\n\n\nprob_buy_baseline = calculateCCPByNFXP(theta_nfxp, beta, trans_mat_hat, states_matrix);\nCCP_dict[\"Baseline\"] = prob_buy_baseline;\n\n\nresult_df_edlp = combine(\n  groupby(\n    data_gen,\n    [:state, :price]\n  ),\n  nrow => :num_obs\n);\nsort!(result_df_edlp, :state)\nresult_df_edlp[!, :prob_buy_baseline] = prob_buy_baseline[:, 2];\n\nresult_df_edlp = combine(\n  groupby(\n    result_df_edlp,\n    [:price]\n  ),\n  [:prob_buy_baseline, :num_obs] =>\n  (\n    (prob_buy_baseline, num_obs) ->\n    sum(prob_buy_baseline .* num_obs) / sum(num_obs)\n  ) =>\n  :prob_buy\n);\n\n\nG_fixed_price = generateMileageTransition(\n  kappa_est, \n  num_mileage_states\n);\n\n\nfor fixed_price in price_states\n  states_matrix_fixed_price = (\n    states_matrix[states_matrix[:, 1] .== fixed_price, :]\n  )\n\n  CCP_dict[\"edlp_\" * string(fixed_price)] = calculateCCPByNFXP(\n    theta_nfxp,\n    beta,\n    G_fixed_price,\n    states_matrix_fixed_price;\n    num_states = num_mileage_states\n  )\nend\n\n\nresult_df_edlp2000 = combine(\n  groupby(\n    data_gen,\n    [:mileage]\n  ),\n  nrow => :num_obs\n);\nsort!(result_df_edlp2000, :mileage)\nresult_df_edlp2000[!, :prob_buy_baseline] = CCP_dict[\"edlp_2000\"][:, 2];\n\nprob_buy_edlp2000 = (\n  sum(result_df_edlp2000.prob_buy_baseline .* result_df_edlp2000.num_obs) / \n  sum(result_df_edlp2000.num_obs)\n);\n\n\nbar(\n    price_states,\n    result_df_edlp.prob_buy,\n    bar_width = 50, legend=false\n)\nhline!([prob_buy_edlp2000])\n\nxlabel!(\"Price (thousand JPY)\")\nylabel!(\"Purchase probability\")"
  },
  {
    "objectID": "single_agent_dynamic_application.html#反実仮想分析-2-永続的一時的な値下げ",
    "href": "single_agent_dynamic_application.html#反実仮想分析-2-永続的一時的な値下げ",
    "title": "8  応用編",
    "section": "8.5 反実仮想分析 2: 永続的・一時的な値下げ",
    "text": "8.5 反実仮想分析 2: 永続的・一時的な値下げ\n\nstates_matrix_discount = states_matrix[:, :];\nstates_matrix_discount[:, 1] .-= 100;\n\nCCP_dict[\"Permanent\"] = calculateCCPByNFXP(theta_nfxp, beta, trans_mat_hat, states_matrix_discount);\n\n\nU_discount = calculateFlowUtil(theta_nfxp, states_matrix_discount);\n\nV = calculateVByContraction(theta_nfxp, beta, trans_mat_hat, states_matrix);\n\nCV_temporary = U_discount + beta .* hcat(trans_mat_hat[:, :, 1] * V, trans_mat_hat[:, :, 2] * V);\n\nCCP_dict[\"Temporary\"] = exp.(CV_temporary) ./ sum(exp.(CV_temporary), dims = 2);\n\n\nplot_cf_df = DataFrame(price = states_matrix[:, 1], mileage = states_matrix[:, 2]);\nplot_cf_df[!, :ProbBaseline] = CCP_dict[\"Baseline\"][:, 2];\nplot_cf_df[!, :ProbPermanent] = CCP_dict[\"Permanent\"][:, 2];\nplot_cf_df[!, :ProbTemporary] = CCP_dict[\"Temporary\"][:, 2];\n\nfilter!(:price => (x -> x == 2200), plot_cf_df);\n\nplot(plot_cf_df.mileage, plot_cf_df.ProbBaseline, label = \"Baseline\")\nplot!(plot_cf_df.mileage, plot_cf_df.ProbPermanent, label = \"Permanent\")\nplot!(plot_cf_df.mileage, plot_cf_df.ProbTemporary, label = \"Temporary\")\nxlabel!(\"Mileage (thousand km)\")\nylabel!(\"Purchase probability\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconsumer_dist_obs = combine(\n  groupby(\n    data_gen,\n    [:state]\n  ),\n  nrow\n)\ntransform!(\n    consumer_dist_obs,\n    :nrow => (x -> x / sum(x)) => :consumer_dist_obs\n);\n\n\ndiscount_scenario_vec = [\"Baseline\", \"Permanent\", \"Temporary\"];\n\nG_CCP_dict = Dict();\n\nfor scenario in discount_scenario_vec\n  G_CCP_dict[scenario] = (\n    CCP_dict[scenario][:, 1] .* trans_mat_hat[:, :, 1] +\n    CCP_dict[scenario][:, 2] .* trans_mat_hat[:, :, 2]\n  );\nend\n\nfor scenario in [\"edlp_\" * string(price) for price in price_states]\n  G_CCP_dict[scenario] = (\n    CCP_dict[scenario][:, 1] .* G_fixed_price[:, :, 1] +\n    CCP_dict[scenario][:, 2] .* G_fixed_price[:, :, 2]\n  );\nend\n\n\nnum_consumer_sim = 1000;\nnum_period_sim = 20;\n\n\ndiscount_sim_dict = Dict();\n\nfor scenario in discount_scenario_vec\n\n  consumer_dist_sim = zeros((num_period_sim, num_states));\n  consumer_dist_sim[1, :] .= consumer_dist_obs.consumer_dist_obs;\n\n  prob_buy_sim_vec = zeros(num_period_sim);\n  demand_vec = zeros(num_period_sim);\n  revenue_vec = zeros(num_period_sim);\n\n  for t in 1:num_period_sim\n\n    if ((t == 1) & (scenario == \"Temporary\"))\n\n      if (t != num_period_sim)\n        consumer_dist_sim[t + 1, :] = consumer_dist_sim[t, :]' * G_CCP_dict[scenario];\n      end\n\n      prob_buy_sim_vec[t] = consumer_dist_sim[t, :]' * CCP_dict[scenario][:, 2];\n      demand_vec[t] = prob_buy_sim_vec[t]' * num_consumer_sim;\n      revenue_vec[t] = sum(\n        (states_matrix[:, 1] .- 100) .* consumer_dist_sim[t, :] .* CCP_dict[scenario][:, 2] .* num_consumer_sim\n      )\n\n    else\n\n      if (scenario == \"Temporary\")\n        scenario_current = \"Baseline\";\n        discount = 0;\n      elseif (scenario == \"Permanent\")\n        scenario_current = scenario;\n        discount = 100;\n      else\n        scenario_current = scenario;\n        discount = 0;\n      end\n\n      if (t != num_period_sim)\n        consumer_dist_sim[t + 1, :] = consumer_dist_sim[t, :]' * G_CCP_dict[scenario_current];\n      end\n\n      prob_buy_sim_vec[t] = consumer_dist_sim[t, :]' * CCP_dict[scenario_current][:, 2];\n      demand_vec[t] = prob_buy_sim_vec[t]' * num_consumer_sim;\n      revenue_vec[t] = sum(\n        (states_matrix[:, 1] .- discount) .* consumer_dist_sim[t, :] .* \n        CCP_dict[scenario_current][:, 2] .* num_consumer_sim\n      )\n\n    end\n\n  end\n\n  discount_sim_dict[scenario] = DataFrame(\n    prob_buy_sim = prob_buy_sim_vec,\n    demand = demand_vec,\n    revenue = revenue_vec,\n  )\n\nend\n\n\nplot(\n  1:num_period_sim,\n  (\n    discount_sim_dict[\"Permanent\"].prob_buy_sim - \n    discount_sim_dict[\"Baseline\"].prob_buy_sim\n  ),\n  label = \"Permanent Change\"\n)\nplot!(\n  1:num_period_sim,\n  (\n    discount_sim_dict[\"Temporary\"].prob_buy_sim - \n    discount_sim_dict[\"Baseline\"].prob_buy_sim\n  ),\n  label = \"Temporary Change\"\n)\n\nxlabel!(\"Period\")\nylabel!(\"Change in purchase probability\")"
  },
  {
    "objectID": "single_agent_dynamic_application.html#需要と収入の計算",
    "href": "single_agent_dynamic_application.html#需要と収入の計算",
    "title": "8  応用編",
    "section": "8.6 需要と収入の計算",
    "text": "8.6 需要と収入の計算\n\nconsumer_dist_obs_edlp = combine(\n  groupby(\n    data_gen,\n    [:mileage]\n  ),\n  nrow\n)\ntransform!(\n    consumer_dist_obs_edlp,\n    :nrow => (x -> x / sum(x)) => :consumer_dist_obs\n);\n\n\nedlp_sim_dict = Dict();\n\nfor fixed_price in price_states\n\n  scenario_edlp = \"edlp_\" * string(fixed_price);\n\n  consumer_dist_sim = zeros((num_period_sim, num_mileage_states));\n  consumer_dist_sim[1, :] .= consumer_dist_obs_edlp.consumer_dist_obs;\n\n  prob_buy_sim_vec = zeros(num_period_sim);\n  demand_vec = zeros(num_period_sim);\n  revenue_vec = zeros(num_period_sim);\n\n  for t in 1:num_period_sim\n\n    if (t != num_period_sim)\n      consumer_dist_sim[t + 1, :] = consumer_dist_sim[t, :]' * G_CCP_dict[scenario_edlp];\n    end\n\n    prob_buy_sim_vec[t] = consumer_dist_sim[t, :]' * CCP_dict[scenario_edlp][:, 2];\n    demand_vec[t] = prob_buy_sim_vec[t]' * num_consumer_sim;\n    revenue_vec[t] = sum(\n      fixed_price .* consumer_dist_sim[t, :] .* \n      CCP_dict[scenario_edlp][:, 2] .* num_consumer_sim\n    )\n\n  end\n\n  edlp_sim_dict[fixed_price] = DataFrame(\n    prob_buy_sim = prob_buy_sim_vec,\n    demand = demand_vec,\n    revenue = revenue_vec,\n  )\n\nend\n\n\nplot()\nfor fixed_price in price_states\n  plot!(1:num_period_sim, edlp_sim_dict[fixed_price].demand, label = \"Price: \" * string(fixed_price))\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor fixed_price in price_states\n  plot!(1:num_period_sim, edlp_sim_dict[fixed_price].revenue, label = \"Price: \" * string(fixed_price))\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    discount_sim_dict[scenario].demand,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    discount_sim_dict[scenario].demand |> cumsum,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand (cumulative sum)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    (discount_sim_dict[scenario].demand |> cumsum) ./ (discount_sim_dict[\"Baseline\"].demand |> cumsum) .* 100,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Demand (cumulative sum, relative to Baseline)\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nplot()\nfor scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n  plot!(\n    1:num_period_sim,\n    discount_sim_dict[scenario].revenue,\n    label = scenario\n  )\nend\ncurrent()\nxlabel!(\"Period\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noutput_df = DataFrame(\n  scenario = [\n    [\"Baseline\", \"Temporary\", \"Permanent\"];\n    [\"edlp_\" * string(price) for price in price_states]\n  ],\n  demand = [\n    [\n      discount_sim_dict[scenario].demand |> sum\n      for scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n    ]; [\n      edlp_sim_dict[price].demand |> sum\n      for price in price_states\n    ]\n  ],\n  revenue = [\n    [\n      discount_sim_dict[scenario].revenue .* (beta .^((1:num_period_sim) .- 1)) |> sum\n      for scenario in [\"Baseline\", \"Temporary\", \"Permanent\"]\n    ]; [\n      edlp_sim_dict[price].revenue .* (beta .^((1:num_period_sim) .- 1)) |> sum\n      for price in price_states\n    ]\n  ]\n)\n\noutput_df[!, :per_rev] = output_df[:, :revenue] ./ output_df[:, :demand] ./ 10;\n\noutput_df\n\n\n9×4 DataFrameRowscenariodemandrevenueper_revStringFloat64Float64Float641Baseline583.3251.19795e6205.3652Temporary586.1781.20157e6204.9843Permanent623.7681.22583e6196.524edlp_2000711.8081.30044e6182.6955edlp_2100664.111.27258e6191.6226edlp_2200620.5181.24426e6200.5197edlp_2300580.3191.21512e6209.3888edlp_2400542.9541.18489e6218.239edlp_2500507.9811.15335e6227.046"
  },
  {
    "objectID": "demand_estimation_1.html#関数の読み込み",
    "href": "demand_estimation_1.html#関数の読み込み",
    "title": "2  基礎編 1",
    "section": "2.1 関数の読み込み",
    "text": "2.1 関数の読み込み\n\nfor file in [\"addIVColumns.jl\", \"calculateSales.jl\"]\n    include(\"functions/demand_estimation/\" * file)\nend"
  },
  {
    "objectID": "demand_estimation_1.html#データの準備",
    "href": "demand_estimation_1.html#データの準備",
    "title": "2  基礎編 1",
    "section": "2.2 データの準備",
    "text": "2.2 データの準備\n\n2.2.1 データの読み込み\n\ndataCar = CSV.File(\n    open(read, \"data/demand_estimation/CleanData_20180222.csv\", enc\"shift-jis\"),\n    missingstring = [\"NA\", \"\"],\n    ) |> DataFrame\nfirst(select(dataCar, Not([:base_color, :option_color])), 5)\n\n\n5×34 DataFrameRowMakerTypeNameYearSalescommentModelYear_trueMonthpricekudoukataTransMissionWheelBaseMinRideHeightweightcapacitySeatRawNumofDoor種類engine過給器displacementFuelTypeTankCapacityHorsePowerMaxTorqueFuelEfficiencyoverall_lengthoverall_widthoverall_heightinterior_lengthinterior_widthinterior_heightString15String7String31Int64Int64String?StringInt64Int64Float64String3String15String3Int64Int64?Int64Int64Int64Int64String31String15StringInt64String15Int64?Int64?Float64?Float64?Int64Int64Int64Int64?Int64?Int64?1AudiForeignA1シリーズ20114206missing1.4 TFSI20111289.0FFDBA-8XCAX7AT24651151190423直列4気筒DOHCCAXターボ1389ハイオク4512220.419.4397017401440missingmissingmissing2AudiForeignA1シリーズ20124502missing1.4 TFSI20121273.0FFDBA-8XCAX7AT24651151190423直列4気筒DOHCCAXターボ1389ハイオク4512220.419.4397017401440missingmissingmissing3AudiForeignA1シリーズ20135071missing1.4 TFSI20121273.0FFDBA-8XCAX7AT24651151190423直列4気筒DOHCCAXターボ1389ハイオク4512220.419.4397017401440missingmissingmissing4AudiForeignA3シリーズ20064830missingアトラクション20061284.0FFGH-8PBSE6AT25751401360525直列4気筒SOHCBSEなし1595ハイオク5510215.112.2428517651430missingmissingmissing5AudiForeignA3シリーズ20073874missingアトラクション20071286.0FFGH-8PBSE6AT25751401360525直列4気筒SOHCBSEなし1595ハイオク5510215.112.2428517651430missingmissingmissing\n\n\n\ndataHH = CSV.read(\"data/demand_estimation/HHsize.csv\", DataFrame)\ndataHH[!, :HH] = parse.(Int, replace.(dataHH.HH, \",\" => \"\"))\nfirst(dataHH, 5)\n\n\n5×2 DataFrameRowyearHHInt64Int6411975333100062197633911052319773438031441978348586965197935350173\n\n\n\ndataCPI = CSV.File(\n    open(read, \"data/demand_estimation/zni2015s.csv\", enc\"shift-jis\"), \n    select = 1:2,\n    skipto = 7\n    ) |> DataFrame\nrename!(dataCPI, \"類・品目\" => \"year\", \"総合\" => \"CPI\")\nfirst(dataCPI, 5)\n\n\n5×2 DataFrameRowyearCPIInt64Float641197031.52197133.53197235.24197339.35197448.4\n\n\n\n\n2.2.2 データクリーニング\n\ndataCar = dataCar[!, [\n        :Maker, :Type, :Name, :Year, :Sales, \n        :Model, :price, :kata, :weight, :FuelEfficiency, \n        :HorsePower, :overall_length, :overall_width, :overall_height\n        ]]\nrename!(dataCar, \"Year\" => \"year\")\ndata = leftjoin(dataCar, dataHH, on = :year)\ndata = leftjoin(data, dataCPI, on = :year)\nfirst(data, 5)\n\n\n5×16 DataFrameRowMakerTypeNameyearSalesModelpricekataweightFuelEfficiencyHorsePoweroverall_lengthoverall_widthoverall_heightHHCPIString15String7String31Int64Int64StringFloat64String15Int64Float64?Int64?Int64Int64Int64Int64?Float64?1AudiForeignA1シリーズ201142061.4 TFSI289.0DBA-8XCAX119019.41223970174014405378343596.32AudiForeignA1シリーズ201245021.4 TFSI273.0DBA-8XCAX119019.41223970174014405417147596.23AudiForeignA1シリーズ201350711.4 TFSI273.0DBA-8XCAX119019.41223970174014405459474496.64AudiForeignA3シリーズ20064830アトラクション284.0GH-8PBSE136012.21024285176514305110200597.25AudiForeignA3シリーズ20073874アトラクション286.0GH-8PBSE136012.21024285176514305171304897.2\n\n\n\ndropmissing!(data, :FuelEfficiency);\n\n\ncpi2016 = dataCPI[dataCPI.year .== 2016, \"CPI\"][1];\ndata[!, :price] = data.price ./ (data.CPI / cpi2016) / 100;\n\n\ndata[!, :size] = (\n    (data[:, :overall_length] / 1000) .* \n    (data[:, :overall_width] / 1000) .* \n    (data[:, :overall_height] / 1000)\n);\ndata[!, :hppw] = data[:, :HorsePower] ./ data[:, :weight];\n\ndata[:, :NameID] = groupby(data, :Name).groups;\n\ntransform!(\n    groupby(data, :year),\n    :Sales => sum => :inside_total\n);\ndata[!, :outside_total] = data.HH .- data.inside_total;\ndata[!, :share] = data.Sales ./ data.HH;\ndata[!, :share0] = data.outside_total ./ data.HH;\n\n\n\n2.2.3 操作変数の構築\n\ntransform!(\n    groupby(data, [:year, :Maker]),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        sum .=> \n        [:hppw_sum_own, :FuelEfficiency_sum_own, :size_sum_own]\n    ),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        (x -> sum(x.^2)) .=> \n        [:hppw_sqr_sum_own, :FuelEfficiency_sqr_sum_own, :size_sqr_sum_own]\n    ),\n    nrow => :group_n\n);\ntransform!(\n    groupby(data, [:year]),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        sum .=> \n        [:hppw_sum_mkt, :FuelEfficiency_sum_mkt, :size_sum_mkt]\n    ),\n    (\n        [:hppw, :FuelEfficiency, :size] .=> \n        (x -> sum(x.^2)) .=> \n        [:hppw_sqr_sum_mkt, :FuelEfficiency_sqr_sum_mkt, :size_sqr_sum_mkt]\n    ),\n    nrow => :mkt_n\n);\n\n\nfor variable in [\"hppw\", \"FuelEfficiency\", \"size\"]\n    addIVColumns!(data, variable)\nend\n\n\nCSV.write(\"tmp/demand_estimation_1/data.csv\", data);"
  },
  {
    "objectID": "demand_estimation_2.html#関数の読み込み",
    "href": "demand_estimation_2.html#関数の読み込み",
    "title": "3  基礎編 2",
    "section": "3.1 関数の読み込み",
    "text": "3.1 関数の読み込み\n\nfor file in readdir(\"functions/demand_estimation\")\n    include(\"functions/demand_estimation/\" * file)\nend"
  },
  {
    "objectID": "demand_estimation_2.html#前回からの加工済みデータの読み込み",
    "href": "demand_estimation_2.html#前回からの加工済みデータの読み込み",
    "title": "3  基礎編 2",
    "section": "3.2 前回からの加工済みデータの読み込み",
    "text": "3.2 前回からの加工済みデータの読み込み\n\ndata = CSV.read(\"tmp/demand_estimation_1/data.csv\", DataFrame);"
  },
  {
    "objectID": "demand_estimation_2.html#データの準備",
    "href": "demand_estimation_2.html#データの準備",
    "title": "3  基礎編 2",
    "section": "3.3 データの準備",
    "text": "3.3 データの準備\n\nNIPPYOautoIDvec = [\n    260, 4, 76, 104, 64, 54, 152, 153, 71, 197,\n    42, 45, 114, 208, 209, 77, 236, 58, 127, 187,\n    79, 175, 19, 117, 216, 112, 256, 119, 37, 158\n];\n\ndataNIPPYO = data[\n    in(NIPPYOautoIDvec).(data[:, :NameID]), \n    [:year, :share, :NameID, :Sales, :price, :hppw, :FuelEfficiency, :size, :Name]\n    ];\ndataNIPPYO[!, :log_sales] = log.(dataNIPPYO[:, :Sales]);\ndataNIPPYO[!, :log_price] = log.(dataNIPPYO[:, :price]);\ndataNIPPYO[!, :log10_sales] = log10.(dataNIPPYO[:, :Sales]);\ndataNIPPYO[!, :log10_price] = log10.(dataNIPPYO[:, :price]);"
  },
  {
    "objectID": "demand_estimation_2.html#logitモデルにおける価格弾力性行列の作成",
    "href": "demand_estimation_2.html#logitモデルにおける価格弾力性行列の作成",
    "title": "3  基礎編 2",
    "section": "3.4 Logitモデルにおける価格弾力性行列の作成",
    "text": "3.4 Logitモデルにおける価格弾力性行列の作成\n\ndata[!, :logit_share] = log.(data[:, :share]) .- log.(data[:, :share0]);\n\nresultGH = reg(\n    data, \n    @formula(logit_share ~ (\n        price ~ iv_GH_own_hppw + iv_GH_own_FuelEfficiency + iv_GH_own_size + \n            iv_GH_other_hppw + iv_GH_other_FuelEfficiency + iv_GH_other_size\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust(),\n    save = true\n);\n\ndata2016 = dataNIPPYO[\n    dataNIPPYO.year .== 2016, \n    [:price, :share, :NameID, :Name]\n    ];\nnumCars2016 = nrow(data2016);\n\nownElasticity = (\n    resultGH.coef[resultGH.coefnames .== \"price\"][1] .* \n    data2016.price .* \n    (1.0 .- data2016.share)\n);\ncrossElasticity = (\n    - resultGH.coef[resultGH.coefnames .== \"price\"][1] .* \n    data2016.price .* \n    data2016.share\n);\n\nelasticityMat = reduce(\n    hcat, \n    [crossElasticity for car = 1:numCars2016]\n    );\nelasticityMat[diagind(elasticityMat)] = ownElasticity;\n\nelasticityMat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -1.76455       0.00114929    0.00114929   0.00114929\n  0.00122042   -0.818689      0.00122042   0.00122042\n  0.000148175   0.000148175  -0.959449     0.000148175\n  0.00184509    0.00184509    0.00184509  -0.67175"
  },
  {
    "objectID": "demand_estimation_2.html#入れ子型ロジットモデルの推定",
    "href": "demand_estimation_2.html#入れ子型ロジットモデルの推定",
    "title": "3  基礎編 2",
    "section": "3.6 入れ子型ロジットモデルの推定",
    "text": "3.6 入れ子型ロジットモデルの推定\n\ndata = transform(\n    groupby(data, [:year, :Type]),\n    :Sales => sum => :sum_year_body\n);\ndata[!, :inside_share] = data.Sales ./ data.sum_year_body;\ndata[!, :log_inside_share] = log.(data.Sales ./ data.sum_year_body);\nresultOLS = reg(\n    data, \n    @formula(\n        logit_share ~ \n        price + log_inside_share + hppw + FuelEfficiency + size\n        )\n    );\n\nresultBLPNested = reg(\n    data, \n    @formula(logit_share ~ (\n        price + log_inside_share ~ iv_BLP_own_hppw_nest + iv_BLP_own_FuelEfficiency_nest + iv_BLP_own_size_nest + \n            iv_BLP_other_hppw_nest + iv_BLP_other_FuelEfficiency_nest + iv_BLP_other_size_nest +\n            iv_BLP_own_num_nest + iv_BLP_other_num_nest\n    ) + hppw + FuelEfficiency + size),\n    Vcov.robust()\n);\n\nregtable(resultOLS, resultBLPNested)\n\n\n-----------------------------------------------\n                               logit_share     \n                          ---------------------\n                                (1)         (2)\n-----------------------------------------------\n(Intercept)               -7.557***   -9.548***\n                            (0.166)     (0.239)\nprice                     -0.307***   -0.654***\n                            (0.013)     (0.053)\nlog_inside_share           0.782***    0.595***\n                            (0.009)     (0.035)\nhppw                      10.636***   18.925***\n                            (0.657)     (1.965)\nFuelEfficiency             0.055***    0.069***\n                            (0.004)     (0.006)\nsize                       0.156***    0.227***\n                            (0.008)     (0.012)\n-----------------------------------------------\nEstimator                       OLS          IV\n-----------------------------------------------\nN                             1,823       1,823\nR2                            0.862       0.765\nWithin-R2                                      \nFirst-stage F statistic                   1.667\n-----------------------------------------------\n\n\n\n\n3.6.1 入れ子型ロジットモデルにおける自己価格弾力性の計算\n\nalpha1 = resultOLS.coef[resultOLS.coefnames .== \"price\"][1]\nsigma1 = resultOLS.coef[resultOLS.coefnames .== \"log_inside_share\"][1]\n\nalpha2 = resultBLPNested.coef[resultBLPNested.coefnames .== \"price\"][1]\nsigma2 = resultBLPNested.coef[resultBLPNested.coefnames .== \"log_inside_share\"][1]\n\ndata[!, :own_elas_ols] = alpha1 .* data[:, :price] .* (\n    1.0 .- sigma1 .* data[:, :inside_share] .- \n    (1.0 .- sigma1) .* data[:, :share]\n) ./ (1.0 .- sigma1);\ndata[!, :own_elas_ivblp_nested] = alpha2 .* data[:, :price] .* (\n    1.0 .- sigma2 .* data[:, :inside_share] .- \n    (1.0 .- sigma2) .* data[:, :share]\n) ./ (1.0 .- sigma2);\n\ndescribe(data[:, r\"^own_elas\"], :mean, :std, :median, :min, :max)\n\n\n2×6 DataFrameRowvariablemeanstdmedianminmaxSymbolFloat64Float64Float64Float64Float641own_elas_ols-3.521312.55849-2.84383-17.7936-0.962572own_elas_ivblp_nested-4.049352.93775-3.2664-20.4015-1.11262\n\n\n\ndataNIPPYO = data[\n    in(NIPPYOautoIDvec).(data[:, :NameID]), \n    [\n        :year, :share, :Type, :inside_share, \n        :NameID, :Sales, :price, :hppw, :FuelEfficiency, :size, :Name\n        ]\n    ];\ndataNIPPYO[!, :log_sales] = log.(dataNIPPYO[:, :Sales]);\ndataNIPPYO[!, :log_price] = log.(dataNIPPYO[:, :price]);\n\ndata2016 = dataNIPPYO[\n    dataNIPPYO.year .== 2016, \n    [:price, :Type, :share, :inside_share, :NameID, :Name]\n    ];\nnumCars2016 = nrow(data2016);\n\nownElasticityNestedLogit = (\n    alpha2 .* \n    data2016.price .* \n    (\n        1.0 .- sigma2 .* \n        data2016.inside_share .- \n        (1.0 .- sigma2) .* \n        data2016.share\n        ) ./ \n    (1.0 .- sigma2)\n);\ncrossElasticityOtherGroup = (\n    - alpha2 .* \n    data2016.price .* \n    data2016.share\n);\n\ncrossElasticityOtherGroup = reduce(\n    hcat, \n    [crossElasticityOtherGroup for car = 1:numCars2016]\n    );\ncrossElasticityOtherGroup[\n    diagind(crossElasticityOtherGroup)\n    ] = ownElasticityNestedLogit;\n\n\ncrossElasticitySameGroup = reduce(\n    hcat,\n    [\n        - alpha2 .* data2016.price .* (\n            sigma2 .* data2016.inside_share .+ (1.0 .- sigma2) .* data2016.share\n        ) ./ (1.0 .- sigma2)\n    for car in 1:numCars2016]\n);\n\nsameGroupIndicatorMat = (\n    reduce(hcat, [data2016.Type for car = 1:numCars2016]) .==\n    permutedims(reduce(hcat, [data2016.Type for car = 1:numCars2016]))\n);\notherGroupIndicatorMat = (sameGroupIndicatorMat .== 0);\n\nelasticityNestedLogitMat = (\n    crossElasticitySameGroup .* \n    sameGroupIndicatorMat .+ \n    crossElasticityOtherGroup .* \n    otherGroupIndicatorMat\n);\nelasticityNestedLogitMat[\n    diagind(elasticityNestedLogitMat)\n    ] = ownElasticityNestedLogit;\n\nelasticityNestedLogitMat[[12, 13, 10, 1], [12, 13, 10, 1]]\n\n4×4 Matrix{Float64}:\n -5.1197       0.0477573    0.0477573    0.00136172\n  0.050713    -2.34881      0.050713     0.001446\n  0.00615725   0.00615725  -2.80217      0.000175564\n  0.00218614   0.00218614   0.00218614  -1.83296"
  },
  {
    "objectID": "demand_estimation_2.html#価格弾力性行列の計算",
    "href": "demand_estimation_2.html#価格弾力性行列の計算",
    "title": "3  基礎編 2",
    "section": "3.8 価格弾力性行列の計算",
    "text": "3.8 価格弾力性行列の計算\n\nmarket2016Index = data.year .== 2016;\n\nelasmat = calculateElasticity(\n    data[market2016Index, :].price,\n    X2[market2016Index, :],\n    beta_hat,\n    resultGMM.minimizer,\n    randomDrawMat,\n    delta[market2016Index, :]\n)\n\nelasmat[[59, 80, 102, 113], [59, 80, 102, 113]]\n\n4×4 Matrix{Float64}:\n -2.07694      0.0043804    0.00405532   0.00447937\n  0.0204111   -1.92602      0.0185025    0.0248292\n  0.00413169   0.00404559  -2.14446      0.00376725\n  0.00295524   0.0035155    0.00243949  -1.51216"
  },
  {
    "objectID": "demand_estimation_2.html#応用-プライシング",
    "href": "demand_estimation_2.html#応用-プライシング",
    "title": "3  基礎編 2",
    "section": "3.9 応用: プライシング",
    "text": "3.9 応用: プライシング\n以下で求められる値はサポートサイトのものとかなり異なるが、これは上で述べた推定結果が原因だと思われる。\n\nprice_range = range(1.8, 4.0, step = 0.05);\nownpi_res = calculateRevenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(delta), Ref(beta_hat), Ref(resultGMM.minimizer),\n    \"ownpi\"\n);\n\nplot(price_range, ownpi_res, legend = false)\nxlabel!(\"Price\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprice_range = range(1.8, 4.0, step = 0.05);\ntotalpi_res = calculateRevenue.(\n    price_range, \n    Ref(data), Ref(datalist), Ref(delta), Ref(beta_hat), Ref(resultGMM.minimizer),\n    \"totalpi\"\n);\n\nplot(price_range, totalpi_res, legend = false)\nxlabel!(\"Price\")\nylabel!(\"Revenue\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nownpi_optim_res = optimize(\n    x -> - calculateRevenue(\n        x[1], data, datalist, delta, \n        beta_hat, resultGMM.minimizer, \"ownpi\"\n        ),\n    [3.0]\n);\n\n@printf(\"Revenue-maximizing price: %.3f \\n\", ownpi_optim_res.minimizer[1])\n@printf(\"Maximized revenue : %.3f\", -ownpi_optim_res.minimum)\n\nRevenue-maximizing price: 3.256 \nMaximized revenue : 44811.735\n\n\n\ntotalpi_optim_res = optimize(\n    x -> - calculateRevenue(\n        x[1], data, datalist, delta, \n        beta_hat, resultGMM.minimizer, \"totalpi\"\n        ),\n    [3.0]\n);\n\n@printf(\"Revenue-maximizing price: %.3f \\n\", totalpi_optim_res.minimizer[1])\n@printf(\"Maximized revenue : %.3f\", -totalpi_optim_res.minimum)\n\nRevenue-maximizing price: 3.508 \nMaximized revenue : 570181.486\n\n\n\ncalculateRevenue(\n    ownpi_optim_res.minimizer[1], \n    data,\n    datalist,\n    delta,\n    beta_hat,\n    resultGMM.minimizer,\n    \"totalpi\"\n    )\n\n569858.7798782628"
  },
  {
    "objectID": "entry_exit_basic.html#データの読み込み",
    "href": "entry_exit_basic.html#データの読み込み",
    "title": "5  基礎編",
    "section": "5.1 データの読み込み",
    "text": "5.1 データの読み込み\n\ndata = CSV.File(\n    open(read, \"data/entry_exit_basic/MRIData.csv\", enc\"UTF-8\"),\n    missingstring = [\"NA\", \"\"],\n    ) |> DataFrame\nfirst(data, 5)\n\n\n5×16 DataFrameRowHospitalIDCityCodeKyukyuKinouSienHyokaDepNeurologyDepNeurosurgeryNumBedsMRINumOwnTeslaPopulationMensekiPopDensityTaxableIncomeMRIOwnDumInt64Int64Int64?Int64?Int64?Int64?Int64?Int64?Int64?Int64Int64?Int64?Float64?Float64?Int64?Int641111011000002431222018946.424743.4301712211010000001801022018946.424743.4301713311011000001101122018946.424743.4301714411011000111343222018946.424743.4301715511010000002501222018946.424743.430171\n\n\n\ndataset = combine(\n    groupby(data, :CityCode),\n    :MRIOwnDum => sum => :NumMRI,\n    [:Population, :Menseki, :PopDensity, :TaxableIncome] .=> mean .=> [:Pop, :Menseki, :PopDen, :Income],   \n);\ndataset[!, :Pop] = dataset.Pop / 1e+6;\ndropmissing!(dataset, :);\nnumObs = nrow(dataset)\n\n1459"
  },
  {
    "objectID": "entry_exit_basic.html#bresnahan-and-reiss-1991-モデルの推定",
    "href": "entry_exit_basic.html#bresnahan-and-reiss-1991-モデルの推定",
    "title": "5  基礎編",
    "section": "5.2 Bresnahan and Reiss (1991) モデルの推定",
    "text": "5.2 Bresnahan and Reiss (1991) モデルの推定\n\nhospitalNumCap = 6;\ndataset[dataset.NumMRI .> hospitalNumCap, :NumMRI] .= hospitalNumCap;\n\n\nobj_for_Optim = TwiceDifferentiable(\n    x -> calculateBRObjective(x, dataset, hospitalNumCap),\n    ones(hospitalNumCap + 1);\n    autodiff = :forward\n);\n@time optim_res = optimize(\n    obj_for_Optim,\n    zeros(hospitalNumCap + 1),\n    repeat([Inf], hospitalNumCap + 1),\n    ones(hospitalNumCap + 1),\n    Optim.Options(show_trace = false)\n);\n\n  5.900208 seconds (15.71 M allocations: 1.961 GiB, 6.81% gc time, 96.10% compilation time)\n\n\n\nse = sqrt.(diag(inv(obj_for_Optim.H) ./ numObs));\nDataFrame(\n    estimates = optim_res.minimizer,\n    se = se\n)\n\n\n7×2 DataFrameRowestimatesseFloat64Float64154.62361.52851233.54331.361838.083460.48228444.236550.32650952.512150.26024161.632970.21518671.390410.046226"
  },
  {
    "objectID": "entry_exit_basic.html#推定値に基づくエクササイズ",
    "href": "entry_exit_basic.html#推定値に基づくエクササイズ",
    "title": "5  基礎編",
    "section": "5.3 推定値に基づくエクササイズ",
    "text": "5.3 推定値に基づくエクササイズ\n\nalpha_est = optim_res.minimizer[1:hospitalNumCap];\ngamma_est = optim_res.minimizer[hospitalNumCap + 1];\n\nEntryThreshold = zeros(Int64, (hospitalNumCap, 2));\n\ndeno = alpha_est[1];\nEntryThreshold[1,:] .= round(gamma_est / deno .* 1e+6);\nfor i = 2:hospitalNumCap\n    deno = deno - alpha_est[i];\n    EntryThreshold[i, :] = round.([gamma_est / deno .* 1e+6, gamma_est / deno .* 1e+6 / i]);\nend\n\nEntryThreshold    \n\n6×2 Matrix{Int64}:\n  25454  25454\n  65958  32979\n 106981  35660\n 158717  39679\n 222532  44506\n 301269  50212"
  },
  {
    "objectID": "single_agent_dynamic_basic.html#パラメタの設定",
    "href": "single_agent_dynamic_basic.html#パラメタの設定",
    "title": "7  基礎編",
    "section": "7.1 パラメタの設定",
    "text": "7.1 パラメタの設定\n\ntheta_true = [0.004, 0.003];\n\nbeta = 0.99;\nEuler_const = Float64(MathConstants.eulergamma);\n\nnum_choice = 2;\n\n\nprice_states = 2000:100:2500;\nmileage_states = 0:5:100;\nnum_price_states = length(price_states);\nnum_mileage_states = length(mileage_states);\nnum_states = num_price_states * num_mileage_states;\n\nstates_matrix = Matrix(\n    reshape(\n        reinterpret(\n            Int, \n            collect(Iterators.product(price_states, mileage_states))\n            ),\n        (2, :)\n        )'\n    );\n\n\nkappa_true = [0.25, 0.05];\n\nmileage_trans_mat_true = generateMileageTransition(\n    kappa_true, \n    num_mileage_states\n    );\n\nmileage_trans_mat_true[1:4, 1:4, 1]\n\n4×4 Matrix{Float64}:\n 0.7  0.25  0.05  0.0\n 0.0  0.7   0.25  0.05\n 0.0  0.0   0.7   0.25\n 0.0  0.0   0.0   0.7\n\n\n\nlambda_true = [\n    0.1, 0.2, 0.2, 0.2, 0.2,\n    0.1, 0.2, 0.2, 0.2, 0.2,\n    0.1, 0.1, 0.2, 0.2, 0.1,\n    0.1, 0.1, 0.2, 0.2, 0.1,\n    0.05, 0.05, 0.1, 0.1, 0.2,\n    0.05, 0.05, 0.1, 0.1, 0.2\n];\n\nprice_trans_mat_true = generatePriceTransition(\n    lambda_true, \n    num_price_states\n    );\n\n\ntrans_mat_true = Array{Float64}(\n    undef, num_states, num_states, num_choice\n    );\nfor i in 1:num_choice\n    trans_mat_true[:, :, i] = kron(\n        mileage_trans_mat_true[:, :, i], \n        price_trans_mat_true\n        );\nend\n\n\nprice_trans_eigen = eigvecs(price_trans_mat_true');\nprice_dist_steady = (\n    price_trans_eigen[:, end] / sum(price_trans_eigen[:, end])\n)\n\n6-element Vector{Float64}:\n 0.07377049180327863\n 0.07377049180327883\n 0.1639344262295082\n 0.16393442622950818\n 0.28571428571428564\n 0.23887587822014061\n\n\n\n@time EV_true = calculateEV(\n    theta_true, beta, trans_mat_true, states_matrix\n    );\n\n  0.727990 seconds (2.26 M allocations: 202.622 MiB, 9.86% gc time, 90.73% compilation time)\n\n\n\nU_true = calculateFlowUtil(theta_true, states_matrix);\nV_CS_true = U_true + beta .* EV_true;\n\n\nprob_buy_true_mat = reshape(\n    exp.(V_CS_true[:, 2]) ./ sum(exp.(V_CS_true), dims = 2), \n    (num_price_states, num_mileage_states)\n    );"
  },
  {
    "objectID": "single_agent_dynamic_basic.html#データの生成",
    "href": "single_agent_dynamic_basic.html#データの生成",
    "title": "7  基礎編",
    "section": "7.2 データの生成",
    "text": "7.2 データの生成\n\nnum_consumer = 1000;\n\nnum_period = 12 * 50;\nnum_period_obs = 12 * 10;\n\nnum_obs = num_consumer * num_period;\n\nRandom.seed!(42);\n\n\ndata_gen = reduce(vcat, [generateData(\n    consumer_id,\n    V_CS_true,\n    trans_mat_true,\n    price_dist_steady\n    ) for consumer_id in 1:num_consumer]) |>\n    filter(:period => (x -> x > num_period - num_period_obs))\n\ndata_gen[!, :price] = states_matrix[data_gen.state, 1];\ndata_gen[!, :mileage] = states_matrix[data_gen.state, 2];\n\n\ndescribe(\n    data_gen[:, [:price, :mileage, :action]], :all\n    )[:, [:variable, :mean, :std, :min, :max]]\n\n\n3×5 DataFrameRowvariablemeanstdminmaxSymbolFloat64Float64Int64Int641price2322.63151.826200025002mileage33.019823.692401003action0.029150.16822801\n\n\n\nhistogram(data_gen.price, bar_width = 50, legend=false)\nxlabel!(\"Price (thousand JPY)\")\nylabel!(\"Frequency\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhistogram(\n    data_gen.mileage, \n    bar_width = 3, \n    legend=false, \n    bins = [collect(mileage_states); [105]] .- 2.5\n    )\nxlabel!(\"Mileage (thousand km)\")\nylabel!(\"Frequency\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbar(\n    price_states,\n    combine(groupby(data_gen, :price), :action => mean).action_mean,\n    bar_width = 50, \n    legend=false\n)\nxlabel!(\"Price (thousand JPY)\")\nylabel!(\"Purchase probability\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbar(\n    mileage_states,\n    combine(groupby(data_gen, :mileage), :action => mean).action_mean,\n    bar_width = 3, \n    legend=false\n)\nxlabel!(\"Mileage (thousand km)\")\nylabel!(\"Purchase probability\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n次の図は「観測された条件付き購入確率」を示す。 元のサポートサイトでは3Dプロットを使って示されていたが、Juliaではいい感じの3Dプロットを書くのが難しかったため、代わりにヒートマップで示している。\n\nheatmap(\n    mileage_states,\n    price_states,\n    reshape(\n        combine(\n            groupby(data_gen, [:mileage, :price]), \n            :action => mean\n            ).action_mean, \n        (num_price_states, num_mileage_states)\n    ),\n    xlabel = \"Mileage\",\n    ylabel = \"Price\",\n    title = \"Conditional probability of buying\"\n)"
  },
  {
    "objectID": "single_agent_dynamic_basic.html#遷移行列の推定",
    "href": "single_agent_dynamic_basic.html#遷移行列の推定",
    "title": "7  基礎編",
    "section": "7.3 遷移行列の推定",
    "text": "7.3 遷移行列の推定\n\ntransform!(\n    groupby(data_gen, :consumer_id), \n    [:price, :mileage, :action] .=> ShiftedArrays.lag\n    );\n\n\nnum_cond_obs_mileage = combine(\n    groupby(\n        transform(\n            data_gen |>\n                filter(\n                    :period => \n                    (x -> x != (num_period - num_period_obs + 1))\n                    ),\n            [:mileage_lag, :mileage, :action_lag] =>\n            ByRow(\n                (mileage_lag, mileage, action_lag) ->\n                (\n                    (\n                        (action_lag == 0) & \n                        (5 <= mileage_lag <= 95) & \n                        (mileage_lag == mileage)\n                        ) |\n                    ((action_lag == 1) & (mileage == 0))\n                    ) ? \"cond_obs_mileage1\" :\n                (\n                    (\n                        (action_lag == 0) & \n                        (5 <= mileage_lag <= 90) & \n                        (mileage_lag == mileage - 5)\n                        ) |\n                    ((action_lag == 1) & (mileage == 5))\n                    ) ? \"cond_obs_mileage2\" :\n                (\n                    (\n                        (action_lag == 0) & \n                        (5 <= mileage_lag <= 90) & \n                        (mileage_lag == mileage - 10)\n                        ) |\n                    ((action_lag == 1) & (mileage == 10))\n                    ) ? \"cond_obs_mileage3\" :\n                (\n                    (\n                        (action_lag == 0) & \n                        (mileage_lag == 95) & \n                        (mileage == 100)\n                        )\n                    ) ? \"cond_obs_mileage4\" :\n                \"other\"\n            ) =>\n            :cond_obs_mileage\n            ),\n        [:cond_obs_mileage]\n        ),\n    nrow => :num_cond_obs\n) |> filter(:cond_obs_mileage => (x -> (x != \"other\")));\n\nnum_cond_obs_mileage = Dict(\n    k => v[1, \"num_cond_obs\"] \n    for ((k, ), v) in pairs(groupby(num_cond_obs_mileage, :cond_obs_mileage))\n    );\n\n\nkappa_est = zeros(2);\n\nkappa_est[1] = num_cond_obs_mileage[\"cond_obs_mileage2\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (\n        num_cond_obs_mileage[\"cond_obs_mileage2\"] + \n        num_cond_obs_mileage[\"cond_obs_mileage3\"]\n        ) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est[2] = num_cond_obs_mileage[\"cond_obs_mileage3\"] * (\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n) / (\n    (\n        num_cond_obs_mileage[\"cond_obs_mileage2\"] + \n        num_cond_obs_mileage[\"cond_obs_mileage3\"]\n        ) * (\n    num_cond_obs_mileage[\"cond_obs_mileage1\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage2\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage3\"] +\n    num_cond_obs_mileage[\"cond_obs_mileage4\"]\n    )\n);\n\nkappa_est\n\n2-element Vector{Float64}:\n 0.2507060588583926\n 0.05038686722769128\n\n\n\nInfomat_mileage_est = zeros((2, 2));\n\nInfomat_mileage_est[1, 1] = (\n    (\n        num_cond_obs_mileage[\"cond_obs_mileage1\"] / \n        (1 - kappa_est[1] - kappa_est[2])^2\n        ) +\n    (num_cond_obs_mileage[\"cond_obs_mileage2\"] / kappa_est[1]^2) +\n    (\n        num_cond_obs_mileage[\"cond_obs_mileage4\"] / \n        (kappa_est[1] + kappa_est[2])^2\n        )\n);\n\nInfomat_mileage_est[1, 2] = (\n    (\n        num_cond_obs_mileage[\"cond_obs_mileage1\"] / \n        (1 - kappa_est[1] - kappa_est[2])^2\n        ) +\n    (\n        num_cond_obs_mileage[\"cond_obs_mileage4\"] / \n        (kappa_est[1] + kappa_est[2])^2\n        )\n);\n\nInfomat_mileage_est[2, 1] = Infomat_mileage_est[1, 2];\n\nInfomat_mileage_est[2, 2] = (\n    (\n        num_cond_obs_mileage[\"cond_obs_mileage1\"] / \n        (1 - kappa_est[1] - kappa_est[2])^2\n        ) +\n    (num_cond_obs_mileage[\"cond_obs_mileage3\"] / kappa_est[2]^2) +\n    (\n        num_cond_obs_mileage[\"cond_obs_mileage4\"] / \n        (kappa_est[1] + kappa_est[2])^2\n        )\n);\n\nkappa_se = sqrt.(diag(inv(Infomat_mileage_est)));\n\n\nDataFrame(kappa_est = kappa_est, kappa_se = kappa_se)\n\n\n2×2 DataFrameRowkappa_estkappa_seFloat64Float6410.2507060.001309820.05038690.000662066\n\n\n\nnum_cond_obs_price = combine(\n    groupby(\n        data_gen |>\n            filter(\n                :period => \n                (x -> x != (num_period - num_period_obs + 1))\n                ),\n        [:price_lag, :price]\n    ),\n    nrow => :num_cond_obs\n)\n\nnum_cond_obs_price = [\n    (\n        num_cond_obs_price |> \n            filter(\n                [:price_lag, :price] => \n                (\n                    (price_lag, price) -> \n                    ((price_lag == p_lag) & (price == p))\n                    )\n                    )\n    )[1, :num_cond_obs]\n    for p_lag in price_states, p in price_states\n]\n\nlambda_est_mat = num_cond_obs_price ./ sum(num_cond_obs_price, dims = 2);\nlambda_est = lambda_est_mat'[lambda_est_mat' .!= diag(lambda_est_mat)];\n\n\nlambda_se = vcat([\n    sqrt.(diag(inv(\n            (\n            diagm(num_cond_obs_price[i, :])[Not(i), Not(i)] ./ \n            lambda_est_mat[Not(i), Not(i)].^2\n        ) .+ (\n            num_cond_obs_price[i, i] /\n            lambda_est_mat[i, i]^2\n        )\n    ))) for i in 1:num_price_states\n]...)\n\n30-element Vector{Float64}:\n 0.003331377707369882\n 0.00671087202774432\n 0.006726990888800794\n 0.009561549640256135\n 0.009611051522479718\n 0.003237157226120388\n 0.006683210833495453\n 0.006696372126260586\n 0.009621285444288651\n 0.009781740363963828\n 0.002223144478519486\n 0.0022780260513659977\n 0.004516183865925486\n ⋮\n 0.006813746538738526\n 0.007677243174949639\n 0.002356517399713087\n 0.0023843478474719036\n 0.0045057964689017155\n 0.0045121986971131695\n 0.005002569765090251\n 0.0026110065055348717\n 0.0025918295553672807\n 0.004885082439414729\n 0.004962738202957978\n 0.005515586477784162\n\n\n\nDataFrame(\n    lambda_est = lambda_est,\n    lambda_se = lambda_se\n)\n\n\n30×2 DataFrame5 rows omittedRowlambda_estlambda_seFloat64Float6410.1012050.0033313820.1969520.0067108730.1984310.0067269940.2052540.0095615550.1988860.0096110560.1044590.0032371670.2000230.0066832180.2017330.0066963790.204470.00962129100.1885050.00978174110.09983120.00222314120.09793890.00227803130.2056460.00451618⋮⋮⋮190.2004770.00681375200.1011280.00767724210.04952970.00235652220.04982360.00238435230.10.0045058240.1009110.0045122250.1992650.00500257260.04865840.00261101270.05096540.00259183280.1037050.00488508290.1005110.00496274300.1981120.00551559"
  },
  {
    "objectID": "single_agent_dynamic_basic.html#パラメタの推定",
    "href": "single_agent_dynamic_basic.html#パラメタの推定",
    "title": "7  基礎編",
    "section": "7.4 パラメタの推定",
    "text": "7.4 パラメタの推定\n\n7.4.1 静学的なロジットによる推定\n\n@time logit_stat_opt = optimize(\n    x -> - calculateLogLikelihoodStatic(x, states_matrix, data_gen),\n    theta_true,\n    Optim.Options(show_trace = false)\n)\n\n  2.115396 seconds (71.91 M allocations: 1.319 GiB, 6.80% gc time, 21.10% compilation time)\n\n\n * Status: success\n\n * Candidate solution\n    Final objective value:     1.350416e+04\n\n * Found with\n    Algorithm:     Nelder-Mead\n\n * Convergence measures\n    √(Σ(yᵢ-ȳ)²)/n ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   2  (vs limit Inf)\n    Iterations:    48\n    f(x) calls:    98\n\n\n\ntheta_est_stat = logit_stat_opt.minimizer;\n\nhessian_stat = ForwardDiff.hessian(\n    x -> - calculateLogLikelihoodStatic(x, states_matrix, data_gen),\n    logit_stat_opt.minimizer\n    );\n\ntheta_se_stat = sqrt.(diag(inv(hessian_stat)));\n\n\nDataFrame(theta_est_stat = theta_est_stat, theta_se_stat = theta_se_stat)\n\n\n2×2 DataFrameRowtheta_est_stattheta_se_statFloat64Float6410.04281720.00069209920.002376471.9178e-5\n\n\n\n\n7.4.2 不動点アルゴリズムを用いた、動学的なロジットによる推定\n\nmileage_trans_mat_hat = generateMileageTransition(\n    kappa_est, \n    num_mileage_states\n    );\n\nprice_trans_mat_hat = generatePriceTransition(\n    lambda_est, \n    num_price_states\n    );\n\ntrans_mat_hat = Array{Float64}(\n    undef, num_states, num_states, num_choice\n    );\nfor i in 1:num_choice\n    trans_mat_hat[:, :, i] = kron(mileage_trans_mat_hat[:, :, i], price_trans_mat_hat);\nend\n\n\n@time NFXP_opt = optimize(\n    x -> - calculateLogLikelihoodDynamic(x, beta, trans_mat_hat, states_matrix, data_gen),\n    theta_true,\n    Optim.Options(show_trace = false)\n)\n\n  6.368038 seconds (73.23 M allocations: 6.324 GiB, 9.68% gc time, 1.16% compilation time)\n\n\n * Status: success\n\n * Candidate solution\n    Final objective value:     1.333722e+04\n\n * Found with\n    Algorithm:     Nelder-Mead\n\n * Convergence measures\n    √(Σ(yᵢ-ȳ)²)/n ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   6  (vs limit Inf)\n    Iterations:    48\n    f(x) calls:    94\n\n\n\ntheta_est = NFXP_opt.minimizer;\n\nhessian = ForwardDiff.hessian(\n    x -> - calculateLogLikelihoodDynamic(x, beta, trans_mat_hat, states_matrix, data_gen),\n    theta_est\n    );\n\ntheta_se = sqrt.(diag(inv(hessian)));\n\n\nDataFrame(theta_est = theta_est, theta_se = theta_se)\n\n\n2×2 DataFrameRowtheta_esttheta_seFloat64Float6410.004018268.88336e-520.003004553.67953e-5\n\n\n\nCSV.write(\"tmp/single_agent_dynamic_basic/data_gen.csv\", data_gen);\n\nserialize(\"tmp/single_agent_dynamic_basic/kappa_est.ser\", kappa_est);\nserialize(\"tmp/single_agent_dynamic_basic/lambda_est.ser\", lambda_est);\nserialize(\"tmp/single_agent_dynamic_basic/theta_est.ser\", theta_est);"
  },
  {
    "objectID": "dynamic_game_data.html#パラメタの設定",
    "href": "dynamic_game_data.html#パラメタの設定",
    "title": "9  疑似データの生成",
    "section": "9.1 パラメタの設定",
    "text": "9.1 パラメタの設定\n\nRandom.seed!(123);\n\nbeta = 0.8;\neulergamma = Float64(MathConstants.eulergamma);\nTransitionMat = [0.7 0.3; 0.4 0.6]\n\nentryMat = repeat([\n    0 0;\n    0 1;\n    1 0;\n    1 1;\n], 2);\nnumFirmsVec = vec(sum(entryMat, dims = 2));\neconomyVec = [repeat([1], 4); repeat([0], 4)];\n\npossibleActionArray = zeros(Int, 8, 3, 2);\npossibleActionArray[:, :, 1] .= repeat([\n    0 1 1;\n    0 1 1;\n    1 1 0;\n    1 1 0\n], 2);\npossibleActionArray[:, :, 2] .= repeat([\n    0 1 1;\n    1 1 0;\n    0 1 1;\n    1 1 0\n], 2);\n\nglobal_param = global_param_struct(\n    beta,\n    eulergamma,\n    entryMat,\n    numFirmsVec,\n    economyVec,\n    possibleActionArray\n);\n\n\nParameters = [\n    0.3,\n    0.2,\n    -0.27,\n    0.45,\n    -0.15,\n    -2.10\n];\n\nparameterMat = hcat([\n    [Parameters[i]; Parameters[3:6]]\n    for i in 1:2\n]...);"
  },
  {
    "objectID": "dynamic_game_data.html#各企業の利潤の計算",
    "href": "dynamic_game_data.html#各企業の利潤の計算",
    "title": "9  疑似データの生成",
    "section": "9.2 各企業の利潤の計算",
    "text": "9.2 各企業の利潤の計算\n\nprofitFirm1 = calculateFirmProfit(\n    parameterMat,\n    global_param.entryMat,\n    global_param.numFirmsVec,\n    global_param.economyVec,\n    global_param.possibleActionArray,\n    1\n);\nprofitFirm2 = calculateFirmProfit(\n    parameterMat,\n    global_param.entryMat,\n    global_param.numFirmsVec,\n    global_param.economyVec,\n    global_param.possibleActionArray,\n    2\n);"
  },
  {
    "objectID": "dynamic_game_data.html#ccpの計算",
    "href": "dynamic_game_data.html#ccpの計算",
    "title": "9  疑似データの生成",
    "section": "9.3 CCPの計算",
    "text": "9.3 CCPの計算\n\nCCP1Stay = repeat([0.5], 8);\nCCP2Stay = repeat([0.5], 8);\n\nCCP1Mat = (\n    hcat(\n        1 .- CCP1Stay,\n        CCP1Stay,\n        1 .- CCP1Stay,\n    ) .* \n    global_param.possibleActionArray[:, :, 1]\n    );\nCCP2Mat = (\n    hcat(\n        1 .- CCP2Stay,\n        CCP2Stay,\n        1 .- CCP2Stay,\n    ) .* \n    global_param.possibleActionArray[:, :, 2]\n    );\n\nstateTransitionMat = generateStateTransitionMat(\n    TransitionMat, \n    CCP1Mat, \n    CCP2Mat, \n    global_param.possibleActionArray\n    );\n\nequilibriumProfitFirm1 = calculateProfitGivenOpponentCCP(profitFirm1, CCP2Mat);\nequilibriumProfitFirm2 = calculateProfitGivenOpponentCCP(profitFirm2, CCP1Mat);\n\nexpectedShockUnderBestActionFirm1 = (\n    eulergamma .- replace(log.(CCP1Mat), -Inf => 0)\n)\nexpectedShockUnderBestActionFirm2 = (\n    eulergamma .- replace(log.(CCP2Mat), -Inf => 0)\n)\n\nexanteV1 = vec(\n    (I(8) - beta .* stateTransitionMat) \\ \n    sum(CCP1Mat .* (equilibriumProfitFirm1 + expectedShockUnderBestActionFirm1), dims = 2)\n);\n\nexanteV2 = vec(\n    (I(8) - beta .* stateTransitionMat) \\ \n    sum(CCP2Mat .* (equilibriumProfitFirm2 + expectedShockUnderBestActionFirm2), dims = 2)\n);\n\n\n# updatedCCP1Numerator = zeros(8, 3);\n# updatedCCP2Numerator = zeros(8, 3);\n# CCP1MatUpdated = zeros(8, 3);\n# CCP2MatUpdated = zeros(8, 3);\n# stateTransitionMatFirm2ActionSpecific = zeros(8, 8, 3);\n# stateTransitionMatFirm1ActionSpecific = zeros(8, 8, 3);\n\ndata_generate_struct = array_struct(\n    CCP1Mat,\n    CCP2Mat,\n    stateTransitionMat,\n    equilibriumProfitFirm1,\n    equilibriumProfitFirm2,\n    expectedShockUnderBestActionFirm1,\n    expectedShockUnderBestActionFirm2,\n    exanteV1,\n    exanteV2,\n    zeros(8, 3),\n    zeros(8, 3),\n    zeros(8, 3),\n    zeros(8, 3),\n    zeros(8, 8, 3),\n    zeros(8, 8, 3),\n    zeros(8),\n    zeros(8)\n);\n\n\ndiffExanteV = 1;\niter = 0;\n\n@time while (diffExanteV > 1e-12)\n\n    calculateFirm2ActionSpecificTransitionMat!(\n        TransitionMat, \n        data_generate_struct.CCP2Mat,\n        data_generate_struct.stateTransitionMatFirm2ActionSpecific,\n        global_param.possibleActionArray\n        );\n    calculateFirm1ActionSpecificTransitionMat!(\n        TransitionMat, \n        data_generate_struct.CCP1Mat,\n        data_generate_struct.stateTransitionMatFirm1ActionSpecific,\n        global_param.possibleActionArray\n        );\n\n    for i in 1:3\n        data_generate_struct.updatedCCP1Numerator[:, i] .= exp.(\n            view(data_generate_struct.equilibriumProfitFirm1, :, i) .+ \n            beta .* view(data_generate_struct.stateTransitionMatFirm2ActionSpecific, :, :, i) * \n            data_generate_struct.exanteV1 .*\n            view(global_param.possibleActionArray, :, i, 1)\n        );\n    end\n    data_generate_struct.CCP1MatUpdated .= (\n        (\n            data_generate_struct.updatedCCP1Numerator ./ \n            (sum(data_generate_struct.updatedCCP1Numerator, dims = 2) .- 1)) .* \n        view(global_param.possibleActionArray, :, :, 1)\n    );\n\n    for i in 1:3\n        data_generate_struct.updatedCCP2Numerator[:, i] .= exp.(\n            view(data_generate_struct.equilibriumProfitFirm2, :, i) .+ \n            beta .* view(data_generate_struct.stateTransitionMatFirm1ActionSpecific, :, :, i) * \n            data_generate_struct.exanteV2 .*\n            view(global_param.possibleActionArray, :, i, 2)\n        );\n    end\n    data_generate_struct.CCP2MatUpdated .= (\n        (\n            data_generate_struct.updatedCCP2Numerator ./ \n            (sum(data_generate_struct.updatedCCP2Numerator, dims = 2) .- 1)\n            ) .* \n        view(global_param.possibleActionArray, :, :, 2)\n    );\n\n    data_generate_struct.stateTransitionMat .= generateStateTransitionMat(\n        TransitionMat, \n        data_generate_struct.CCP1MatUpdated, \n        data_generate_struct.CCP2MatUpdated, \n        global_param.possibleActionArray\n        );\n\n    data_generate_struct.equilibriumProfitFirm1 .= calculateProfitGivenOpponentCCP(\n        profitFirm1, \n        data_generate_struct.CCP2MatUpdated\n        );\n    data_generate_struct.equilibriumProfitFirm2 .= calculateProfitGivenOpponentCCP(\n        profitFirm2, \n        data_generate_struct.CCP1MatUpdated\n        );\n\n    data_generate_struct.expectedShockUnderBestActionFirm1 .= (\n        eulergamma .- replace(log.(data_generate_struct.CCP1MatUpdated), -Inf => 0)\n    )\n    data_generate_struct.expectedShockUnderBestActionFirm2 .= (\n        eulergamma .- replace(log.(data_generate_struct.CCP2MatUpdated), -Inf => 0)\n    )\n\n    data_generate_struct.exanteV1Updated .= vec(\n        (I(8) - beta .* data_generate_struct.stateTransitionMat) \\ \n        sum(\n            data_generate_struct.CCP1MatUpdated .* (\n                data_generate_struct.equilibriumProfitFirm1 + \n                data_generate_struct.expectedShockUnderBestActionFirm1\n                ), dims = 2)\n    );\n\n    data_generate_struct.exanteV2Updated .= vec(\n        (I(8) - beta .* data_generate_struct.stateTransitionMat) \\ \n        sum(\n            data_generate_struct.CCP2MatUpdated .* (\n                data_generate_struct.equilibriumProfitFirm2 + \n                data_generate_struct.expectedShockUnderBestActionFirm2\n                ), dims = 2)\n    );\n\n    diffExanteV = sum(\n        (data_generate_struct.exanteV1Updated - data_generate_struct.exanteV1).^2\n        ) + sum(\n            (data_generate_struct.exanteV2Updated - data_generate_struct.exanteV2).^2\n            );\n\n    data_generate_struct.exanteV1 .= data_generate_struct.exanteV1Updated[:];\n    data_generate_struct.exanteV2 .= data_generate_struct.exanteV2Updated[:];\n\n    data_generate_struct.CCP1Mat .= data_generate_struct.CCP1MatUpdated[:, :];\n    data_generate_struct.CCP2Mat .= data_generate_struct.CCP2MatUpdated[:, :];\n\n    println(diffExanteV)\n    iter += 1;\n\nend\n\nCCP1Mat .= data_generate_struct.CCP1Mat;\nCCP2Mat .= data_generate_struct.CCP2Mat;\n\nexanteV1 = data_generate_struct.exanteV1;\nexanteV2 = data_generate_struct.exanteV2;\n\n9.059385123406884\n0.0010509979269102616\n5.0928397934340845e-6\n5.6083848572020334e-8\n5.889460824473882e-10\n5.5728209722870154e-12\n3.866293900916097e-14\n  1.262130 seconds (5.23 M allocations: 332.698 MiB, 3.42% gc time, 98.65% compilation time)"
  },
  {
    "objectID": "dynamic_game_data.html#疑似データの生成",
    "href": "dynamic_game_data.html#疑似データの生成",
    "title": "9  疑似データの生成",
    "section": "9.4 疑似データの生成",
    "text": "9.4 疑似データの生成\n\nNumSimMarkets = 500;\nNumSimPeriods = 50;\nNumSimFirms = 2;\n\n\nInitialState = sample(1:8, NumSimMarkets);\n\nRandomNumbers = reshape(\n    rand(NumSimMarkets * NumSimPeriods * (NumSimFirms + 1)),\n    (NumSimMarkets, NumSimPeriods, NumSimFirms + 1)\n);\n\n\nFakeData = zeros(NumSimMarkets * NumSimPeriods, 8);\n\nfor m in 1:NumSimMarkets, t in 1:NumSimPeriods\n\n    FakeData[(m - 1) * NumSimPeriods + t, 1] = m;\n    FakeData[(m - 1) * NumSimPeriods + t, 2] = t;\n\n    if t == 1\n\n        FakeData[(m - 1) * NumSimPeriods + 1, 3] = InitialState[m];\n\n        FakeData[(m - 1) * NumSimPeriods + 1, 4] = (\n            (InitialState[m] >= 1) & (InitialState[m] <= 4) ? 1 :\n            2\n        );\n\n    else\n\n        sprev = FakeData[(m - 1) * NumSimPeriods + t - 1, 3]\n        a1prev = FakeData[(m - 1) * NumSimPeriods + t - 1, 7]\n        a2prev = FakeData[(m - 1) * NumSimPeriods + t - 1, 8]\n\n        if (sprev >= 1) & (sprev <= 4)\n            FakeData[(m - 1) * NumSimPeriods + t, 4] = (\n                (RandomNumbers[m, t, 3] < TransitionMat[1, 1]) ? 1 :\n                2\n            );\n        else\n            FakeData[(m - 1) * NumSimPeriods + t, 4] = (\n                (RandomNumbers[m, t, 3] < TransitionMat[2, 2]) ? 2 :\n                1\n            );\n        end\n\n        snow = FakeData[(m - 1) * NumSimPeriods + t, 4];\n        n1t = FakeData[(m - 1) * NumSimPeriods + t - 1, 5] + a1prev;\n        n2t = FakeData[(m - 1) * NumSimPeriods + t - 1, 6] + a2prev;\n\n        FakeData[(m - 1) * NumSimPeriods + t, 3] = (\n            (snow == 1) & (n1t == 0) & (n2t == 0) ? 1 :\n            (snow == 1) & (n1t == 0) & (n2t == 1) ? 2 :\n            (snow == 1) & (n1t == 1) & (n2t == 0) ? 3 :\n            (snow == 1) & (n1t == 1) & (n2t == 1) ? 4 :\n            (snow == 2) & (n1t == 0) & (n2t == 0) ? 5 :\n            (snow == 2) & (n1t == 0) & (n2t == 1) ? 6 :\n            (snow == 2) & (n1t == 1) & (n2t == 0) ? 7 :\n            (snow == 2) & (n1t == 1) & (n2t == 1) ? 8 :\n            0\n        );\n\n    end\n\n    s = Int(FakeData[(m - 1) * NumSimPeriods + t, 3]);\n\n    if s == 1\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 0, 0];\n        if (RandomNumbers[m, t, 1] > CCP1Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 2\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 0, 1];\n        if (RandomNumbers[m, t, 1] > CCP1Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    elseif s == 3\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 1, 0];\n        if (RandomNumbers[m, t, 1] > CCP1Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 4\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [1, 1, 1];\n        if (RandomNumbers[m, t, 1] > CCP1Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    elseif s == 5\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 0, 0];\n        if (RandomNumbers[m, t, 1] > CCP1Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 6\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 0, 1];\n        if (RandomNumbers[m, t, 1] > CCP1Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = 1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    elseif s == 7\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 1, 0];\n        if (RandomNumbers[m, t, 1] > CCP1Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = 1;\n        end\n    elseif s == 8\n        FakeData[(m - 1) * NumSimPeriods + t, 4:6] .= [2, 1, 1];\n        if (RandomNumbers[m, t, 1] > CCP1Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 7] = -1;\n        end\n        if (RandomNumbers[m, t, 2] > CCP2Mat[s, 2])\n            FakeData[(m - 1) * NumSimPeriods + t, 8] = -1;\n        end\n    end\nend\n\n\njldsave(\n    \"tmp/dynamic_game/data_workspace.jld2\" ;\n    FakeData, CCP1Mat, CCP2Mat, \n    exanteV1, exanteV2, global_param\n)"
  },
  {
    "objectID": "dynamic_game_estimation_1.html#パラメタの設定",
    "href": "dynamic_game_estimation_1.html#パラメタの設定",
    "title": "10  推定 1",
    "section": "10.1 パラメタの設定",
    "text": "10.1 パラメタの設定\n\nNumSimMarkets = 500;\nNumSimPeriods = 50;\n\nRandom.seed!(123);\n\n\nParameters = [\n    0.3,\n    0.2,\n    -0.27,\n    0.45,\n    -0.15,\n    -2.10\n];\n\nparameterMat = hcat([\n    [Parameters[i]; Parameters[3:6]]\n    for i in 1:2\n]...);\n\nTransitionMat = [0.7 0.3; 0.4 0.6];"
  },
  {
    "objectID": "dynamic_game_estimation_1.html#前章で生成したデータの読み込み",
    "href": "dynamic_game_estimation_1.html#前章で生成したデータの読み込み",
    "title": "10  推定 1",
    "section": "10.2 前章で生成したデータの読み込み",
    "text": "10.2 前章で生成したデータの読み込み\n\n@load \"tmp/dynamic_game/data_workspace.jld2\";"
  },
  {
    "objectID": "dynamic_game_estimation_1.html#ccpの推定",
    "href": "dynamic_game_estimation_1.html#ccpの推定",
    "title": "10  推定 1",
    "section": "10.3 CCPの推定",
    "text": "10.3 CCPの推定\n\nEstimatedCCP1Mat, EstimatedCCP2Mat = estimateCCPMat(\n    FakeData, global_param\n);"
  },
  {
    "objectID": "dynamic_game_estimation_1.html#遷移行列の推定",
    "href": "dynamic_game_estimation_1.html#遷移行列の推定",
    "title": "10  推定 1",
    "section": "10.4 遷移行列の推定",
    "text": "10.4 遷移行列の推定\n\nEstimatedTransition = estimateTransition(FakeData);\n\n\nhcat(EstimatedCCP1Mat[:, 2], EstimatedCCP2Mat[:, 2])\n\n8×2 Matrix{Float64}:\n 0.671276  0.718293\n 0.70041   0.800378\n 0.827299  0.746308\n 0.797659  0.767725\n 0.705617  0.714142\n 0.725334  0.761288\n 0.789778  0.76567\n 0.787342  0.736392\n\n\n\nEstimatedTransition\n\n2×2 Matrix{Float64}:\n 0.700071  0.299929\n 0.400289  0.599711\n\n\n\n10.4.1 関数が正しく挙動しているかのチェック\n\noutput = updateCCP(\n    parameterMat,\n    CCP1Mat,\n    CCP2Mat,\n    TransitionMat,\n    global_param\n);\n\n\nprintln(\"Difference between CCP in GDP and predicted CCP\")\n\nDifference between CCP in GDP and predicted CCP\n\n\n\nCCP1Mat - output[1]\n\n8×3 Matrix{Float64}:\n  0.0         -1.95367e-9  1.95367e-9\n  0.0         -2.42611e-9  2.42611e-9\n -1.33685e-9   1.33685e-9  0.0\n -1.75907e-9   1.75907e-9  0.0\n  0.0         -1.94553e-9  1.94553e-9\n  0.0         -2.46917e-9  2.46917e-9\n -1.3948e-9    1.3948e-9   0.0\n -2.09866e-9   2.09866e-9  0.0\n\n\n\nCCP2Mat - output[2]\n\n8×3 Matrix{Float64}:\n  0.0         -6.91787e-9  6.91787e-9\n -5.08387e-9   5.08387e-9  0.0\n  0.0         -5.43541e-9  5.43541e-9\n -5.30343e-9   5.30343e-9  0.0\n  0.0         -6.37121e-9  6.37121e-9\n -5.46061e-9   5.46061e-9  0.0\n  0.0         -5.44987e-9  5.44987e-9\n -6.33131e-9   6.33131e-9  0.0\n\n\n\nNormalized_TrueParam = [\n    Parameters[1] - ((1 - global_param.beta) / global_param.beta) * Parameters[5],\n    Parameters[3],\n    Parameters[4],\n    0,\n    Parameters[6] + Parameters[5],\n    Parameters[2] - ((1 - global_param.beta) / global_param.beta) * Parameters[5],\n    Parameters[3],\n    Parameters[4],\n    0,\n    Parameters[6] + Parameters[5],\n];\n\noutput_normalized = updateCCP(\n    reshape(Normalized_TrueParam, (:, 2)),\n    CCP1Mat,\n    CCP2Mat,\n    TransitionMat,\n    global_param\n);\n\nprintln(\"Difference: predicted CCP in true parameter and normalized parameter\")\n\nDifference: predicted CCP in true parameter and normalized parameter\n\n\n\noutput_normalized[1] - output[1]\n\n8×3 Matrix{Float64}:\n 0.0           2.22045e-16  -1.66533e-16\n 0.0           0.0           0.0\n 2.498e-16    -2.22045e-16   0.0\n 1.38778e-16  -1.11022e-16   0.0\n 0.0           4.44089e-16  -3.33067e-16\n 0.0           2.22045e-16  -2.77556e-16\n 8.32667e-17  -2.22045e-16   0.0\n 3.33067e-16  -2.22045e-16   0.0\n\n\n\noutput_normalized[2] - output[2]\n\n8×3 Matrix{Float64}:\n  0.0           1.11022e-16  -1.11022e-16\n -1.38778e-16   2.22045e-16   0.0\n  0.0           0.0           0.0\n  2.77556e-17   2.22045e-16   0.0\n  0.0          -1.11022e-16   1.11022e-16\n  0.0           0.0           0.0\n  0.0           0.0          -1.66533e-16\n -5.55112e-17   1.11022e-16   0.0"
  },
  {
    "objectID": "dynamic_game_estimation_1.html#pesendorfer-and-schmidt-denglerの方法によるパラメタの推定",
    "href": "dynamic_game_estimation_1.html#pesendorfer-and-schmidt-denglerの方法によるパラメタの推定",
    "title": "10  推定 1",
    "section": "10.5 Pesendorfer and Schmidt-Denglerの方法によるパラメタの推定",
    "text": "10.5 Pesendorfer and Schmidt-Denglerの方法によるパラメタの推定\n\ninitial = [Parameters[1:4]; Parameters[6]];\nmat_initial2 = initial .* reshape(rand(Uniform(0.6, 1.2), 50), (5, :));\nresult = zeros(6, 10);\n\n@time for i in 1:10\n    sol = optimize(\n        x -> calculatePSDObjective(\n            x,\n            EstimatedCCP1Mat, \n            EstimatedCCP2Mat, \n            EstimatedTransition, \n            global_param\n            ),\n        mat_initial2[:, i],\n        Optim.Options(show_trace = false)\n    );\n    result[:, i] = [sol.minimizer; sol.minimum];\nend\n\nresult_pick = result[1:5, argmin(result[6, :])];\n\n  0.894520 seconds (5.11 M allocations: 392.116 MiB, 8.88% gc time, 81.60% compilation time)\n\n\n\nnormalized_trueparam = [\n    Normalized_TrueParam[1],\n    Normalized_TrueParam[6],\n    Normalized_TrueParam[2],\n    Normalized_TrueParam[3],\n    Normalized_TrueParam[5],\n];\n\nDataFrame(\n    param_est = result_pick,\n    normalized_trueparam = normalized_trueparam\n)\n\n\n5×2 DataFrameRowparam_estnormalized_trueparamFloat64Float6410.3487870.337520.2238680.23753-0.291698-0.2740.4926550.455-2.22346-2.25\n\n\n\nnumBootSample = 100;\n\nbootindex = reshape(\n    sample(1:NumSimMarkets, NumSimMarkets * numBootSample),\n    (NumSimMarkets, numBootSample)\n);\n\n\nbootresult_transition = zeros(2, numBootSample);\nbootresult_CCP1 = zeros(8, numBootSample);\nbootresult_CCP2 = zeros(8, numBootSample);\nbootresult_payoff = zeros(5, numBootSample);\n\n\n@time for b in 1:numBootSample\n    bootsample = zeros(NumSimPeriods * NumSimMarkets, 8);\n    for m in 1:NumSimMarkets\n        temp = FakeData[FakeData[:, 1] .== bootindex[m, b], :];\n        bootsample[(1 + NumSimPeriods * (m - 1)):(NumSimPeriods * m), :] = temp;\n    end\n\n    output = Estimation_PS_bootstrap(bootsample, global_param);\n\n    bootresult_CCP1[:, b] = output[1][:, 2];\n    bootresult_CCP2[:, b] = output[2][:, 2];\n    bootresult_transition[:, b] = diag(output[3]);\n    bootresult_payoff[:, b] = output[4];\nend\n\n  3.938225 seconds (17.45 M allocations: 13.188 GiB, 16.14% gc time, 1.48% compilation time)\n\n\n\nprintln(\"CCP for firm 1\")\nDataFrame(\n    \"True values\" => CCP1Mat[:, 2],\n    \"Estimated\" => vec(EstimatedCCP1Mat[:, 2]),\n    \"SE\" => vec(std(bootresult_CCP1, dims=2))\n)\n\nCCP for firm 1\n\n\n\n8×3 DataFrameRowTrue valuesEstimatedSEFloat64Float64Float6410.6835630.6712760.0091672420.7126620.700410.0076721230.8156510.8272990.0062089240.7938190.7976590.0057718650.7080670.7056170.0095922560.7359650.7253340.0089972670.7975470.7897780.0086046680.7741370.7873420.00711149\n\n\n\nprintln(\"CCP for firm 2\")\nDataFrame(\n    \"True values\" => CCP2Mat[:, 2],\n    \"Estimated\" => vec(EstimatedCCP2Mat[:, 2]),\n    \"SE\" => vec(std(bootresult_CCP2, dims=2))\n)\n\nCCP for firm 2\n\n\n\n8×3 DataFrameRowTrue valuesEstimatedSEFloat64Float64Float6410.7147250.7182930.0096869420.7924090.8003780.0073107830.7416970.7463080.0057263840.7687310.7677250.0064062850.7376850.7141420.010424760.7727060.7612880.0083257770.763530.765670.0072145480.74730.7363920.00769535\n\n\n\nprintln(\"Transition Probability (GG and BB)\")\nDataFrame(\n    \"True values\" => diag(TransitionMat),\n    \"Estimated\" => diag(EstimatedTransition),\n    \"SE\" => vec(std(bootresult_transition, dims=2))\n)\n\nTransition Probability (GG and BB)\n\n\n\n2×3 DataFrameRowTrue valuesEstimatedSEFloat64Float64Float6410.70.7000710.0033715420.60.5997110.0045105\n\n\n\nDataFrame(\n    \"True values\" => initial,\n    \"Normalized true values\" => Normalized_TrueParam[[1, 6, 2, 3, 5]],\n    \"Estimated\" => result_pick,\n    \"SE\" => vec(std(bootresult_payoff, dims=2))\n    )\n\n\n5×4 DataFrameRowTrue valuesNormalized true valuesEstimatedSEFloat64Float64Float64Float6410.30.33750.3487870.054496120.20.23750.2238680.05570813-0.27-0.27-0.2916980.038532140.450.450.4926550.0894355-2.1-2.25-2.223460.0196745\n\n\n\n@save \"tmp/dynamic_game/estimates_1.jld2\" EstimatedCCP1Mat EstimatedCCP2Mat EstimatedTransition;"
  },
  {
    "objectID": "demand_estimation_merger.html#データの読み込み",
    "href": "demand_estimation_merger.html#データの読み込み",
    "title": "4  応用編",
    "section": "4.1 データの読み込み",
    "text": "4.1 データの読み込み\n\ndata = CSV.read(\"data/demand_estimation_merger/chap3_data.csv\", DataFrame);\nfirst(data, 5)\n\n\n5×61 DataFrameRowNameIDyearMakerTypeNameSalesModelpricekataFuelEfficiencycapacityFuelTypeHHsizehppwshareshare0hppw_sum_ownFuelEfficiency_sum_ownsize_sum_ownhppw_sqr_sum_ownFuelEfficiency_sqr_sum_ownsize_sqr_sum_ownhppw_sum_mktFuelEfficiency_sum_mktsize_sum_mkthppw_sqr_sum_mktFuelEfficiency_sqr_sum_mktsize_sqr_sum_mktiv_BLP_own_hppwiv_BLP_own_FuelEfficiencyiv_BLP_own_sizeiv_BLP_other_hppwiv_BLP_other_FuelEfficiencyiv_BLP_other_sizeiv_BLP_own_numiv_BLP_other_numiv_GH_own_hppwiv_GH_own_FuelEfficiencyiv_GH_own_sizeiv_GH_other_hppwiv_GH_other_FuelEfficiencyiv_GH_other_sizelogit_shareiv_BLP_own_hppw_nestiv_BLP_own_FuelEfficiency_nestiv_BLP_own_size_nestiv_BLP_other_hppw_nestiv_BLP_other_FuelEfficiency_nestiv_BLP_other_size_nestiv_BLP_own_num_nestiv_BLP_other_num_nestiv_GH_own_hppw_nestiv_GH_own_FuelEfficiency_nestiv_GH_own_size_nestiv_GH_other_hppw_nestiv_GH_other_FuelEfficiency_nestiv_GH_other_size_nestsum_year_bodyinside_sharelog_inside_shareInt64Int64String15String7String31Int64StringFloat64String15Float64Int64String15Int64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Int64Int64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Float64Int64Int64Float64Float64Float64Float64Float64Float64Int64Float64Float641142011AudiForeignA1シリーズ42061.4 TFSI2.99804DBA-8XCAX19.44ハイオク537834359.947230.1025217.82025e-50.9389810.29906149.433.13970.0299428831.48369.0741.93875276.2218.5640.2070444206.042550.970.1965430.023.192515.72292464.51811.6121570.00015442343.846.619650.2163155703.331332.33-9.393250.1965430.023.19251.63969226.8185.4242160.00015442343.846.619650.00906462596.4876.13911433570.0293393-3.528832142012AudiForeignA1シリーズ45021.4 TFSI2.835DBA-8XCAX19.44ハイオク541714759.947230.1025218.31065e-50.9197620.30998449.833.17910.0323769842.36370.0511.83969298.3215.5090.1825244896.572484.020.20746330.423.231916.18512659.31891.3621640.00034886539.26.81180.220626457.491428.51-9.311750.20746330.423.23191.5297248.5182.332160.00034886539.26.81180.00466326434.1769.77421592100.0282771-3.56573142013AudiForeignA1シリーズ50711.4 TFSI2.82326DBA-8XCAX19.44ハイオク545947449.947230.1025219.28844e-50.9195630.31182852.733.54560.0327145947.05378.121.95986334.4228.3990.1966265760.22656.10.20930733.323.598315.53852762.21857.6321610.00030821531.377.591380.2016286612.261400.56-9.20030.20930733.323.59831.64803281.7194.8532170.00030821531.377.591380.00467482281.3183.58731918740.0264288-3.63334152006AudiForeignA3シリーズ4830アトラクション2.91889GH-8PBSE12.25ハイオク5110200510.81510.0759.45168e-50.9152280.16343523.422.42020.0134458274.28251.6451.97874224.8231.4730.2079982577.222715.960.088435411.211.605116.16092391.01840.911630.0001805091.00.6240490.2553134557.361004.29-9.178150.088435411.211.60511.81531201.4209.0531180.0001805091.00.6240490.02350667.947.84971694880.0284976-3.557945152007AudiForeignA3シリーズ3874アトラクション2.93944GH-8PBSE12.25ハイオク5171304810.81510.0757.49134e-50.9201740.31268935.433.1110.0357225418.28365.9382.08997225.1232.3580.2309082583.732733.060.23768923.222.295916.05342382.01839.1621620.005694131.040.6395140.2528114335.921039.11-9.415990.23768923.222.29591.77728189.7199.2472170.005694131.040.6395140.024219467.0545.79411620150.0239114-3.7334"
  },
  {
    "objectID": "demand_estimation_merger.html#データクリーニング",
    "href": "demand_estimation_merger.html#データクリーニング",
    "title": "4  応用編",
    "section": "4.2 データクリーニング",
    "text": "4.2 データクリーニング\n\ndata[!, :Foreign_d] = data[:, :Type] .== \"Foreign\";\ndata[!, :FuelRegular_d] = data[:, :FuelType] .== \"レギュラー\";\ndata[!, :capacity_d] = data[:, :capacity] .> 4;\ntransform!(\n    data, \n    [\n        :year => ByRow(isequal(v))=> Symbol(\"year_\" * string(v)) \n        for v in unique(data.year)\n        ]\n    );\nselect!(data, Not(:year_2006));"
  },
  {
    "objectID": "demand_estimation_merger.html#ランダム係数ロジットモデルの推定",
    "href": "demand_estimation_merger.html#ランダム係数ロジットモデルの推定",
    "title": "4  応用編",
    "section": "4.3 ランダム係数ロジットモデルの推定",
    "text": "4.3 ランダム係数ロジットモデルの推定\n\nsort!(data, [:year, :Maker, :price]);\nN = nrow(data);\nT = length(unique(data.year));\nX1 = hcat(\n    ones(N),\n    Matrix(\n        data[:,[\n            :price, :FuelEfficiency, :hppw, :size, \n            :capacity_d, :FuelRegular_d, :Foreign_d\n            ]]\n        ),\n    Matrix(data[:, r\"^year_\"])    \n    );\nX2 = Matrix(data[:, [:price]]);\nZ = hcat(\n    ones(N),\n    Matrix(\n        data[:, [\n            :FuelEfficiency, :hppw, :size, \n            :capacity_d, :FuelRegular_d, :Foreign_d\n            ]]\n        ),\n    Matrix(data[:, r\"^year_\"]),\n    Matrix(data[:, r\"^iv_GH.*(?<!nest)$\"])\n    );\n\nRandom.seed!(42);\nNsim = 1000;\n\nrandomDrawMat = randn(size(X2)[2], Nsim);\n\n\nmarketIndex = data.year;\nuniqueMarketIndex = sort(unique(data.year));\n\nmarketIndexMat = reduce(\n    hcat, \n    [marketIndex .== market for market in uniqueMarketIndex]\n    );\n\ndatalist = datalist_struct(\n    X1, \n    X2, \n    Z, \n    data.share, \n    marketIndex, \n    data.logit_share, \n    randomDrawMat, \n    marketIndexMat\n    );\nparameter = parameter_struct(Nsim, T, N);\n\n\ninitial_x = [0.7];\ndelta_ini = calculateMeanUtil(initial_x, datalist, datalist.logitshare);\n\n\nobjFunc_for_Optim = OnceDifferentiable(\n    x -> calculateGMMObjective(x, datalist, delta_ini),\n    initial_x;\n    autodiff = :forward\n    );\n@time resultGMM = optimize(\n    objFunc_for_Optim,\n    [0.0],\n    [Inf],\n    initial_x,\n    Fminbox(),\n    Optim.Options(show_trace = false)\n)\n\n\nW = inv(datalist.Z' * datalist.Z);    \ndelta = calculateMeanUtil(resultGMM.minimizer, datalist, delta_ini);\nbeta_hat = (\n    (datalist.X1' * datalist.Z * W * datalist.Z' * datalist.X1) \\ \n    (datalist.X1' * datalist.Z * W * datalist.Z' * delta)\n);\n\n\nXi = delta - X1 * beta_hat;\nOmega_hat = reduce(+, Z[i,:] * Z[i,:]' .* Xi[i]^2 ./ N for i = 1:N);\nDdelta = ForwardDiff.jacobian(\n    x -> delta_ini = calculateMeanUtil(x, datalist, delta), \n    resultGMM.minimizer\n    );\nG = Z' * hcat(- X1, Ddelta) ./ N;\nAsyVarMat = (G' * W * G) \\ G' * W * Omega_hat * W * G * inv(G' * W * G);\nAse = sqrt.(diag(AsyVarMat) ./ N);\nDataFrame(\n    Var = [\n        \"Const\", \"Price\", \"Fuel Efficiency\", \"hppw\", \"size\", \n        \"capacity_d\", \"FuelRegular_d\", \"Foreign_d\",\n        \"year_2007\", \"year_2008\", \"year_2009\", \n        \"year_2010\", \"year_2011\", \"year_2012\", \n        \"year_2013\", \"year_2014\", \"year_2015\", \"year_2016\", \n        \"random_price\"\n        ],\n    Est = vcat(beta_hat, resultGMM.minimizer),\n    se = Ase\n)\n\n\n19×3 DataFrameRowVarEstseStringFloat64Float641Const-13.90270.5685532Price-2.27820.6602783Fuel Efficiency0.1966780.0126334hppw14.67053.612495size0.555190.07666446capacity_d-0.3230590.1390027FuelRegular_d-1.139950.2920498Foreign_d1.043150.194869year_2007-0.8361530.17655910year_2008-0.7042570.16922811year_2009-0.8563190.16901212year_2010-0.09763510.15240213year_2011-0.2540890.15260414year_2012-0.4873420.1641115year_2013-0.6251380.16678516year_2014-1.049740.18015717year_2015-1.151210.17902518year_2016-1.25020.18026419random_price0.700290.248176\n\n\n\nmarket2016Index = data.year .== 2016;\ndata_2016 = data[market2016Index, :];\n\n@time elasmat_2016 = calculateElasticity(\n    data_2016.price,\n    X2[market2016Index, :],\n    beta_hat,\n    resultGMM.minimizer,\n    randomDrawMat,\n    delta[market2016Index]\n);\n\n  0.270182 seconds (691.04 k allocations: 54.730 MiB, 86.41% compilation time)"
  },
  {
    "objectID": "demand_estimation_merger.html#限界費用の推定",
    "href": "demand_estimation_merger.html#限界費用の推定",
    "title": "4  応用編",
    "section": "4.4 限界費用の推定",
    "text": "4.4 限界費用の推定\n\nPricevec_2016 = data_2016.price;\nSharevec_2016 = data_2016.share;\n\nXi_2016 = Xi[data.year .== 2016];\nOwnership_2016 = data_2016.Maker .== permutedims(data_2016.Maker);\nDerivative_2016 = - elasmat_2016 .* Sharevec_2016' ./ Pricevec_2016;\nDelta_2016 = Derivative_2016 .* Ownership_2016;\nMarginal_Cost_2016 = Pricevec_2016 - (Delta_2016 \\ Sharevec_2016);\npred_mc_df = DataFrame(\n    Maker = data_2016.Maker, \n    Name = data_2016.Name, \n    Price = data_2016.price,\n    MC = Marginal_Cost_2016,\n    Margin = (data_2016.price .- Marginal_Cost_2016) ./ data_2016.price\n);\nfirst(pred_mc_df, 10)\n\n\n10×5 DataFrameRowMakerNamePriceMCMarginString15String31Float64Float64Float641AudiA3シリーズ3.282.417260.2630312AudiA4シリーズ5.183.740930.2778123BMWミニ2.41.70010.2916264BMW1シリーズ3.12.271910.2671275BMWX13.672.713450.260646BMW2シリーズ3.812.817960.2603787BMW3シリーズ4.493.299240.2652028Daihatsuミラ0.8850.3790430.5717039Daihatsuムーヴ1.1340.6012330.46981210Daihatsuブーン1.150.6154430.464832\n\n\n\nhistogram(pred_mc_df.Margin, bins = 40, legend = false)"
  },
  {
    "objectID": "demand_estimation_merger.html#合併シミュレーション",
    "href": "demand_estimation_merger.html#合併シミュレーション",
    "title": "4  応用編",
    "section": "4.5 合併シミュレーション",
    "text": "4.5 合併シミュレーション\n\n4.5.1 データの下準備\n\ndata_2016 = leftjoin(data_2016, pred_mc_df, on = [\"Maker\", \"Name\"]);\ndropmissing!(data_2016);\n\ndata_2016[data_2016.Maker .== \"Honda\", :Maker] .= \"Nippyo\";\ndata_2016[data_2016.Maker .== \"Nissan\", :Maker] .= \"BrandA\";\ndata_2016[data_2016.Maker .== \"Subaru\", :Maker] .= \"BrandB\";\ndata_2016[data_2016.Maker .== \"Toyota\", :Maker] .= \"BrandC\";\n\ndata_2016[!, :MakerNippyoA] = data_2016[:, :Maker];\ndata_2016[!, :MakerNippyoB] = data_2016[:, :Maker];\ndata_2016[in([\"Nippyo\", \"BrandA\"]).(data_2016[:, :Maker]), :MakerNippyoA] .= \"NippyoA\";\ndata_2016[in([\"Nippyo\", \"BrandB\"]).(data_2016[:, :Maker]), :MakerNippyoB] .= \"NippyoB\";\n\nOwnership_true = data_2016.Maker .== permutedims(data_2016.Maker);\nOwnership_NippyoA = data_2016.MakerNippyoA .== permutedims(data_2016.MakerNippyoA);\nOwnership_NippyoB = data_2016.MakerNippyoB .== permutedims(data_2016.MakerNippyoB);\n\n\nmc = data_2016.MC;\ndatalist_2016 = datalist_struct(\n    X1[market2016Index, :],\n    X2[market2016Index, :],\n    Z[market2016Index, :],\n    data_2016.share,\n    data_2016.year,\n    data_2016.logit_share,\n    datalist.randomDrawMat,\n    datalist.marketIndexMat[market2016Index, :]\n);\n\n\np_NippyoA = calculateEquilibriumPrice(\n    datalist_2016,\n    data_2016.price,\n    Ownership_NippyoA,\n    beta_hat,\n    resultGMM.minimizer,\n    mc,\n    Xi_2016\n);\n\np_NippyoB = calculateEquilibriumPrice(\n    datalist_2016,\n    data_2016.price,\n    Ownership_NippyoB,\n    beta_hat,\n    resultGMM.minimizer,\n    mc,\n    Xi_2016\n);\n\n\n\n4.5.2 合併シミュレーションによる価格・販売台数変化\n\nmerger_sim_df = DataFrame(\n    Maker = data_2016.Maker, \n    Name = data_2016.Name, \n    Price_A = (p_NippyoA .- data_2016.price) ./ data_2016.price .* 100.0,\n    Share_A = (simulateMarketShare(\n                datalist_2016,\n                p_NippyoA,\n                beta_hat,\n                resultGMM.minimizer,\n                Xi_2016\n            ) .- data_2016.share) ./ data_2016.share .* 100.0,\n    Price_B = (p_NippyoB .- data_2016.price) ./ data_2016.price .* 100.0,\n    Share_B = (simulateMarketShare(\n                datalist_2016,\n                p_NippyoB,\n                beta_hat,\n                resultGMM.minimizer,\n                Xi_2016\n            ) .- data_2016.share) ./ data_2016.share .* 100.0,\n);\n\nmerger_sim_df[in([\"Nippyo\", \"BrandA\", \"BrandB\", \"BrandC\"]).(merger_sim_df.Maker), :]\n\n\n92×6 DataFrame67 rows omittedRowMakerNamePrice_AShare_APrice_BShare_BString15String31Float64Float64Float64Float641NippyoN-WGN0.541509-1.131540.205652-0.430362NippyoN-ONE0.53828-1.140050.204763-0.4343453NippyoN-BOX0.526869-1.174710.201748-0.4506354Nippyoフィット0.523412-1.187010.200885-0.4564445Nippyoバモス0.515992-1.217490.199145-0.47096Nippyoシャトル0.497664-1.351510.196526-0.53547Nippyoグレイス0.49624-1.374680.196691-0.5466948Nippyoフリード0.49438-1.429580.197626-0.5736019Nippyoヴェゼル0.49419-1.446490.198051-0.58193110NippyoS6600.494207-1.471870.198799-0.59446311Nippyoステップワゴン0.499161-1.601880.204403-0.65920112NippyoCR-V0.50524-1.678130.208852-0.69748213Nippyoジェイド0.507676-1.703120.210473-0.710059⋮⋮⋮⋮⋮⋮⋮81BrandCエスクァイア0.005198140.05002990.002336690.020408682BrandCハイエースワゴン0.005181980.05049960.002325830.020635883BrandCハリアー0.005148660.05139390.002302890.021070984BrandCアルファード0.00495420.05519050.002162160.022958185BrandCヴェルファイア0.00495420.05519050.002162160.022958186BrandCカムリ0.004948050.05528350.002157630.023005287BrandCFJクルーザー0.004927890.05558040.002142760.023155988BrandCエスティマ0.004907640.05586710.002127790.023301889BrandCSAI0.004885270.05617140.002111250.023457290BrandCクラウン0.004417960.06074080.001763940.025858191BrandCランドクルーザー0.002765480.06876540.0005327120.030472992BrandCセンチュリー-0.004203070.0562356-0.00342010.0171902\n\n\n\n\n4.5.3 合併後に価格が変化しないような限界費用の計算\n\nOwnership_2016_A = data_2016.MakerNippyoA .== permutedims(data_2016.MakerNippyoA);\nDerivative_2016_A = - elasmat_2016 .* Sharevec_2016' ./ Pricevec_2016;\nDelta_2016_A = Derivative_2016_A .* Ownership_2016_A;\nmc_NippyoA_pfix = Pricevec_2016 - (Delta_2016_A \\ Sharevec_2016);\n\nOwnership_2016_B = data_2016.MakerNippyoB .== permutedims(data_2016.MakerNippyoB);\nDerivative_2016_B = - elasmat_2016 .* Sharevec_2016' ./ Pricevec_2016;\nDelta_2016_B = Derivative_2016_B .* Ownership_2016_B;\nmc_NippyoB_pfix = Pricevec_2016 - (Delta_2016_B \\ Sharevec_2016);\n\nmc_sim_df = DataFrame(\n    Maker = data_2016.Maker, \n    Name = data_2016.Name, \n    Nippyo_and_Brand_A = (mc_NippyoA_pfix .- mc) ./ mc .* 100.0,\n    Nippyo_and_Brand_B = (mc_NippyoB_pfix .- mc) ./ mc .* 100.0,\n);\n\nmc_sim_df[in([\"Nippyo\", \"BrandA\", \"BrandB\", \"BrandC\"]).(mc_sim_df.Maker), :]\n\n\n92×4 DataFrame67 rows omittedRowMakerNameNippyo_and_Brand_ANippyo_and_Brand_BString15String31Float64Float641NippyoN-WGN-0.91733-0.3492872NippyoN-ONE-0.900594-0.3434753NippyoN-BOX-0.842563-0.3234514Nippyoフィット-0.825194-0.3175065Nippyoバモス-0.787848-0.3048226Nippyoシャトル-0.685154-0.2712147Nippyoグレイス-0.673848-0.2677298Nippyoフリード-0.651828-0.2611929Nippyoヴェゼル-0.646177-0.25958610NippyoS660-0.638542-0.25748311Nippyoステップワゴン-0.611683-0.25112212NippyoCR-V-0.60284-0.24986913Nippyoジェイド-0.600761-0.249749⋮⋮⋮⋮⋮81BrandCエスクァイア0.00.082BrandCハイエースワゴン0.00.083BrandCハリアー0.00.084BrandCアルファード0.00.085BrandCヴェルファイア0.00.086BrandCカムリ0.00.087BrandCFJクルーザー0.00.088BrandCエスティマ0.00.089BrandCSAI0.00.090BrandCクラウン0.00.091BrandCランドクルーザー0.00.092BrandCセンチュリー0.00.0\n\n\n\n\n4.5.4 合併シミュレーションの厚生分析\n\nCS_2016 = calculateCS(\n    datalist_2016, \n    data_2016.price, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016,\n    data_2016.HH[1]\n);\n\nCS_NippyoA = calculateCS(\n    datalist_2016, \n    p_NippyoA, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016,\n    data_2016.HH[1]\n);\n\nCS_NippyoB = calculateCS(\n    datalist_2016, \n    p_NippyoB, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016,\n    data_2016.HH[1]\n);\n\nCV_NippyoA = CS_NippyoA - CS_2016;\nCV_NippyoB = CS_NippyoB - CS_2016;\n\n\npro_rev_2016 = calculateProfit(\n    data_2016.Maker,\n    data_2016.price,\n    mc,\n    data_2016.share,\n    data_2016.HH\n);\npro_rev_NippyoA = calculateProfit(\n    data_2016.Maker,\n    p_NippyoA,\n    mc,\n    simulateMarketShare(\n                datalist_2016,\n                p_NippyoA,\n                beta_hat,\n                resultGMM.minimizer,\n                Xi_2016,\n            ),\n    data_2016.HH\n);\npro_rev_NippyoB = calculateProfit(\n    data_2016.Maker,\n    p_NippyoB,\n    mc,\n    simulateMarketShare(\n                datalist_2016,\n                p_NippyoB,\n                beta_hat,\n                resultGMM.minimizer,\n                Xi_2016,\n            ),\n    data_2016.HH\n);\n\nTS_change_NippyoA = CV_NippyoA + sum(pro_rev_NippyoA.profit - pro_rev_2016.profit);\nTS_change_NippyoB = CV_NippyoB + sum(pro_rev_NippyoB.profit - pro_rev_2016.profit);\n\n\nDataFrame(\n    Measure = [\"Consumer surplus\", \"Total welfare\"],\n    Nippyo_and_Brand_A = [CV_NippyoA, TS_change_NippyoA],\n    Nippyo_and_Brand_B = [CV_NippyoB, TS_change_NippyoB],\n)\n\n\n2×3 DataFrameRowMeasureNippyo_and_Brand_ANippyo_and_Brand_BStringFloat64Float641Consumer surplus-11740.6-4610.72Total welfare-10457.5-4060.65\n\n\n\nresult_df = DataFrame(\n    Maker = pro_rev_2016.Maker,\n    Profits_NippyoA = pro_rev_NippyoA.profit - pro_rev_2016.profit,\n    Revenue_NippyoA = pro_rev_NippyoA.revenue - pro_rev_2016.revenue,\n    Profits_NippyoB = pro_rev_NippyoB.profit - pro_rev_2016.profit,\n    Revenue_NippyoB = pro_rev_NippyoB.revenue - pro_rev_2016.revenue,\n);\n\ntotal_df = combine(result_df, 2:5 .=> sum .=> names(result_df)[2:5]);\ntotal_df[!, :Maker] .= \"Total\"\nappend!(result_df, total_df)\n\n\n16×5 DataFrameRowMakerProfits_NippyoARevenue_NippyoAProfits_NippyoBRevenue_NippyoBString15Float64Float64Float64Float641Audi11.714343.25634.8105118.59282BMW39.1788134.84616.362656.99623Daihatsu115.249224.04646.395988.99234Fiat1.62324.504660.671271.834755Lexas65.7824239.71724.6482108.3376Matsuda63.1001164.76725.972467.05487Mercedes57.4933211.16721.548395.63498Mitsubishi21.709454.60538.902622.19919Suzuki120.615231.99548.531192.183710Volkswagen20.605564.27288.6092526.612611Volvo9.6295935.02144.0138914.929912Nippyo83.8031-9633.8144.2023-3841.8413BrandA14.4172-10950.459.5346154.20114BrandB58.2013166.716-12.6581-5066.2415BrandC599.971536.03248.508629.816Total1283.09-17473.3550.053-7530.71"
  },
  {
    "objectID": "demand_estimation_merger.html#追加的なシミュレーション",
    "href": "demand_estimation_merger.html#追加的なシミュレーション",
    "title": "4  応用編",
    "section": "4.6 追加的なシミュレーション",
    "text": "4.6 追加的なシミュレーション\n\ncostReducingFirms = [\"Nippyo\", \"Brand_A\"];\ndistance = 100\nlambda = 1e-6;\nmax_cost_red = 1.0;\nmin_cost_red = 0.0;\n\niter = 1;\n\n\n@time while (distance > lambda) & (iter < 100)\n    \n    mid_cost_red = (max_cost_red + min_cost_red) / 2.0;\n    \n    mid_eval = calculateTSChangeByCostReduction(\n        mid_cost_red,\n        costReducingFirms,\n        Ownership_NippyoA,\n        data_2016,\n        mc,\n        datalist_2016,\n        beta_hat,\n        resultGMM.minimizer,\n        data_2016.HH,\n        p_NippyoA,\n        pro_rev_2016,\n        CS_2016,\n        Xi_2016\n    );\n    \n    if mid_eval > 0\n        min_cost_red = mid_cost_red;\n    else\n        max_cost_red = mid_cost_red;\n    end\n    \n    distance = abs(mid_eval - 0);\n    iter += 1\n    \nend\ncost_red_NippyoA = (min_cost_red + min_cost_red) / 2.0;\n\n\nmc_NippyoA_TSfix = mc[:];\nmc_NippyoA_TSfix[in(costReducingFirms).(data_2016.Maker)] .*= cost_red_NippyoA;\n\n\np_NippyoA_TSfix = calculateEquilibriumPrice(\n    datalist_2016, \n    p_NippyoA, \n    Ownership_NippyoA, \n    beta_hat, \n    resultGMM.minimizer, \n    mc_NippyoA_TSfix, \n    Xi_2016\n    );\nshare_NippyoA_TSfix = simulateMarketShare(\n    datalist_2016, \n    p_NippyoA_TSfix, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016\n    );\n\n\ncostReducingFirms = [\"Nippyo\", \"Brand_B\"];\ndistance = 100\nlambda = 1e-6;\nmax_cost_red = 1.0;\nmin_cost_red = 0.0;\n\niter = 1;\n\n\n@time while (distance > lambda) & (iter < 100)\n    \n    mid_cost_red = (max_cost_red + min_cost_red) / 2.0;\n    \n    mid_eval = calculateTSChangeByCostReduction(\n        mid_cost_red,\n        costReducingFirms,\n        Ownership_NippyoB,\n        data_2016,\n        mc,\n        datalist_2016,\n        beta_hat,\n        resultGMM.minimizer,\n        data_2016.HH,\n        p_NippyoB,\n        pro_rev_2016,\n        CS_2016,\n        Xi_2016\n    );\n    \n    if mid_eval > 0\n        min_cost_red = mid_cost_red;\n    else\n        max_cost_red = mid_cost_red;\n    end\n    \n    distance = abs(mid_eval - 0);\n    iter += 1\n    \nend\ncost_red_NippyoB = (min_cost_red + min_cost_red) / 2.0;\n\n\nmc_NippyoB_TSfix = mc[:];\nmc_NippyoB_TSfix[in(costReducingFirms).(data_2016.Maker)] .*= cost_red_NippyoB;\n\n\np_NippyoB_TSfix = calculateEquilibriumPrice(\n    datalist_2016, \n    p_NippyoB, \n    Ownership_NippyoB,\n    beta_hat, \n    resultGMM.minimizer, \n    mc_NippyoB_TSfix, \n    Xi_2016\n    );\nshare_NippyoB_TSfix = simulateMarketShare(\n    datalist_2016, \n    p_NippyoB_TSfix, \n    beta_hat, \n    resultGMM.minimizer, \n    Xi_2016\n    );\n\n\n[1-cost_red_NippyoA 1-cost_red_NippyoB] .* 100\n\n1×2 Matrix{Float64}:\n 1.46299  0.566009\n\n\n\n4.6.1 限界費用削減をしたときの利潤と収入の変化\n\npro_rev_NippyoA_rc = calculateProfit(\n    data_2016.Maker,\n    p_NippyoA_TSfix,\n    mc_NippyoA_TSfix,\n    share_NippyoA_TSfix,\n    data_2016.HH\n);\npro_rev_NippyoB_rc = calculateProfit(\n    data_2016.Maker,\n    p_NippyoB_TSfix,\n    mc_NippyoB_TSfix,\n    share_NippyoB_TSfix,\n    data_2016.HH\n);\n\nresult2_df = DataFrame(\n    Maker = pro_rev_2016.Maker,\n    Profits_NippyoA = pro_rev_NippyoA_rc.profit - pro_rev_2016.profit,\n    Revenue_NippyoA = pro_rev_NippyoA_rc.revenue - pro_rev_2016.revenue,\n    Profits_NippyoB = pro_rev_NippyoB_rc.profit - pro_rev_2016.profit,\n    Revenue_NippyoB = pro_rev_NippyoB_rc.revenue - pro_rev_2016.revenue,\n);\n\ntotal2_df = combine(result2_df, 2:5 .=> sum .=> names(result2_df)[2:5]);\ntotal2_df[!, :Maker] .= \"Total\";\nappend!(result2_df, total2_df)\n\n\n16×5 DataFrameRowMakerProfits_NippyoARevenue_NippyoAProfits_NippyoBRevenue_NippyoBString15Float64Float64Float64Float641Audi0.7932960.2017250.5825271.910462BMW1.30464-0.2816611.692094.626443Daihatsu-2.32447-5.485570.798129-0.04263124Fiat-0.0129613-0.0823010.03699780.05606395Lexas10.4044-3.421163.2379814.16556Matsuda-0.530124-2.951591.304372.01827Mercedes8.89116-3.778242.7548512.34068Mitsubishi-0.208908-0.9823140.4048970.6434769Suzuki-2.43621-5.654510.8084160.00030913910Volkswagen0.103842-0.7637240.6640131.3993211Volvo0.4624780.09815850.4639321.397112Nippyo10318.311771.13965.294405.3513BrandA-134.893-11555.43.094645.487114BrandB-0.0324358-2.34412-35.68-5169.2515BrandC1.32803-25.897616.480524.159116Total10201.1164.3873961.93-695.748\n\n\n\n@printf(\n    \"Percent change in profit by Brand A merger: %.3f \\n\", \n    (sum(pro_rev_NippyoA_rc.profit) - sum(pro_rev_2016.profit)) / sum(pro_rev_2016.profit) * 100.0\n    )\n@printf(\n    \"Percent change in revenue by brand A merger: %.3f \\n\", \n    (sum(pro_rev_NippyoA_rc.revenue) - sum(pro_rev_2016.revenue)) / sum(pro_rev_2016.revenue) * 100.0\n    )\n@printf(\n    \"Percent change in profit by Brand B merger: %.3f \\n\", \n    (sum(pro_rev_NippyoB_rc.profit) - sum(pro_rev_2016.profit)) / sum(pro_rev_2016.profit) * 100.0\n    )\n@printf(\n    \"Percent change in revenue by Brand B merger: %.3f \\n\", \n    (sum(pro_rev_NippyoB_rc.revenue) - sum(pro_rev_2016.revenue)) / sum(pro_rev_2016.revenue) * 100.0\n    )\n\nPercent change in profit by Brand A merger: 0.384 \nPercent change in revenue by brand A merger: 0.002 \nPercent change in profit by Brand B merger: 0.149 \nPercent change in revenue by Brand B merger: -0.009"
  },
  {
    "objectID": "entry_exit_application.html#推定結果",
    "href": "entry_exit_application.html#推定結果",
    "title": "6  応用編",
    "section": "6.4 推定結果",
    "text": "6.4 推定結果\n\n[minx std(bootEstMat, dims = 2)]\n\n14×2 Matrix{Float64}:\n -0.655829  0.103045\n -8.41047   3.51758\n -0.491684  0.158229\n -0.44966   0.203663\n -1.25152   0.20427\n -1.0654    0.104526\n -3.52228   0.473332\n -1.11907   1.23384\n  2.58767   0.0825597\n  0.033967  0.0142215\n  0.394342  0.0451492\n -1.44356   0.189356\n  1.08858   0.132724\n  0.963786  0.0157399\n\n\n\n6.4.1 モデルによる予測の確認\n\nberry_est = minx;\nalpha_est = berry_est[1:8];\nbeta_est = berry_est[9:12];\ndelta_est = berry_est[13];\nrho_est = berry_est[14];\n\nprofitExcludeCompetition = calculateProfitExcludeCompetition(\n    berry_est,\n    data_processed,\n    u_m0,\n    u_mIm\n);\n\neach_entry_mat = calculateEquilibriumNumEntry(\n    data_processed,\n    delta_est,\n    profitExcludeCompetition\n);\n\nentryProb = mean(simulateEntryByOrder(\n    delta_est,\n    cityIndex,\n    profitExcludeCompetition,\n    each_entry_mat\n), dims = 2)[:, 1];\n\n\nentryPred = entryProb .> 0.5;\n\ndata_predicted = copy(data_processed);\ndata_predicted[!, :entryProb] = entryProb;\ndata_predicted[!, :entryPred] = entryPred;\ndata_predicted_agg = combine(\n    groupby(data_predicted, :CityCode),\n    :MRIOwnDum => sum => :Actual,\n    :entryPred => sum => :Predict\n);\n\ndata_predicted_agg = stack(data_predicted_agg, [:Actual, :Predict]);\ndata_predicted_sum = combine(groupby(data_predicted_agg, [:variable, :value]), nrow);\nsort!(data_predicted_sum, [:variable, :value]);\ngroupedbar(\n    data_predicted_sum.nrow, \n    group = data_predicted_sum.variable,\n    xlabel = \"Number of hospitals in a city\", \n    ylabel = \"Number of cities\",\n    bar_width = 0.67,\n    xticks = (1:5, 0:4),\n    lw = 0\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata_predicted[!, :Top25pct_NumBeds] = (\n    data_processed.LogNumBeds .>= log(1.2)\n);\ndata_predicted[!, :NotNeuro] = (\n    (data_processed.DepNeurology .!= 1) .&\n    (data_processed.DepNeurosurgery .!= 1)\n);\nlistVarsShort = [\n    \"Kyukyu\", \"Sien\", \"Hyoka\", \"DepNeurology\",\n    \"DepNeurosurgery\", \"Top25pct_NumBeds\", \n    \"ZeroBedDum\", \"DaigakuDum\", \"NotNeuro\"\n]\n\ntableActPred = vcat([\n        sum.(\n            eachcol(data_predicted[\n                data_predicted[:, variable] .== 1, \n                [:MRIOwnDum, :entryPred]\n                ])\n        )'\n        for variable in listVarsShort\n    ]...);\n\ndfActPred = vcat(\n    DataFrame(\n        Actual = sum(data_predicted.MRIOwnDum),\n        Predict = sum(data_predicted.entryPred)\n    ),\n    DataFrame(\n        Actual = tableActPred[:, 1],\n        Predict = tableActPred[:, 2]\n    )\n);\n\ndfActPredStack = stack(dfActPred, [:Actual, :Predict]);\ndfActPredStack[:, :category] = repeat([\"All\"; listVarsShort], 2);\ngroupedbar(\n    dfActPredStack.category, \n    dfActPredStack.value,\n    group = dfActPredStack.variable,\n    xlabel = \"Number of hospitals in a city\", \n    ylabel = \"Number of cities\",\n    bar_width = 0.67,\n    lw = 0,\n    xrotation = 30\n)"
  }
]