---
title: "応用編"
format:
  html:
    toc: true
    html-math-method: katex
jupyter: julia-1.9
---

```{julia}
using CSV
using DataFrames
using StringEncodings
using Plots
using LinearAlgebra
using Statistics
using StatsBase
using Printf
using ForwardDiff
using Random
using NLopt
using StatsPlots
using CategoricalArrays
# using BenchmarkTools
```

```{julia}
for file in readdir("functions/entry_exit/")
    include("functions/entry_exit/" * file)
end
```

```{julia}
data_raw = data = CSV.File(
    open(read, "data/entry_exit_application/data_hospital_chapter6.csv", enc"UTF-8"),
    missingstring = ["NA", ""],
    ) |> DataFrame
first(data, 5)
```

```{julia}
data_cleaned = data_raw[:, :];
replace!(data_cleaned.Management, missing => "");
data_cleaned[!, :DaigakuDum] = in(["公立大学法人", "国（国立大学法人）", "私立学校法人"]).(data_cleaned.Management);
data_cleaned[!, :ZeroBedDum] = (data_cleaned[:, :NumBeds] .== 0);

data_cleaned[!, :NumBeds] = data_cleaned[:, :NumBeds] ./ 100.0;
data_cleaned[!, :LogNumBeds] = log.(data_cleaned[:, :NumBeds] .+ 0.01);
data_cleaned[!, :Population] = data_cleaned[:, :Population] ./ 1e+6;
data_cleaned[!, :Menseki] = data_cleaned[:, :Menseki] ./ 100.0;
data_cleaned[!, :TaxableIncome] = data_cleaned[:, :TaxableIncome] ./ 1000.0;
data_cleaned[!, :LogPop] = log.(data_cleaned[:, :Population]);
data_cleaned[!, :LogIncome] = log.(data_cleaned[:, :TaxableIncome]);
```

## 4

```{julia}
listVars = [
    "Kyukyu", "Kinou", "Sien", "Hyoka", "DepNeurology",
    "DepNeurosurgery", "NumBeds", "ZeroBedDum", "DaigakuDum"
]
table_mean = combine(
    groupby(data_cleaned, :MRIOwnDum),
    [Symbol(variable) for variable in listVars] .=> 
    x -> mean(skipmissing(x))
);
table_sd = combine(
    groupby(data_cleaned, :MRIOwnDum),
    [Symbol(variable) for variable in listVars] .=> 
    x -> std(skipmissing(x))
);

DataFrame(
    variable = listVars,
    meanOwnMRI = Matrix(table_mean)[2, 2:end],
    sdOwnMRI = Matrix(table_sd)[2, 2:end],
    meanNotOwnMRI_ = Matrix(table_mean)[1, 2:end],
    sdNotOwnMRI = Matrix(table_sd)[1, 2:end]
)

```

```{julia}
vcat(
    calculateShareOwnMRI(data_cleaned),
    calculateShareOwnMRI(dropmissing(data_cleaned, :Kyukyu)[dropmissing(data_cleaned, :Kyukyu).Kyukyu .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_cleaned, :Sien)[dropmissing(data_cleaned, :Sien).Sien .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_cleaned, :Hyoka)[dropmissing(data_cleaned, :Hyoka).Hyoka .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_cleaned, :DepNeurology)[dropmissing(data_cleaned, :DepNeurology).DepNeurology .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_cleaned, :DepNeurosurgery)[dropmissing(data_cleaned, :DepNeurosurgery).DepNeurosurgery .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_cleaned, :LogNumBeds)[dropmissing(data_cleaned, :LogNumBeds).LogNumBeds .>= log(1.2), :]),
    calculateShareOwnMRI(dropmissing(data_cleaned, :DaigakuDum)[dropmissing(data_cleaned, :DaigakuDum).DaigakuDum .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_cleaned, :ZeroBedDum)[dropmissing(data_cleaned, :ZeroBedDum).ZeroBedDum .== 1, :]),
)
```

## 5

```{julia}
data_processed_pre = dropmissing(data_cleaned[:, [
            :CityCode, :Kyukyu, :Kinou, :Sien, :Hyoka,
            :DepNeurology, :DepNeurosurgery, :LogNumBeds,
            :ZeroBedDum, :DaigakuDum,
            :Menseki, :LogPop, :LogIncome, :MRIOwnDum
            ]]);
first(data_processed_pre, 5)
```

```{julia}
function processDataForBerryEst(df)
    
    data_processed = df[:, :];
    data_processed[!, :TieEntryOrder] = rand(nrow(df));
    
    transform!(
        groupby(data_processed, :CityCode),
        nrow => :numPotenHos,
        :MRIOwnDum => sum => :numEntryObs
    );
    sort!(data_processed, [:CityCode, :LogNumBeds, :TieEntryOrder], rev = [false, true, true]);
    transform!(groupby(data_processed, :CityCode), :numPotenHos => (x -> 1:length(x)) => :EntryOrderId);
    
    return data_processed
        
end
```

```{julia}
Random.seed!(123)
data_processed = processDataForBerryEst(data_processed_pre);
first(data_processed, 5)
```

```{julia}
numPotenHos_max = 4;
data_processed = data_processed[data_processed.EntryOrderId .<= numPotenHos_max, :];
transform!(
    groupby(data_processed, :CityCode),
    :MRIOwnDum => sum => :numEntryObs,
    nrow => :numPotenHos
);
data_processed[!, :Const] .= 1;
vcat(
    calculateShareOwnMRI(data_processed),
    calculateShareOwnMRI(dropmissing(data_processed, :Kyukyu)[dropmissing(data_processed, :Kyukyu).Kyukyu .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_processed, :Sien)[dropmissing(data_processed, :Sien).Sien .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_processed, :Hyoka)[dropmissing(data_processed, :Hyoka).Hyoka .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_processed, :DepNeurology)[dropmissing(data_processed, :DepNeurology).DepNeurology .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_processed, :DepNeurosurgery)[dropmissing(data_processed, :DepNeurosurgery).DepNeurosurgery .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_processed, :LogNumBeds)[dropmissing(data_processed, :LogNumBeds).LogNumBeds .>= log(1.2), :]),
    calculateShareOwnMRI(dropmissing(data_processed, :DaigakuDum)[dropmissing(data_processed, :DaigakuDum).DaigakuDum .== 1, :]),
    calculateShareOwnMRI(dropmissing(data_processed, :ZeroBedDum)[dropmissing(data_processed, :ZeroBedDum).ZeroBedDum .== 1, :]),
)

```

```{julia}
numSim = 100;

uniqueCityCode = unique(data_processed.CityCode);
numCity = length(uniqueCityCode);
numHos = nrow(data_processed);
numEntryObs = combine(
    groupby(data_processed, :CityCode),
    :MRIOwnDum => sum => :numEntryObs
).numEntryObs;
NumPotenHos_vec = combine(
    groupby(data_processed, :CityCode),
    nrow => :numPotenHos
).numPotenHos;

cityIndex = data_processed.CityCode .== uniqueCityCode';
```

```{julia}
u_m0 = cityIndex * randn(numCity, numSim);
u_mIm = randn(numHos, numSim);
```

```{julia}

param_init = [
    -0.612340533,   -5.525423772,   -0.505275676,   
    -0.32531026,    -1.04162392,    -0.991878025,   
    -3.87040966,    -1.272714254,   2.684741676,    
    0.040555764,    0.426448612,    -1.399627382,   
    0.990975782,    0.958075433
];

```

```{julia}

@time profitExcludeCompetition = calculateProfitExcludeCompetition(
    param_init,
    data_processed,
    u_m0,
    u_mIm

)

@time each_entry_mat = calculateEquilibriumNumEntry(
    data_processed,
    param_init[13],
    profitExcludeCompetition
);
```

```{julia}

@time entryMat = simulateEntryByOrder(
    param_init[13],
    cityIndex,
    profitExcludeCompetition,
    each_entry_mat
);
mean(entryMat, dims = 2)

```

```{julia}

function calculateBerryObjectiveAtHospitalLevel(
        param,
        df::DataFrame,
        u_m0::Matrix{Float64},
        u_mIm::Matrix{Float64},
        cityIndex::BitMatrix,
        simulateEntry
    )

    profitExcludeCompetition = calculateProfitExcludeCompetition(
        param,
        df,
        u_m0,
        u_mIm

    )

    each_entry_mat = calculateEquilibriumNumEntry(
        df,
        param[13],
        profitExcludeCompetition
    );

    entryMat = simulateEntry(
        param[13],
        cityIndex,
        profitExcludeCompetition,
        each_entry_mat
    )

    return mean((df.MRIOwnDum .- mean(entryMat, dims = 2)).^2);

end
```

```{julia}
@time calculateBerryObjectiveAtHospitalLevel(param_init, data_processed, u_m0, u_mIm, cityIndex, simulateEntryByOrder);
```

```{julia}
#| echo: false
#| eval: false

# obj_for_Optim = TwiceDifferentiable(
#     x -> calculateBerryObjective(x, data_processed, u_m0, u_mIm, numEntryObs),
#     param_init;
#     autodiff = :forward
# );
# @time optim_res = Optim.optimize(
#     obj_for_Optim,
#     # x -> calculateBerryObjective(x, data_processed, u_m0, u_mIm, numEntryObs),
#     [repeat([-Inf], 13); -1.0],
#     [repeat([Inf], 13); 1.0],
#     param_init,
#     # NelderMead(),
#     Optim.Options(show_trace = false)
# );

# [param_init optim_res.minimizer]

```

```{julia}
# @benchmark calculateBerryObjective(param_init, data_processed, u_m0, u_mIm, numEntryObs)
function obj_for_Optim(x::Vector, grad::Vector)
    if length(grad) != 0
        ForwardDiff.gradient!(
            grad, 
            x -> calculateBerryObjectiveAtHospitalLevel(x, data_processed, u_m0, u_mIm, cityIndex, simulateEntryByOrder), 
            x
            )
    end
    return calculateBerryObjectiveAtHospitalLevel(x, data_processed, u_m0, u_mIm, cityIndex, simulateEntryByOrder)
end

opt = NLopt.Opt(:LN_NELDERMEAD, length(param_init))
opt.lower_bounds = [repeat([-Inf], 13); -1.0]
opt.upper_bounds = [repeat([Inf], 13); 1.0]

opt.min_objective = obj_for_Optim;
@time (minf, minx, ret) = NLopt.optimize(opt, param_init)

[param_init minx]
```

```{julia}

numBootstrap = 100;
bootEstMat = zeros(length(minx), numBootstrap)

@time for bootIndex in 1:numBootstrap

    bootCitySample = sample(uniqueCityCode, numCity, replace = true);
    df_boot = reduce(
        vcat,
        [
            transform(
                data_processed[data_processed.CityCode .== bootCitySample[city] , :],
                :CityCode => (x -> city) => :CityCode
            )
            for city in 1:numCity
        ]
    );

    numHos_boot = nrow(df_boot);

    uniqueCityCode_boot = unique(df_boot.CityCode);
    cityIndex_boot = df_boot.CityCode .== uniqueCityCode_boot';

    u_m0_boot = cityIndex_boot * randn(numCity, numSim);
    u_mIm_boot = randn(numHos_boot, numSim);

    function obj_for_Optim(x::Vector, grad::Vector)
        if length(grad) != 0
            ForwardDiff.gradient!(
                grad, 
                x -> calculateBerryObjectiveAtHospitalLevel(x, df_boot, u_m0_boot, u_mIm_boot, cityIndex_boot, simulateEntryByOrder), 
                x
                )
        end
        return calculateBerryObjectiveAtHospitalLevel(x, df_boot, u_m0_boot, u_mIm_boot, cityIndex_boot, simulateEntryByOrder)
    end

    opt_boot = NLopt.Opt(:LN_NELDERMEAD, length(param_init))
    opt_boot.lower_bounds = [repeat([-Inf], 13); -1.0]
    opt_boot.upper_bounds = [repeat([Inf], 13); 1.0]

    opt_boot.min_objective = obj_for_Optim;
    (minf_boot, minx_boot, ret_boot) = NLopt.optimize(opt_boot, param_init)
    bootEstMat[:, bootIndex] .= minx_boot;

end

```

```{julia}
[minx std(bootEstMat, dims = 2)]
```

## 6.2

```{julia}

berry_est = minx;
alpha_est = berry_est[1:8];
beta_est = berry_est[9:12];
delta_est = berry_est[13];
rho_est = berry_est[14];

profitExcludeCompetition = calculateProfitExcludeCompetition(
    berry_est,
    data_processed,
    u_m0,
    u_mIm
);

each_entry_mat = calculateEquilibriumNumEntry(
    data_processed,
    delta_est,
    profitExcludeCompetition
);

entryProb = mean(simulateEntryByOrder(
    delta_est,
    cityIndex,
    profitExcludeCompetition,
    each_entry_mat
), dims = 2)[:, 1];
```

```{julia}
entryPred = entryProb .> 0.5;

data_predicted = copy(data_processed);
data_predicted[!, :entryProb] = entryProb;
data_predicted[!, :entryPred] = entryPred;
data_predicted_agg = combine(
    groupby(data_predicted, :CityCode),
    :MRIOwnDum => sum => :Actual,
    :entryPred => sum => :Predict
);

data_predicted_agg = stack(data_predicted_agg, [:Actual, :Predict]);
data_predicted_sum = combine(groupby(data_predicted_agg, [:variable, :value]), nrow);
sort!(data_predicted_sum, [:variable, :value]);
groupedbar(
    data_predicted_sum.nrow, 
    group = data_predicted_sum.variable,
    xlabel = "value", 
    ylabel = "count",
    bar_width = 0.67,
    xticks = (1:5, 0:4),
    lw = 0
)
```

```{julia}
data_predicted[!, :Top25pct_NumBeds] = data_processed.LogNumBeds .>= log(1.2);
listVarsShort = [
    "Kyukyu", "Sien", "Hyoka", "DepNeurology",
    "DepNeurosurgery", "Top25pct_NumBeds", "ZeroBedDum", "DaigakuDum"
]

tableActPred = vcat([
        sum.(
            eachcol(data_predicted[
                data_predicted[:, variable] .== 1, 
                [:MRIOwnDum, :entryPred]
                ])
        )'
        for variable in listVarsShort
    ]...);

dfActPred = vcat(
    DataFrame(
        Actual = sum(data_predicted.MRIOwnDum),
        Predict = sum(data_predicted.entryPred)
    ),
    DataFrame(
        Actual = tableActPred[:, 1],
        Predict = tableActPred[:, 2]
    )
);

dfActPredStack = stack(dfActPred, [:Actual, :Predict]);
dfActPredStack[:, :category] = repeat(["All"; listVarsShort], 2);
groupedbar(
    dfActPredStack.category, 
    dfActPredStack.value,
    group = dfActPredStack.variable,
    xlabel = "value", 
    ylabel = "count",
    bar_width = 0.67,
    lw = 0,
    xrotation = 30
)
```

## 7

```{julia}
data_cf = copy(data_processed);
sort!(data_cf, [:CityCode, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :TieEntryOrder], rev = [false, true, true, true, true]);
transform!(groupby(data_cf, :CityCode), :numPotenHos => (x -> 1:length(x)) => :EntryOrderId);
var_profit_cf = Matrix(data_cf[:, [:Const, :Menseki, :LogPop, :LogIncome]]) * beta_est .+ 
    rho_est .* u_m0;
fixedCost_cf = Matrix(data_cf[:, [:Kyukyu, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :LogNumBeds, :ZeroBedDum, :DaigakuDum]]) * alpha_est .-
    (sqrt.(1.0 - rho_est^2) .* u_mIm);

profitExcludeCompetition_cf = var_profit_cf - fixedCost_cf;
profitExcludeCompetition_cf[(data_cf.DepNeurology .== 1) .| (data_cf.DepNeurosurgery .== 1), :] .= 1e+5;
```

```{julia}
EntryProb_cf = map(
    i -> simulateEntry(data_cf[data_cf.CityCode .== i, :], delta_est, profitExcludeCompetition_cf[data_cf.CityCode .== i, :]), 
    uniqueCityCode
);
```

```{julia}
EntryPred_cf = reduce(vcat, EntryProb_cf) .> 0.5;
data_predicted_cf = copy(data_processed);
data_predicted_cf[!, :entryProb] = reduce(vcat, EntryProb_cf);
data_predicted_cf[!, :entryPred] = EntryPred_cf;
data_predicted_cf_agg = combine(
    groupby(data_predicted_cf, :CityCode),
    :MRIOwnDum => sum => :Actual,
    :entryPred => sum => :CounterFactual
);

data_predicted_cf_agg = stack(data_predicted_cf_agg, [:Actual, :CounterFactual]);
data_predicted_cf_sum = combine(groupby(
    vcat(data_predicted_agg, data_predicted_cf_agg[data_predicted_cf_agg.variable .== "CounterFactual", :]),
    [:variable, :value]
    ), nrow);

transform!(
    data_predicted_cf_sum, 
    :variable => 
    (x -> categorical(x; ordered = true, levels = ["Actual", "Predict", "CounterFactual"])) => 
    :variable
    )
sort!(data_predicted_cf_sum, [:variable, :value]);
groupedbar(
    data_predicted_cf_sum.nrow, 
    group = data_predicted_cf_sum.variable,
    xlabel = "value", 
    ylabel = "count",
    bar_width = 0.67,
    xticks = (1:5, 0:4),
    lw = 0
)
```

```{julia}
vcat(
    combine(groupby(
        data_predicted_agg, :variable
        ), :value => sum),
    combine(groupby(
        data_predicted_cf_agg, :variable
        ), :value => sum) |> 
        filter(:variable => (x -> x .== "CounterFactual"))
)
```

```{julia}
data_predicted_agg_wo_neuro = combine(
    groupby(
        filter([:DepNeurology, :DepNeurosurgery] => ((d1, d2) -> (d1 .== 1) .& (d2 .== 1)), data_predicted),
        :CityCode
        ),
    :MRIOwnDum => sum => :Actual,
    :entryPred => sum => :Predict
);

data_predicted_agg_wo_neuro = stack(data_predicted_agg_wo_neuro, [:Actual, :Predict]);
data_predicted_sum_wo_neuro = combine(groupby(data_predicted_agg_wo_neuro, [:variable, :value]), nrow);

data_predicted_cf_agg_wo_neuro = combine(
    groupby(
        # data_predicted_cf, 
        filter([:DepNeurology, :DepNeurosurgery] => ((d1, d2) -> (d1 .== 1) .& (d2 .== 1)), data_predicted_cf),
        :CityCode
        ),
    :MRIOwnDum => sum => :Actual,
    :entryPred => sum => :CounterFactual
);

data_predicted_cf_agg_wo_neuro = stack(data_predicted_cf_agg_wo_neuro, [:Actual, :CounterFactual]);

data_predicted_cf_sum_wo_neuro = combine(groupby(
    vcat(
        data_predicted_agg_wo_neuro, 
        data_predicted_cf_agg_wo_neuro[data_predicted_cf_agg_wo_neuro.variable .== "CounterFactual", :]
        ),
    [:variable, :value]
    ), nrow)

transform!(
    data_predicted_cf_sum_wo_neuro, 
    :variable => 
    (x -> categorical(x; ordered = true, levels = ["Actual", "Predict", "CounterFactual"])) => 
    :variable
    )
sort!(data_predicted_cf_sum_wo_neuro, [:variable, :value]);
groupedbar(
    data_predicted_cf_sum_wo_neuro.nrow, 
    group = data_predicted_cf_sum_wo_neuro.variable,
    xlabel = "value", 
    ylabel = "count",
    bar_width = 0.67,
    xticks = (1:5, 0:4),
    lw = 0
)
```

```{julia}
vcat(
    combine(groupby(
        data_predicted_agg_wo_neuro, :variable
        ), :value => sum),
    combine(groupby(
        data_predicted_cf_agg_wo_neuro, :variable
        ), :value => sum) |> 
        filter(:variable => (x -> x .== "CounterFactual"))
)
```

```{julia}
#| echo: false
#| eval: false

# EntryPred_cf = reduce(vcat, EntryProb_cf) .> 0.5;
# data_cf[!, :entryProb] = reduce(vcat, EntryProb_cf);
# data_cf[!, :entryPred] = EntryPred_cf;
# var_list = [:Kyukyu, :Sien, :Hyoka, :DepNeurology, :DepNeurosurgery, :DaigakuDum, :ZeroBedDum]
# actual_pred_MRI_cf = map(x -> combine(data_cf[data_cf[:, x] .== 1, [:MRIOwnDum, :entryPred]], All() .=> sum), var_list);
# actual_pred_MRI_cf = vcat(
#     combine(data_cf[:, [:MRIOwnDum, :entryPred]], All() .=> sum),
#     reduce(vcat, actual_pred_MRI_cf),
#     combine(data_cf[data_cf[:, :LogNumBeds] .>= log(1.2), [:MRIOwnDum, :entryPred]], All() .=> sum),
#     combine(data_cf[(data_cf[:, :DepNeurology] .== 0) .& (data_cf[:, :DepNeurosurgery] .== 0), [:MRIOwnDum, :entryPred]], All() .=> sum)
# )

# [actual_pred_MRI.EntryPred_sum actual_pred_MRI_cf.EntryPred_sum]
```

