---
title: "推定 1"
format:
  html:
    toc: true
    html-math-method: katex
jupyter: julia-1.9
---

```{julia}
using CSV, Tables
using DataFrames
using Random
using Distributions
using JLD2
using Statistics
using StatsBase
using LinearAlgebra
using Optim
```



```{julia}

beta = 0.8;
eulergamma = Float64(MathConstants.eulergamma);
TransitionMat = [0.7 0.3; 0.4 0.6]

NumSimMarkets = 500;
NumSimPeriods = 50;

Random.seed!(123);

```

```{julia}

Parameters = [
    0.3,
    0.2,
    -0.27,
    0.45,
    -0.15,
    -2.10
];

TrueParameterValues = [
    0.3,
    -0.27,
    0.45,
    -0.15,
    -2.10,
    0.2,
    -0.27,
    0.45,
    -0.15,
    -2.10
];

```


```{julia}

@load "tmp/dynamic_game/data_workspace.jld2";

```

```{julia}
#| code-fold: true
#| code-summary: "Functions defined previously"

function pi1gen(theta)

    base = [
        0,
        0,
        theta[1] + theta[3],
        theta[1] + theta[2] + theta[3],
        0,
        0,
        theta[1],
        theta[1] + theta[2]
    ];

    invdiv = [theta[4], 0, theta[5]];

    base = reshape(repeat(base, 3), (8, :));
    invdiv = reshape(repeat(invdiv, 8), (:, 8))';
    return base + invdiv;
end;

function pi2gen(theta)

    base = [
        0,
        theta[6] + theta[8],
        0,
        theta[6] + theta[7] + theta[8],
        0,
        theta[6],
        0,
        theta[6] + theta[7]
    ];

    invdiv = [theta[9], 0, theta[10]];

    base = reshape(repeat(base, 3), (8, :));
    invdiv = reshape(repeat(invdiv, 8), (:, 8))';
    return base + invdiv;
end;

function CCP1Transform(x)

    return [
        0 x[1] 1-x[1];
        0 x[2] 1-x[2];
        1-x[3] x[3] 0;
        1-x[4] x[4] 0;
        0 x[5] 1-x[5];
        0 x[6] 1-x[6];
        1-x[7] x[7] 0;
        1-x[8] x[8] 0;
    ]

end;

function CCP2Transform(x)

    return [
        0 x[1] 1-x[1];
        1-x[2] x[2] 0;
        0 x[3] 1-x[3];
        1-x[4] x[4] 0;
        0 x[5] 1-x[5];
        1-x[6] x[6] 0;
        0 x[7] 1-x[7];
        1-x[8] x[8] 0;
    ]

end;

function fP(Matrix1, Vec1, Vec2)

    TempMat0 = kron(Matrix1, ones(4, 4));

    TempMat1 = [
        Vec1[1] 1-Vec1[1];
        Vec1[2] 1-Vec1[2];
        1-Vec1[3] Vec1[3];
        1-Vec1[4] Vec1[4];
        Vec1[5] 1-Vec1[5];
        Vec1[6] 1-Vec1[6];
        1-Vec1[7] Vec1[7];
        1-Vec1[8] Vec1[8];
    ];
    TempMat1 = kron(TempMat1, [1 1]);
    TempMat1 = hcat(TempMat1, TempMat1);

    TempMat2 = [
        Vec2[1] 1-Vec2[1];
        1-Vec2[2] Vec2[2];
        Vec2[3] 1-Vec2[3];
        1-Vec2[4] Vec2[4];
        Vec2[5] 1-Vec2[5];
        1-Vec2[6] Vec2[6];
        Vec2[7] 1-Vec2[7];
        1-Vec2[8] Vec2[8];
    ];
    TempMat2 = kron(ones(1, 4), TempMat2);

    return TempMat0 .* TempMat1 .* TempMat2;

end;

function pi1PsigmaGen(pi1, Mat2)

    pi1_dec = pi1[:, 1];
    pi1_0 = pi1[:, 2];
    pi1_inc = pi1[:, 3];

    pi1_dec = (pi1_dec .* Mat2) * ones(3);
    pi1_0 = (pi1_0 .* Mat2) * ones(3);
    pi1_inc = (pi1_inc .* Mat2) * ones(3);

    return hcat(
        pi1_dec, pi1_0, pi1_inc
    )

end

function pi2PsigmaGen(pi2, Mat1)

    pi2_dec = pi2[:, 1];
    pi2_0 = pi2[:, 2];
    pi2_inc = pi2[:, 3];

    pi2_dec = (pi2_dec .* Mat1) * ones(3);
    pi2_0 = (pi2_0 .* Mat1) * ones(3);
    pi2_inc = (pi2_inc .* Mat1) * ones(3);

    return hcat(
        pi2_dec, pi2_0, pi2_inc
    )

end

function CCP1LogTransform(x)

    return [
        0 log(x[1]) log(1 - x[1]);
        0 log(x[2]) log(1 - x[2]);
        log(1 - x[3]) log(x[3]) 0;
        log(1 - x[4]) log(x[4]) 0;
        0 log(x[5]) log(1 - x[5]);
        0 log(x[6]) log(1 - x[6]);
        log(1 - x[7]) log(x[7]) 0;
        log(1 - x[8]) log(x[8]) 0;
    ]

end

function CCP2LogTransform(x)

    return [
        0 log(x[1]) log(1 - x[1]);
        log(1 - x[2]) log(x[2]) 0;
        0 log(x[3]) log(1 - x[3]);
        log(1 - x[4]) log(x[4]) 0;
        0 log(x[5]) log(1 - x[5]);
        log(1 - x[6]) log(x[6]) 0;
        0 log(x[7]) log(1 - x[7]);
        log(1 - x[8]) log(x[8]) 0;
    ]

end

function fP_a1given(Matrix1, Vec2)

    TempMat0 = kron(Matrix1, ones(4, 4));

    TempMat2 = [
        Vec2[1] 1-Vec2[1] Vec2[1] 1-Vec2[1];
        1-Vec2[2] Vec2[2] 1-Vec2[2] Vec2[2];
        Vec2[3] 1-Vec2[3] Vec2[3] 1-Vec2[3];
        1-Vec2[4] Vec2[4] 1-Vec2[4] Vec2[4];
        Vec2[5] 1-Vec2[5] Vec2[5] 1-Vec2[5];
        1-Vec2[6] Vec2[6] 1-Vec2[6] Vec2[6];
        Vec2[7] 1-Vec2[7] Vec2[7] 1-Vec2[7];
        1-Vec2[8] Vec2[8] 1-Vec2[8] Vec2[8];
    ];
    TempMat2 = hcat(TempMat2, TempMat2);

    MatAdjustMinus1 = repeat(vcat(
        zeros(2, 8), ones(2, 8)
    ), 2);
    MatAdjustMinus2 = repeat(vcat(
        ones(2, 8), zeros(2, 8)
    ), 2)';
    output1 = TempMat0 .* TempMat2 .* MatAdjustMinus1 .* MatAdjustMinus2;


    ForZero = diagm(ones(2));
    MatAdjustZero = kron(ForZero, ones(2, 2));
    MatAdjustZero = hcat(MatAdjustZero, MatAdjustZero);
    MatAdjustZero = vcat(MatAdjustZero, MatAdjustZero);
    output2 = TempMat0 .* TempMat2 .* MatAdjustZero;


    MatAdjustPlus1 = repeat(vcat(
        ones(2, 8), zeros(2, 8)
    ), 2);
    MatAdjustPlus2 = repeat(vcat(
        zeros(2, 8), ones(2, 8)
    ), 2)';
    output3 = TempMat0 .* TempMat2 .* MatAdjustPlus1 .* MatAdjustPlus2;

    return [output1, output2, output3]
end

function fP_a2given(Matrix1, Vec1)

    TempMat0 = kron(Matrix1, ones(4, 4));

    TempMat1 = [
        Vec1[1] Vec1[1] 1-Vec1[1] 1-Vec1[1];
        Vec1[2] Vec1[2] 1-Vec1[2] 1-Vec1[2];
        1-Vec1[3] 1-Vec1[3] Vec1[3] Vec1[3];
        1-Vec1[4] 1-Vec1[4] Vec1[4] Vec1[4];
        Vec1[5] Vec1[5] 1-Vec1[5] 1-Vec1[5];
        Vec1[6] Vec1[6] 1-Vec1[6] 1-Vec1[6];
        1-Vec1[7] 1-Vec1[7] Vec1[7] Vec1[7];
        1-Vec1[8] 1-Vec1[8] Vec1[8] Vec1[8];
    ];
    TempMat1 = kron(ones(1, 2), TempMat1);

    MatAdjustMinus1 = repeat(vcat(zeros(1, 8), ones(1, 8)), 4);
    MatAdjustMinus2 = repeat(vcat(ones(1, 8), zeros(1, 8)), 4)';
    output1 = TempMat0 .* TempMat1 .* MatAdjustMinus1 .* MatAdjustMinus2;


    MatAdjustZero = repeat(vcat(
        repeat([1, 0], 4)',
        repeat([0, 1], 4)',
    ), 4);
    output2 = TempMat0 .* TempMat1 .* MatAdjustZero;


    MatAdjustPlus1 = repeat(vcat(ones(1, 8), zeros(1, 8)), 4);
    MatAdjustPlus2 = repeat(vcat(zeros(1, 8), ones(1, 8)), 4)';
    output3 = TempMat0 .* TempMat1 .* MatAdjustPlus1 .* MatAdjustPlus2;

    return [output1, output2, output3]
end


```

```{julia}

EstimatedCCP1 = zeros(8, 1);
EstimatedCCP2 = zeros(8, 1);

for s in 1:8
    SubData = FakeData[FakeData[:, 3] .== s, :];
    EstimatedCCP1[s] = mean(SubData[:, 7] .== 0);
    EstimatedCCP2[s] = mean(SubData[:, 8] .== 0);
end

```

```{julia}

EstimatedTransition = zeros(2, 2);

SubData = hcat(FakeData, [[0]; FakeData[1:(end - 1), 4]]);
SubData = SubData[SubData[:, 2] .!= 1, :];

for z in 1:2
    SubDataZ = SubData[SubData[:, 4] .== z, :];
    EstimatedTransition[z, z] = mean(SubDataZ[:, 9] .== z);
    EstimatedTransition[z, 3 - z] = 1 - EstimatedTransition[z, z];
end

```

```{julia}
hcat(EstimatedCCP1, EstimatedCCP2)
```

```{julia}
EstimatedTransition
```

## Step 2

```{julia}
#| code-fold: true
#| code-summary: "CCP to Value to Prediction"

function CCP_to_Value_to_prediction(
    theta,
    CCP1,
    CCP2,
    TransitionMat,
    beta
)

    CCP1Adjuster = [
        0 1 1;
        0 1 1;
        1 1 0;
        1 1 0
    ];
    CCP1Adjuster = repeat(CCP1Adjuster, 2);

    CCP2Adjuster = [
        0 1 1;
        1 1 0;
        0 1 1;
        1 1 0
    ];
    CCP2Adjuster = repeat(CCP2Adjuster, 2);

    pi1 = pi1gen(theta) .* CCP1Adjuster;
    pi2 = pi2gen(theta) .* CCP2Adjuster;

    CCP1Mat = CCP1Transform(CCP1);
    CCP2Mat = CCP2Transform(CCP2);

    fPsigma = fP(TransitionMat, CCP1, CCP2);

    pi1Psigma = pi1PsigmaGen(pi1, CCP2Mat);
    pi2Psigma = pi2PsigmaGen(pi2, CCP1Mat);

    eP1 = eulergamma .- CCP1LogTransform(CCP1);
    eP2 = eulergamma .- CCP2LogTransform(CCP2);

    ExanteV1 = (
        (diagm(ones(8)) - beta .* fPsigma) \ 
        ((CCP1Mat .* (pi1Psigma + eP1)) * ones(3))
    );

    ExanteV2 = (
        (diagm(ones(8)) - beta .* fPsigma) \ 
        ((CCP2Mat .* (pi2Psigma + eP2)) * ones(3))
    );

    fP_a1 = fP_a1given(TransitionMat, CCP2);
    fP_a2 = fP_a2given(TransitionMat, CCP1);

    NewSigmaSeed1 = (
        pi1Psigma + beta .* hcat(fP_a1[1] * ExanteV1, fP_a1[2] * ExanteV1, fP_a1[3] * ExanteV1) .* CCP1Adjuster
    );
    NewSigmaDeno1 = (
        sum(exp.(NewSigmaSeed1), dims = 2) .- 1
    );
    NewSigma1 = exp.(NewSigmaSeed1) ./ NewSigmaDeno1;
    CCP1UpdatedMat = NewSigma1 .* CCP1Adjuster;
    CCP1Updated = CCP1UpdatedMat[:, 2];

    NewSigmaSeed2 = (
        pi2Psigma + beta .* hcat(fP_a2[1] * ExanteV2, fP_a2[2] * ExanteV2, fP_a2[3] * ExanteV2) .* CCP2Adjuster
    );
    NewSigmaDeno2 = (
        sum(exp.(NewSigmaSeed2), dims = 2) .- 1
    );
    NewSigma2 = exp.(NewSigmaSeed2) ./ NewSigmaDeno2;
    CCP2UpdatedMat = NewSigma2 .* CCP2Adjuster;
    CCP2Updated = CCP2UpdatedMat[:, 2];

    return hcat(CCP1Updated, CCP2Updated)

end

```

```{julia}

output = CCP_to_Value_to_prediction(
    TrueParameterValues,
    CCP1UpdatedMat[:, 2],
    CCP2UpdatedMat[:, 2],
    TransitionMat,
    beta
);

println("Difference between CCP in GDP and predicted CCP")
output - hcat(CCP1UpdatedMat[:, 2], CCP2UpdatedMat[:, 2])

```

```{julia}

Normalized_TrueParam = [
    Parameters[1] - ((1 - beta) / beta) * Parameters[5],
    Parameters[3],
    Parameters[4],
    0,
    Parameters[6] + Parameters[5],
    Parameters[2] - ((1 - beta) / beta) * Parameters[5],
    Parameters[3],
    Parameters[4],
    0,
    Parameters[6] + Parameters[5],
]

output_noramlized = CCP_to_Value_to_prediction(
    Normalized_TrueParam,
    CCP1UpdatedMat[:, 2],
    CCP2UpdatedMat[:, 2],
    TransitionMat,
    beta
)

println("Difference: predicted CCP in true parameter and normalized parameter")
output_noramlized - output

```


```{julia}
#| code-fold: true
#| code-summary: "Objective function"

function obj_fun(
    param,
    EstimatedCCP1,
    EstimatedCCP2,
    TransitionProb,
    beta
)

    output = CCP_to_Value_to_prediction(
        param, EstimatedCCP1, EstimatedCCP2, TransitionProb, beta
    );

    return sum((output[:, 1] - EstimatedCCP1).^2) + sum((output[:, 2] - EstimatedCCP2).^2)

end;

```

```{julia}

initial = [Parameters[1:4]; Parameters[6]];
mat_initial2 = initial .* reshape(rand(Uniform(0.6, 1.2), 50), (5, :));
result = zeros(6, 10);

for i in 1:10
    sol = optimize(
        x -> obj_fun(
            [x[1]; x[3:4]; [0]; x[5]; x[2]; x[3:4]; [0]; x[5]], 
            EstimatedCCP1, EstimatedCCP2, EstimatedTransition, beta
            ),
        mat_initial2[:, i],
        Optim.Options(show_trace = false)
    );
    result[:, i] = [sol.minimizer; sol.minimum];
end

result_pick = result[1:5, argmin(result[6, :])];

```

```{julia}

normalized_trueparam = [
    Normalized_TrueParam[1],
    Normalized_TrueParam[6],
    Normalized_TrueParam[2],
    Normalized_TrueParam[3],
    Normalized_TrueParam[5],
];

DataFrame(
    param_est = result_pick,
    normalized_trueparam = normalized_trueparam
)

```


```{julia}

numBootSample = 100;

bootindex = reshape(
    sample(1:NumSimMarkets, NumSimMarkets * numBootSample),
    (NumSimMarkets, numBootSample)
);

```

```{julia}

bootresult_transition = zeros(2, numBootSample);
bootresult_CCP1 = zeros(8, numBootSample);
bootresult_CCP2 = zeros(8, numBootSample);
bootresult_payoff = zeros(5, numBootSample);

```

```{julia}
#| code-fold: true
#| code-summary: "Bootstrap"

function Estimation_PS_bootstrap(
    FakeData,
    beta
)

    EstimatedCCP1 = zeros(8, 1);
    EstimatedCCP2 = zeros(8, 1);

    for s in 1:8
        SubData = FakeData[FakeData[:, 3] .== s, :];
        EstimatedCCP1[s] = mean(SubData[:, 7] .== 0);
        EstimatedCCP2[s] = mean(SubData[:, 8] .== 0);
    end

    EstimatedTransition = zeros(2, 2);

    SubData = hcat(FakeData, [[0]; FakeData[1:(end - 1), 4]]);
    SubData = SubData[SubData[:, 2] .!= 1, :];

    for z in 1:2
        SubDataZ = SubData[SubData[:, 4] .== z, :];
        EstimatedTransition[z, z] = mean(SubDataZ[:, 9] .== z);
        EstimatedTransition[z, 3 - z] = 1 - EstimatedTransition[z, z];
    end

    SubData = hcat(FakeData, [[0]; FakeData[1:(end - 1), 4]]);
    SubData = SubData[SubData[:, 2] .!= 1, :];

    for z in 1:2
        SubDataZ = SubData[SubData[:, 4] .== z, :];
        EstimatedTransition[z, z] = mean(SubDataZ[:, 9] .== z);
        EstimatedTransition[z, 3 - z] = 1 - EstimatedTransition[z, z];
    end

    result = optimize(
        x -> obj_fun(
            [x[1]; x[3:4]; [0]; x[5]; x[2]; x[3:4]; [0]; x[5]], 
            EstimatedCCP1, EstimatedCCP2, EstimatedTransition, beta
            ),
        [0.3, 0.2, -0.27, 0.45, -2.1],
        Optim.Options(show_trace = false)
    );

    return [
        hcat(EstimatedCCP1, EstimatedCCP2),
        EstimatedTransition,
        result.minimizer,
        result.minimum
    ]

end

```

```{julia}

@time for b in 1:numBootSample
    bootsample = zeros(NumSimPeriods * NumSimMarkets, 8);
    for m in 1:NumSimMarkets
        temp = FakeData[FakeData[:, 1] .== bootindex[m, b], :];
        bootsample[(1 + NumSimPeriods * (m - 1)):(NumSimPeriods * m), :] = temp;
    end

    output = Estimation_PS_bootstrap(bootsample, beta);

    bootresult_CCP1[:, b] = output[1][:, 1];
    bootresult_CCP2[:, b] = output[1][:, 2];
    bootresult_transition[:, b] = diag(output[2]);
    bootresult_payoff[:, b] = output[3];
end

```

```{julia}
println("CCP for firm 1")
DataFrame(
    "True values" => CCP1UpdatedMat[:, 2],
    "Estimated" => vec(EstimatedCCP1),
    "SE" => vec(std(bootresult_CCP1, dims=2))
)
```

```{julia}
println("CCP for firm 2")
DataFrame(
    "True values" => CCP2UpdatedMat[:, 2],
    "Estimated" => vec(EstimatedCCP2),
    "SE" => vec(std(bootresult_CCP2, dims=2))
)
```

```{julia}

println("Transition Probability (GG and BB)")
DataFrame(
    "True values" => diag(TransitionMat),
    "Estimated" => diag(EstimatedTransition),
    "SE" => vec(std(bootresult_transition, dims=2))
)

```

```{julia}

DataFrame(
    "True values" => initial,
    "Normalized true values" => Normalized_TrueParam[[1, 6, 2, 3, 5]],
    "Estimated" => result_pick,
    "SE" => vec(std(bootresult_payoff, dims=2))
    )

```
